# 1 "ctime3.cpp"
# 1 "../blitz/array.h" 1
 
































 














 
# 1 "../blitz/blitz.h" 1
 


















































 





 
  
 
 
  
 
 
  
 


# 1 "../blitz/compiler.h" 1
 














































 
 

# 1 "../blitz/config.h" 1
 








 


 





 













































 

# 51 "../blitz/compiler.h" 2


 
























    
    
    







  



    





    





    





    













    



    
    
    







    







  







  







  





  






# 69 "../blitz/blitz.h" 2

# 1 "../blitz/tuning.h" 1
 
















































 
 



























 







 












  
  
 
 
 







 





 





 





 




# 143 "../blitz/tuning.h"


 


















# 70 "../blitz/blitz.h" 2

# 1 "../blitz/tau.h" 1
 






































 
 
 
 
 
 
 
 
 
 
 
 



# 71 "../blitz/blitz.h" 2


# 1 "/u/tveldhui/software/egcs-irix/include/g++/string" 1 3
 




# 1 "/u/tveldhui/software/egcs-irix/include/g++/std/bastring.h" 1 3
 
 

 
 
 
 
 

 
 
 
 

 
 
 

 
 
 
 
 

 
 





#pragma interface


# 1 "/u/tveldhui/software/egcs-irix/include/g++/cstddef" 1 3
 
 



# 1 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/stddef.h" 1 3






 







 

 




 


 





 


# 61 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/stddef.h" 3


 





 


















 





 

 





















typedef int  ptrdiff_t;









 




 

 


































typedef unsigned int  size_t;






















 




 





























 



















































typedef unsigned int  wint_t;




 

 

# 317 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/stddef.h" 3




 













 







# 6 "/u/tveldhui/software/egcs-irix/include/g++/cstddef" 2 3


# 35 "/u/tveldhui/software/egcs-irix/include/g++/std/bastring.h" 2 3

# 1 "/u/tveldhui/software/egcs-irix/include/g++/std/straits.h" 1 3
 
 

 
 
 
 
 

 
 
 
 

 
 
 

 
 
 
 
 

 
 





 
#pragma interface "std/straits.h"




extern "C++" {
template <class charT>
struct string_char_traits {
  typedef charT char_type;  

   

  static void assign (char_type& c1, const char_type& c2)
    { c1 = c2; }
  static bool eq (const char_type& c1, const char_type& c2)
    { return (c1 == c2); }
  static bool ne (const char_type& c1, const char_type& c2)
    { return !(c1 == c2); }
  static bool lt (const char_type& c1, const char_type& c2)
    { return (c1 < c2); }
  static char_type eos () { return char_type(); }  
  static bool is_del(char_type a) { return 0; }
   
  
   

  static int compare (const char_type* s1, const char_type* s2, size_t n)
    {
      size_t i;
      for (i = 0; i < n; ++i)
	if (ne (s1[i], s2[i]))
	  return lt (s1[i], s2[i]) ? -1 : 1;

      return 0;
    }
    
  static size_t length (const char_type* s)
    {
      size_t l = 0;
      while (ne (*s++, eos ()))
	++l;
      return l;
    }

  static char_type* copy (char_type* s1, const char_type* s2, size_t n)
    {
      for (; n--; )
	assign (s1[n], s2[n]);
      return s1;
    }

  static char_type* move (char_type* s1, const char_type* s2, size_t n)
    {
      char_type a[n];
      size_t i;
      for (i = 0; i < n; ++i)
	assign (a[i], s2[i]);
      for (i = 0; i < n; ++i)
	assign (s1[i], a[i]);
      return s1;
    }

  static char_type* set (char_type* s1, const char_type& c, size_t n)
    {
      for (; n--; )
	assign (s1[n], c);
      return s1;
    }
};

class istream;
class ostream;
# 1 "/u/tveldhui/software/egcs-irix/include/g++/cctype" 1 3
 
 



# 1 "/usr/include/ctype.h" 1 3



extern "C" {

#ident  "$Revision$"
 
















 
 

 
 
 

 




# 1 "/usr/include/standards.h" 1 3


 















#ident  "$Id$"

 





























 












 





















 

























 

















 













 












 









 















 












 





















 








 





# 36 "/usr/include/ctype.h" 2 3





























extern int isalnum(int);
extern int isalpha(int);
extern int iscntrl(int);
extern int isdigit(int);
extern int isgraph(int);
extern int islower(int);
extern int isprint(int);
extern int ispunct(int);
extern int isspace(int);
extern int __isblank(int);
extern int isupper(int);
extern int isxdigit(int);
extern int tolower(int);
extern int toupper(int);

 
extern int isascii(int);        
extern int toascii(int);        

extern int _tolower(int);
extern int _toupper(int);



# 1 "/usr/include/locale_attr.h" 1 3
 














# 1 "/usr/include/sgidefs.h" 1 3
 














extern "C" {


#ident  "$Revision$"

 















 






 









 






		 


 









 



































 













 











typedef int __int32_t;
typedef unsigned  __uint32_t;








 



































	 
typedef long long __int64_t;
typedef unsigned long long  __uint64_t;

# 214 "/usr/include/sgidefs.h" 3





typedef __int32_t __psint_t;
typedef __uint32_t __psunsigned_t;







 











 
typedef __int32_t __scint_t;
typedef __uint32_t __scunsigned_t;






}



# 16 "/usr/include/locale_attr.h" 2 3



extern "C" {

#ident  "$Revision$"

 












 







typedef struct {

    unsigned int	_class [ 257 ];
    signed short	_lower [ 257 ];
    signed short	_upper [ 257 ];

    char		_cswidth [ 7 ];
    char		_fill [ 1 ];

     

} __ctype_t;

 
typedef int	(*__isset_func_t)(int);

# 68 "/usr/include/locale_attr.h" 3

 
typedef int	(*__iscodeset_func_t)(int, wint_t);

 
typedef struct __attr {

    __ctype_t *		_ctype_tbl;	 

    struct _csinfo {			 
	unsigned char	_eucwidth[3];	 
	unsigned char	_scrwidth[3];	 
	unsigned char	_mb_cur_max;	 
    } _csinfo;

    struct _euc_func {			 
	int		_is_euc;	 
	__isset_func_t	_isset2;	 
	__isset_func_t	_isset3;	 
	__iscodeset_func_t _iscodeset;	 
    } _euc_func;

    struct _collate_res {		 
	unsigned char	_coll_as_cmp;	 
    } _collate_res;

    void *		_fill[15];	 
} __attr_t;



 
extern __attr_t __libc_attr;


}


# 89 "/usr/include/ctype.h" 2 3


























# 143 "/usr/include/ctype.h" 3



}


# 6 "/u/tveldhui/software/egcs-irix/include/g++/cctype" 2 3


# 105 "/u/tveldhui/software/egcs-irix/include/g++/std/straits.h" 2 3

# 1 "/u/tveldhui/software/egcs-irix/include/g++/cstring" 1 3
 
 




# 1 "/usr/include/string.h" 1 3



extern "C" {

#ident  "$Revision$"
 
















 
 
 

 
 
 
 

 






# 48 "/usr/include/string.h" 3
















 


extern void *memcpy(void *, const void *, size_t);
extern void *memmove(void *, const void *, size_t);
extern char *strcpy(char *, const char *);
extern char *strncpy(char *, const char *, size_t);
extern char *strcat(char *, const char *);
extern char *strncat(char *, const char *, size_t);
extern void *memccpy(void *, const void *, int, size_t);
extern int memcmp(const void *, const void *, size_t);
extern int strcmp(const char *, const char *);
extern int strcoll(const char *, const char *);
extern int strncmp(const char *, const char *, size_t);
extern size_t strxfrm(char *, const char *, size_t);

extern void *memchr(const void *, int, size_t);
extern char *strchr(const char *, int);

extern size_t strcspn(const char *, const char *);
#pragma int_to_unsigned strcspn

extern char *strpbrk(const char *, const char *);
extern char *strrchr(const char *, int);

extern size_t strspn(const char *, const char *);
#pragma int_to_unsigned strspn

extern char *strstr(const char *, const char *);

extern char *strtok(char *, const char *);
extern void *memset(void *, int, size_t);
extern char *strerror(int);
extern size_t strlen(const char *);
#pragma int_to_unsigned strlen









extern char *strdup(const char *);






# 132 "/usr/include/string.h" 3



}


# 205 "/usr/include/string.h" 3




# 7 "/u/tveldhui/software/egcs-irix/include/g++/cstring" 2 3


# 94 "/u/tveldhui/software/egcs-irix/include/g++/cstring" 3



# 106 "/u/tveldhui/software/egcs-irix/include/g++/std/straits.h" 2 3


struct string_char_traits <char> {
  typedef char char_type;

  static void assign (char_type& c1, const char_type& c2)
    { c1 = c2; }
  static bool eq (const char_type & c1, const char_type& c2)
    { return (c1 == c2); }
  static bool ne (const char_type& c1, const char_type& c2)
    { return (c1 != c2); }
  static bool lt (const char_type& c1, const char_type& c2)
    { return (c1 < c2); }
  static char_type eos () { return 0; }
  static bool is_del(char_type a) { return ((__libc_attr._ctype_tbl->_class+1)[ a ] & (0x00000008  | 0x80000000 ) ) ; }

  static int compare (const char_type* s1, const char_type* s2, size_t n)
    { return memcmp (s1, s2, n); }
  static size_t length (const char_type* s)
    { return strlen (s); }
  static char_type* copy (char_type* s1, const char_type* s2, size_t n)
    { return (char_type*) memcpy (s1, s2, n); }
  static char_type* move (char_type* s1, const char_type* s2, size_t n)
    { return (char_type*) memmove (s1, s2, n); }
  static char_type* set (char_type* s1, const char_type& c, size_t n)
    { return (char_type*) memset (s1, c, n); }
};

# 159 "/u/tveldhui/software/egcs-irix/include/g++/std/straits.h" 3

}  

# 36 "/u/tveldhui/software/egcs-irix/include/g++/std/bastring.h" 2 3


 
# 1 "/u/tveldhui/software/egcs-irix/include/g++/alloc.h" 1 3
 
















# 1 "/u/tveldhui/software/egcs-irix/include/g++/stl_config.h" 1 3
 




























 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 





# 103 "/u/tveldhui/software/egcs-irix/include/g++/stl_config.h" 3



# 1 "/u/tveldhui/software/egcs-irix/mips-sgi-irix6.5/include/_G_config.h" 1 3
  









typedef          int   _G_int8_t __attribute__((__mode__(__QI__)));
typedef unsigned int  _G_uint8_t __attribute__((__mode__(__QI__)));
typedef          int  _G_int16_t __attribute__((__mode__(__HI__)));
typedef unsigned int _G_uint16_t __attribute__((__mode__(__HI__)));
typedef          int  _G_int32_t __attribute__((__mode__(__SI__)));
typedef unsigned int _G_uint32_t __attribute__((__mode__(__SI__)));
typedef          int  _G_int64_t __attribute__((__mode__(__DI__)));
typedef unsigned int _G_uint64_t __attribute__((__mode__(__DI__)));

__extension__ typedef long long _G_llong;
__extension__ typedef unsigned long long _G_ullong;








typedef long _G_clock_t;
typedef unsigned long _G_dev_t;
typedef _G_llong _G_fpos_t;
typedef long _G_gid_t;
typedef _G_ullong _G_ino_t;
typedef unsigned long _G_mode_t;
typedef unsigned long _G_nlink_t;
typedef _G_llong _G_off_t;
typedef long _G_pid_t;



typedef int  _G_ptrdiff_t;
typedef int   _G_sigset_t;



typedef unsigned int  _G_size_t;
typedef long _G_time_t;
typedef long _G_uid_t;
typedef long _G_wchar_t;















typedef int _G_ssize_t;
typedef unsigned int _G_wint_t;
typedef char * _G_va_list;

















# 1 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/stddef.h" 1 3






 


# 19 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/stddef.h" 3



 


 





 


# 61 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/stddef.h" 3


 





 


















 





 

 


# 126 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/stddef.h" 3


 




 

 


# 188 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/stddef.h" 3





 




 


# 269 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/stddef.h" 3
















 

 

# 317 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/stddef.h" 3




 













 







# 86 "/u/tveldhui/software/egcs-irix/mips-sgi-irix6.5/include/_G_config.h" 2 3


# 106 "/u/tveldhui/software/egcs-irix/include/g++/stl_config.h" 2 3











     























# 160 "/u/tveldhui/software/egcs-irix/include/g++/stl_config.h" 3


# 174 "/u/tveldhui/software/egcs-irix/include/g++/stl_config.h" 3





























 
 
# 213 "/u/tveldhui/software/egcs-irix/include/g++/stl_config.h" 3



































 
 
 
# 18 "/u/tveldhui/software/egcs-irix/include/g++/alloc.h" 2 3



# 1 "/u/tveldhui/software/egcs-irix/include/g++/stl_alloc.h" 1 3
 












 



















 
 
 
 
 
 





# 1 "/u/tveldhui/software/egcs-irix/include/g++/iostream.h" 1 3
 

























#pragma interface



# 1 "/u/tveldhui/software/egcs-irix/include/g++/streambuf.h" 1 3
 


























#pragma interface


   



extern "C" {
# 1 "/u/tveldhui/software/egcs-irix/include/g++/libio.h" 1 3
 













































# 55 "/u/tveldhui/software/egcs-irix/include/g++/libio.h" 3




# 1 "/usr/include/sys/cdefs.h" 1 3


 


















#ident  "$Revision$"











 















# 59 "/u/tveldhui/software/egcs-irix/include/g++/libio.h" 2 3


















 















# 104 "/u/tveldhui/software/egcs-irix/include/g++/libio.h" 3











 
























 



















struct _IO_jump_t;  struct _IO_FILE;

 
# 174 "/u/tveldhui/software/egcs-irix/include/g++/libio.h" 3









    typedef void _IO_lock_t;





 

struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;
   

   
  int _pos;
# 207 "/u/tveldhui/software/egcs-irix/include/g++/libio.h" 3

};

struct _IO_FILE {
  int _flags;		 


   
   
  char* _IO_read_ptr;	 
  char* _IO_read_end;	 
  char* _IO_read_base;	 
  char* _IO_write_base;	 
  char* _IO_write_ptr;	 
  char* _IO_write_end;	 
  char* _IO_buf_base;	 
  char* _IO_buf_end;	 
   
  char *_IO_save_base;  
  char *_IO_backup_base;   
  char *_IO_save_end;  

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _blksize;



  _G_off_t  _offset;



   
  unsigned short _cur_column;
  char _unused;
  char _shortbuf[1];

   








};











struct _IO_FILE_plus;
extern struct _IO_FILE_plus _IO_stdin_, _IO_stdout_, _IO_stderr_;





 
typedef struct
{
  _G_ssize_t  (*read)  (struct _IO_FILE *, void *, _G_ssize_t )  ;
  _G_ssize_t  (*write)  (struct _IO_FILE *, const void *, _G_ssize_t )  ;
  _G_fpos_t  (*seek)  (struct _IO_FILE *, _G_off_t , int)  ;
  int (*close)  (struct _IO_FILE *)  ;
} _IO_cookie_io_functions_t;

 
struct _IO_cookie_file
{
  struct _IO_FILE file;
  const void *vtable;
  void *cookie;
  _IO_cookie_io_functions_t io_functions;
};



extern "C" {


extern int __underflow  (_IO_FILE *)  ;
extern int __uflow  (_IO_FILE *)  ;
extern int __overflow  (_IO_FILE *, int)  ;

















extern int _IO_getc  (_IO_FILE *__fp)  ;
extern int _IO_putc  (int __c, _IO_FILE *__fp)  ;
extern int _IO_feof  (_IO_FILE *__fp)  ;
extern int _IO_ferror  (_IO_FILE *__fp)  ;

extern int _IO_peekc_locked  (_IO_FILE *__fp)  ;

 



extern void _IO_flockfile  (_IO_FILE *)  ;
extern void _IO_funlockfile  (_IO_FILE *)  ;
extern int _IO_ftrylockfile  (_IO_FILE *)  ;













extern int _IO_vfscanf  (_IO_FILE *, const char *, _G_va_list , int *)  ;
extern int _IO_vfprintf  (_IO_FILE *, const char *, _G_va_list )  ;
extern _G_ssize_t  _IO_padn  (_IO_FILE *, int, _G_ssize_t )  ;
extern _G_size_t  _IO_sgetn  (_IO_FILE *, void *, _G_size_t )  ;





extern _G_fpos_t  _IO_seekoff  (_IO_FILE *, _G_off_t , int, int)  ;
extern _G_fpos_t  _IO_seekpos  (_IO_FILE *, _G_fpos_t , int)  ;


extern void _IO_free_backup_area  (_IO_FILE *)  ;


}



# 36 "/u/tveldhui/software/egcs-irix/include/g++/streambuf.h" 2 3

}
 


























extern "C++" {
class istream;  
class ostream; class streambuf;

 







typedef _G_off_t  streamoff;
typedef _G_fpos_t  streampos;

typedef _G_ssize_t  streamsize;

typedef unsigned long __fmtflags;
typedef unsigned char __iostate;

struct _ios_fields
{  
    streambuf *_strbuf;
    ostream* _tie;
    int _width;
    __fmtflags _flags;
    short  _fill;
    __iostate _state;
    __iostate _exceptions;
    int _precision;

    void *_arrays;  
};















# 124 "/u/tveldhui/software/egcs-irix/include/g++/streambuf.h" 3


class ios : public _ios_fields {
  ios& operator=(ios&);   
  ios (const ios&);  
  public:
    typedef __fmtflags fmtflags;
    typedef int iostate;
    typedef int openmode;
    typedef int streamsize;
    enum io_state {
	goodbit = 0 ,
	eofbit = 1 ,
	failbit = 2 ,
	badbit = 4  };
    enum open_mode {
	in = 1 ,
	out = 2 ,
	ate = 4 ,
	app = 8 ,
	trunc = 16 ,
	nocreate = 32 ,
	noreplace = 64 ,
	bin = 128 ,  
	binary = 128  };
    enum seek_dir { beg, cur, end};
    typedef enum seek_dir seekdir;
     
    enum { skipws= 01 ,
	   left= 02 , right= 04 , internal= 010 ,
	   dec= 020 , oct= 040 , hex= 0100 ,
	   showbase= 0200 , showpoint= 0400 ,
	   uppercase= 01000 , showpos= 02000 ,
	   scientific= 04000 , fixed= 010000 ,
	   unitbuf= 020000 , stdio= 040000 



	   };
    enum {  
	basefield=dec+oct+hex,
	floatfield = scientific+fixed,
	adjustfield = left+right+internal
    };

# 177 "/u/tveldhui/software/egcs-irix/include/g++/streambuf.h" 3


    ostream* tie() const { return _tie; }
    ostream* tie(ostream* val) { ostream* save=_tie; _tie=val; return save; }

     
    short  fill() const { return _fill; }
    short  fill(short  newf)
	{short  oldf = _fill; _fill = newf; return oldf;}
    fmtflags flags() const { return _flags; }
    fmtflags flags(fmtflags new_val) {
	fmtflags old_val = _flags; _flags = new_val; return old_val; }
    int precision() const { return _precision; }
    int precision(int newp) {
	unsigned short oldp = _precision; _precision = (unsigned short)newp;
	return oldp; }
    fmtflags setf(fmtflags val) {
	fmtflags oldbits = _flags;
	_flags |= val; return oldbits; }
    fmtflags setf(fmtflags val, fmtflags mask) {
	fmtflags oldbits = _flags;
	_flags = (_flags & ~mask) | (val & mask); return oldbits; }
    fmtflags unsetf(fmtflags mask) {
	fmtflags oldbits = _flags;
	_flags &= ~mask; return oldbits; }
    int width() const { return _width; }
    int width(int val) { int save = _width; _width = val; return save; }




    void _throw_failure() const { }

    void clear(iostate state = 0) {
	_state = _strbuf ? state : state|badbit;
	if (_state & _exceptions) _throw_failure(); }
    void set(iostate flag) { _state |= flag;
	if (_state & _exceptions) _throw_failure(); }
    void setstate(iostate flag) { _state |= flag;  
	if (_state & _exceptions) _throw_failure(); }
    int good() const { return _state == 0; }
    int eof() const { return _state & ios::eofbit; }
    int fail() const { return _state & (ios::badbit|ios::failbit); }
    int bad() const { return _state & ios::badbit; }
    iostate rdstate() const { return _state; }
    operator void*() const { return fail() ? (void*)0 : (void*)(-1); }
    int operator!() const { return fail(); }
    iostate exceptions() const { return _exceptions; }
    void exceptions(iostate enable) {
	_exceptions = enable;
	if (_state & _exceptions) _throw_failure(); }

    streambuf* rdbuf() const { return _strbuf; }
    streambuf* rdbuf(streambuf *_s) {
      streambuf *_old = _strbuf; _strbuf = _s; clear (); return _old; }

    static int sync_with_stdio(int on);
    static void sync_with_stdio() { sync_with_stdio(1); }
    static fmtflags bitalloc();
    static int xalloc();
    void*& pword(int);
    void* pword(int) const;
    long& iword(int);
    long iword(int) const;









     
    class Init {
    public:
      Init () { }
    };

  protected:
    inline ios(streambuf* sb = 0, ostream* tie_to = 0);
    inline virtual ~ios();
    inline void init(streambuf* sb, ostream* tie = 0);
};




typedef ios::seek_dir _seek_dir;


 
 
 
 
 

 
 
class streammarker : private _IO_marker {
    friend class streambuf;
    void set_offset(int offset) { _pos = offset; }
  public:
    streammarker(streambuf *sb);
    ~streammarker();
    int saving() { return  1; }
    int delta(streammarker&);
    int delta();
};

struct streambuf : public _IO_FILE {  
    friend class ios;
    friend class istream;
    friend class ostream;
    friend class streammarker;
    const void *&_vtable() { return *(const void**)((_IO_FILE*)this + 1); }
  protected:
    static streambuf* _list_all;  
    _IO_FILE*& xchain() { return _chain; }
    void _un_link();
    void _link_in();
    char* gptr() const
      { return _flags  & 0x100  ? _IO_save_base : _IO_read_ptr; }
    char* pptr() const { return _IO_write_ptr; }
    char* egptr() const
      { return _flags  & 0x100  ? _IO_save_end : _IO_read_end; }
    char* epptr() const { return _IO_write_end; }
    char* pbase() const { return _IO_write_base; }
    char* eback() const
      { return _flags  & 0x100  ? _IO_save_base : _IO_read_base;}
    char* base() const { return _IO_buf_base; }
    char* ebuf() const { return _IO_buf_end; }
    int blen() const { return _IO_buf_end - _IO_buf_base; }
    void xput_char(char c) { *_IO_write_ptr++ = c; }
    int xflags() { return _flags ; }
    int xflags(int f) {int fl = _flags ; _flags  = f; return fl;}
    void xsetflags(int f) { _flags  |= f; }
    void xsetflags(int f, int mask)
      { _flags  = (_flags  & ~mask) | (f & mask); }
    void gbump(int n)
      { _flags  & 0x100  ? (_IO_save_base+=n):(_IO_read_ptr+=n);}
    void pbump(int n) { _IO_write_ptr += n; }
    void setb(char* b, char* eb, int a=0);
    void setp(char* p, char* ep)
      { _IO_write_base=_IO_write_ptr=p; _IO_write_end=ep; }
    void setg(char* eb, char* g, char *eg) {
      if (_flags  & 0x100 ) _IO_free_backup_area(this); 
      _IO_read_base = eb; _IO_read_ptr = g; _IO_read_end = eg; }
    char *shortbuf() { return _shortbuf; }

    int in_backup() { return _flags & 0x100 ; }
     
    char *Gbase() { return in_backup() ? _IO_save_base : _IO_read_base; }
     
    char *eGptr() { return in_backup() ? _IO_save_end : _IO_read_end; }
     
    char *Bbase() { return in_backup() ? _IO_read_base : _IO_save_base; }
    char *Bptr() { return _IO_backup_base; }
     
    char *eBptr() { return in_backup() ? _IO_read_end : _IO_save_end; }
    char *Nbase() { return _IO_save_base; }
    char *eNptr() { return _IO_save_end; }
    int have_backup() { return _IO_save_base != __null ; }
    int have_markers() { return _markers != __null ; }
    void free_backup_area();
    void unsave_markers();  
    int put_mode() { return _flags & 0x800 ; }
    int switch_to_get_mode();
    
    streambuf(int flags=0);
  public:
    static int flush_all();
    static void flush_all_linebuffered();  
    virtual ~streambuf();
    virtual int overflow(int c = (-1) );  
    virtual int underflow();  
    virtual int uflow();  
    virtual int pbackfail(int c);
 
    virtual streamsize xsputn(const char* s, streamsize n);
    virtual streamsize xsgetn(char* s, streamsize n);
    virtual streampos seekoff(streamoff, _seek_dir, int mode=ios::in|ios::out);
    virtual streampos seekpos(streampos pos, int mode = ios::in|ios::out);

    streampos pubseekoff(streamoff o, _seek_dir d, int mode=ios::in|ios::out)
      { return _IO_seekoff (this, o, d, mode); }
    streampos pubseekpos(streampos pos, int mode = ios::in|ios::out)
      { return _IO_seekpos (this, pos, mode); }
    streampos sseekoff(streamoff, _seek_dir, int mode=ios::in|ios::out);
    streampos sseekpos(streampos pos, int mode = ios::in|ios::out);
    virtual streambuf* setbuf(char* p, int len);
    virtual int sync();
    virtual int doallocate();

    int seekmark(streammarker& mark, int delta = 0);
    int sputbackc(char c);
    int sungetc();
    int unbuffered() { return _flags & 2  ? 1 : 0; }
    int linebuffered() { return _flags & 0x200  ? 1 : 0; }
    void unbuffered(int i)
	{ if (i) _flags |= 2 ; else _flags &= ~2 ; }
    void linebuffered(int i)
	{ if (i) _flags |= 0x200 ; else _flags &= ~0x200 ; }
    int allocate() {  
	if (base() || unbuffered()) return 0;
	else return doallocate(); }
     
    void allocbuf() { if (base() == __null ) doallocbuf(); }
    void doallocbuf();
    int in_avail() { return _IO_read_end - _IO_read_ptr; }
    int out_waiting() { return _IO_write_ptr - _IO_write_base; }
    streamsize sputn(const char* s, streamsize n) { return xsputn(s, n); }
    streamsize padn(char pad, streamsize n) { return _IO_padn(this, pad, n); }
    streamsize sgetn(char* s, streamsize n) { return _IO_sgetn(this, s, n); }
    int ignore(int);
    int get_column();
    int set_column(int);
    long sgetline(char* buf, _G_size_t  n, char delim, int putback_delim);
    int sputc(int c) { return _IO_putc(c, this); }
    int sbumpc() { return _IO_getc(this); }
    int sgetc() { return ((  this  )->_IO_read_ptr >= (  this  )->_IO_read_end && __underflow (  this  ) == (-1)  ? (-1)  : *(unsigned char *) (  this  )->_IO_read_ptr)  ; }
    int snextc() {
	if (_IO_read_ptr >= _IO_read_end && __underflow(this) == (-1) )
	  return (-1) ;
	else return _IO_read_ptr++, sgetc(); }
    void stossc() { if (_IO_read_ptr < _IO_read_end) _IO_read_ptr++; }
    int vscan(char const *fmt0, _G_va_list  ap, ios* stream = __null );
    int scan(char const *fmt0 ...);
    int vform(char const *fmt0, _G_va_list  ap);
    int form(char const *fmt0 ...);




    virtual streamsize sys_read(char* buf, streamsize size);
    virtual streamsize sys_write(const char*, streamsize);
    virtual streampos sys_seek(streamoff, _seek_dir);
    virtual int sys_close();
    virtual int sys_stat(void*);  




};

 
 

class filebuf : public streambuf {
  protected:
    void init();
  public:
    static const int openprot;  
    filebuf();
    filebuf(int fd);
    filebuf(int fd, char* p, int len);



    ~filebuf();
    filebuf* attach(int fd);
    filebuf* open(const char *filename, const char *mode);
    filebuf* open(const char *filename, ios::openmode mode, int prot = 0664);
    virtual int underflow();
    virtual int overflow(int c = (-1) );
    int is_open() const { return _fileno >= 0; }
    int fd() const { return is_open() ? _fileno : (-1) ; }
    filebuf* close();
    virtual int doallocate();
    virtual streampos seekoff(streamoff, _seek_dir, int mode=ios::in|ios::out);
    virtual streambuf* setbuf(char* p, int len);
    streamsize xsputn(const char* s, streamsize n);
    streamsize xsgetn(char* s, streamsize n);
    virtual int sync();
  protected:  
 
    int is_reading() { return eback() != egptr(); }
    char* cur_ptr() { return is_reading() ?  gptr() : pptr(); }
     
    char* file_ptr() { return eGptr(); }
     
    virtual streamsize sys_read(char* buf, streamsize size);
    virtual streampos sys_seek(streamoff, _seek_dir);
    virtual streamsize sys_write(const char*, streamsize);
    virtual int sys_stat(void*);  
    virtual int sys_close();




};

inline void ios::init(streambuf* sb, ostream* tie_to) {
		_state = sb ? ios::goodbit : ios::badbit; _exceptions=0;
		_strbuf=sb; _tie = tie_to; _width=0; _fill=' ';

		_flags=ios::skipws|ios::dec;



		_precision=6; _arrays = 0; }

inline ios::ios(streambuf* sb, ostream* tie_to) { init(sb, tie_to); }

inline ios::~ios() {



    if (_arrays) delete [] _arrays;
}
}  

# 31 "/u/tveldhui/software/egcs-irix/include/g++/iostream.h" 2 3


extern "C++" {
class istream; class ostream;
typedef ios& (*__manip)(ios&);
typedef istream& (*__imanip)(istream&);
typedef ostream& (*__omanip)(ostream&);

extern istream& ws(istream& ins);
extern ostream& flush(ostream& outs);
extern ostream& endl(ostream& outs);
extern ostream& ends(ostream& outs);

class ostream : virtual public ios
{
     
    void do_osfx();
  public:
    ostream() { }
    ostream(streambuf* sb, ostream* tied= __null );
    int opfx() {
	if (!good()) return 0;
	else { if (_tie) _tie->flush();  ; return 1;} }
    void osfx() {  ;
		  if (flags() & (ios::unitbuf|ios::stdio))
		      do_osfx(); }
    ostream& flush();
    ostream& put(char c) { _strbuf->sputc(c); return *this; }





    ostream& write(const char *s, streamsize n);
    ostream& write(const unsigned char *s, streamsize n)
      { return write((const char*)s, n);}
    ostream& write(const signed char *s, streamsize n)
      { return write((const char*)s, n);}
    ostream& write(const void *s, streamsize n)
      { return write((const char*)s, n);}
    ostream& seekp(streampos);
    ostream& seekp(streamoff, _seek_dir);
    streampos tellp();
    ostream& form(const char *format ...);
    ostream& vform(const char *format, _G_va_list  args);

    ostream& operator<<(char c);
    ostream& operator<<(unsigned char c) { return (*this) << (char)c; }
    ostream& operator<<(signed char c) { return (*this) << (char)c; }
    ostream& operator<<(const char *s);
    ostream& operator<<(const unsigned char *s)
	{ return (*this) << (const char*)s; }
    ostream& operator<<(const signed char *s)
	{ return (*this) << (const char*)s; }
    ostream& operator<<(const void *p);
    ostream& operator<<(int n);
    ostream& operator<<(unsigned int n);
    ostream& operator<<(long n);
    ostream& operator<<(unsigned long n);

    __extension__ ostream& operator<<(long long n);
    __extension__ ostream& operator<<(unsigned long long n);

    ostream& operator<<(short n) {return operator<<((int)n);}
    ostream& operator<<(unsigned short n) {return operator<<((unsigned int)n);}

    ostream& operator<<(bool b) { return operator<<((int)b); }

    ostream& operator<<(double n);
    ostream& operator<<(float n) { return operator<<((double)n); }



    ostream& operator<<(long double n) { return operator<<((double)n); }

    ostream& operator<<(__omanip func) { return (*func)(*this); }
    ostream& operator<<(__manip func) {(*func)(*this); return *this;}
    ostream& operator<<(streambuf*);



};

class istream : virtual public ios
{
     
protected:
    _G_size_t  _gcount;

    int _skip_ws();
  public:
    istream(): _gcount (0) { }
    istream(streambuf* sb, ostream*tied= __null );
    istream& get(char* ptr, int len, char delim = '\n');
    istream& get(unsigned char* ptr, int len, char delim = '\n')
	{ return get((char*)ptr, len, delim); }
    istream& get(char& c);
    istream& get(unsigned char& c) { return get((char&)c); }
    istream& getline(char* ptr, int len, char delim = '\n');
    istream& getline(unsigned char* ptr, int len, char delim = '\n')
	{ return getline((char*)ptr, len, delim); }
    istream& get(signed char& c)  { return get((char&)c); }
    istream& get(signed char* ptr, int len, char delim = '\n')
	{ return get((char*)ptr, len, delim); }
    istream& getline(signed char* ptr, int len, char delim = '\n')
	{ return getline((char*)ptr, len, delim); }
    istream& read(char *ptr, streamsize n);
    istream& read(unsigned char *ptr, streamsize n)
      { return read((char*)ptr, n); }
    istream& read(signed char *ptr, streamsize n)
      { return read((char*)ptr, n); }
    istream& read(void *ptr, streamsize n)
      { return read((char*)ptr, n); }
    istream& get(streambuf& sb, char delim = '\n');
    istream& gets(char **s, char delim = '\n');
    int ipfx(int need = 0) {
	if (!good()) { set(ios::failbit); return 0; }
	else {
	   ;
	  if (_tie && (need == 0 || rdbuf()->in_avail() < need)) _tie->flush();
	  if (!need && (flags() & ios::skipws)) return _skip_ws();
	  else return 1;
	}
    }
    int ipfx0() {  
	if (!good()) { set(ios::failbit); return 0; }
	else {
	   ;
	  if (_tie) _tie->flush();
	  if (flags() & ios::skipws) return _skip_ws();
	  else return 1;
	}
    }
    int ipfx1() {  
	if (!good()) { set(ios::failbit); return 0; }
	else {
	   ;
	  if (_tie && rdbuf()->in_avail() == 0) _tie->flush();
	  return 1;
	}
    }
    void isfx() {  ; }
    int get() { if (!ipfx1()) return (-1) ;
		else { int ch = _strbuf->sbumpc();
		       if (ch == (-1) ) set(ios::eofbit);
		       return ch;
		     } }
    int peek();
    _G_size_t  gcount() { return _gcount; }
    istream& ignore(int n=1, int delim = (-1) );
    int sync ();
    istream& seekg(streampos);
    istream& seekg(streamoff, _seek_dir);
    streampos tellg();
    istream& putback(char ch) {
	if (good() && _strbuf->sputbackc(ch) == (-1) ) clear(ios::badbit);
	return *this;}
    istream& unget() {
	if (good() && _strbuf->sungetc() == (-1) ) clear(ios::badbit);
	return *this;}
    istream& scan(const char *format ...);
    istream& vscan(const char *format, _G_va_list  args);






    istream& operator>>(char*);
    istream& operator>>(unsigned char* p) { return operator>>((char*)p); }
    istream& operator>>(signed char*p) { return operator>>((char*)p); }
    istream& operator>>(char& c);
    istream& operator>>(unsigned char& c) {return operator>>((char&)c);}
    istream& operator>>(signed char& c) {return operator>>((char&)c);}
    istream& operator>>(int&);
    istream& operator>>(long&);

    __extension__ istream& operator>>(long long&);
    __extension__ istream& operator>>(unsigned long long&);

    istream& operator>>(short&);
    istream& operator>>(unsigned int&);
    istream& operator>>(unsigned long&);
    istream& operator>>(unsigned short&);

    istream& operator>>(bool&);

    istream& operator>>(float&);
    istream& operator>>(double&);
    istream& operator>>(long double&);
    istream& operator>>( __manip func) {(*func)(*this); return *this;}
    istream& operator>>(__imanip func) { return (*func)(*this); }
    istream& operator>>(streambuf*);
};

class iostream : public istream, public ostream
{
  public:
    iostream() { }
    iostream(streambuf* sb, ostream*tied= __null );
};

class _IO_istream_withassign : public istream {
public:
  _IO_istream_withassign& operator=(istream&);
  _IO_istream_withassign& operator=(_IO_istream_withassign& rhs)
    { return operator= (static_cast<istream&> (rhs)); }
};

class _IO_ostream_withassign : public ostream {
public:
  _IO_ostream_withassign& operator=(ostream&);
  _IO_ostream_withassign& operator=(_IO_ostream_withassign& rhs)
    { return operator= (static_cast<ostream&> (rhs)); }
};

extern _IO_istream_withassign cin;
 
extern _IO_ostream_withassign cout, cerr;

extern _IO_ostream_withassign clog



;

extern istream& lock(istream& ins);
extern istream& unlock(istream& ins);
extern ostream& lock(ostream& outs);
extern ostream& unlock(ostream& outs);

struct Iostream_init { } ;   

inline ios& dec(ios& i)
{ i.setf(ios::dec, ios::dec|ios::hex|ios::oct); return i; }
inline ios& hex(ios& i)
{ i.setf(ios::hex, ios::dec|ios::hex|ios::oct); return i; }
inline ios& oct(ios& i)
{ i.setf(ios::oct, ios::dec|ios::hex|ios::oct); return i; }
}  


# 45 "/u/tveldhui/software/egcs-irix/include/g++/stl_alloc.h" 2 3











# 1 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/stddef.h" 1 3
# 342 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/stddef.h" 3

# 56 "/u/tveldhui/software/egcs-irix/include/g++/stl_alloc.h" 2 3

# 1 "/usr/include/stdlib.h" 1 3



extern "C" {

#ident  "$Revision$"
 
















 
 

 
 
 

 









 



 


# 64 "/usr/include/stdlib.h" 3



 






















typedef	struct {
	 int	quot;
	 int	rem;
	} div_t;

typedef struct {
	 long	quot;
	 long	rem;
	} ldiv_t;

# 108 "/usr/include/stdlib.h" 3






typedef int	ssize_t;







# 130 "/usr/include/stdlib.h" 3













 
extern double atof(const char *);
extern int atoi(const char *);
extern long int atol(const char *);
extern double strtod(const char *, char **);
extern long int strtol(const char *, char **, int);
extern unsigned long int strtoul(const char *, char **, int);
extern int rand(void);
extern void srand(unsigned int);
extern void *calloc(size_t, size_t);
extern void free(void *);
extern void *malloc(size_t);
extern void *realloc(void *, size_t);







extern void abort(void);
extern int atexit(void (*)(void));
extern void exit(int);




extern char *getenv(const char *);
extern int system(const char *);
extern void *bsearch(const void *, const void *, size_t, size_t,
	int (*)(const void *, const void *));
extern void qsort(void *, size_t, size_t,
	int (*)(const void *, const void *));




inline int abs(int x) {return x > 0 ? x : -x;}









extern div_t div(int, int);
extern long int labs(long);




extern ldiv_t ldiv(long, long);
extern int mbtowc(wchar_t *, const char *, size_t);
extern int mblen(const char *, size_t);
extern int wctomb(char *, wchar_t);
extern size_t mbstowcs(wchar_t *, const char *, size_t);
extern size_t wcstombs(char *, const wchar_t *, size_t);


	 
extern int putenv(const char *);
extern double	drand48(void);
extern double	erand48(unsigned short [3]);
extern long	lrand48(void);
extern long	nrand48(unsigned short [3]);
extern long	mrand48(void);
extern long	jrand48(unsigned short [3]);
extern void	srand48(long);
extern void	lcong48(unsigned short int [7]);
extern void     setkey(const char *);
extern unsigned short * seed48(unsigned short int [3]);



	 
extern long a64l(const char *);
extern char *ecvt(double, int, int *, int *);
extern char *fcvt(double, int, int *, int *);
extern char *gcvt(double, int, char *);
extern int getsubopt(char **, char * const *, char **);
extern int grantpt(int);
extern char *initstate(unsigned int, char *, size_t);
extern char *l64a(long);
extern char *mktemp(char *);
extern int mkstemp(char *);
extern char *ptsname(int);
extern long random(void);
extern char *realpath(const char *, char *);
extern char *setstate(const char *);
extern void srandom(unsigned);
extern int ttyslot(void);
extern int unlockpt(int);
extern void *valloc(size_t);










# 280 "/usr/include/stdlib.h" 3


# 305 "/usr/include/stdlib.h" 3






# 320 "/usr/include/stdlib.h" 3





}


# 343 "/usr/include/stdlib.h" 3



# 57 "/u/tveldhui/software/egcs-irix/include/g++/stl_alloc.h" 2 3


# 1 "/u/tveldhui/software/egcs-irix/mips-sgi-irix6.5/include/assert.h" 1 3
 








# 19 "/u/tveldhui/software/egcs-irix/mips-sgi-irix6.5/include/assert.h" 3




 

extern "C" {
extern void __eprintf (const char *, const char *, unsigned, const char *)
    __attribute__ ((noreturn));
}












# 52 "/u/tveldhui/software/egcs-irix/mips-sgi-irix6.5/include/assert.h" 3



# 59 "/u/tveldhui/software/egcs-irix/include/g++/stl_alloc.h" 2 3










# 80 "/u/tveldhui/software/egcs-irix/include/g++/stl_alloc.h" 3

# 90 "/u/tveldhui/software/egcs-irix/include/g++/stl_alloc.h" 3

# 108 "/u/tveldhui/software/egcs-irix/include/g++/stl_alloc.h" 3


 






 





 
 









template <int inst>
class __malloc_alloc_template {

private:

static void *oom_malloc(size_t);

static void *oom_realloc(void *, size_t);


    static void (* __malloc_alloc_oom_handler)();


public:

static void * allocate(size_t n)
{
    void *result = malloc(n);
    if (0 == result) result = oom_malloc(n);
    return result;
}

static void deallocate(void *p, size_t  )
{
    free(p);
}

static void * reallocate(void *p, size_t  , size_t new_sz)
{
    void * result = realloc(p, new_sz);
    if (0 == result) result = oom_realloc(p, new_sz);
    return result;
}

static void (* set_malloc_handler(void (*f)()))()
{
    void (* old)() = __malloc_alloc_oom_handler;
    __malloc_alloc_oom_handler = f;
    return(old);
}

};

 


template <int inst>
void (* __malloc_alloc_template<inst>::__malloc_alloc_oom_handler)() = 0;


template <int inst>
void * __malloc_alloc_template<inst>::oom_malloc(size_t n)
{
    void (* my_malloc_handler)();
    void *result;

    for (;;) {
        my_malloc_handler = __malloc_alloc_oom_handler;
        if (0 == my_malloc_handler) { cerr << "out of memory" << endl; exit(1) ; }
        (*my_malloc_handler)();
        result = malloc(n);
        if (result) return(result);
    }
}

template <int inst>
void * __malloc_alloc_template<inst>::oom_realloc(void *p, size_t n)
{
    void (* my_malloc_handler)();
    void *result;

    for (;;) {
        my_malloc_handler = __malloc_alloc_oom_handler;
        if (0 == my_malloc_handler) { cerr << "out of memory" << endl; exit(1) ; }
        (*my_malloc_handler)();
        result = realloc(p, n);
        if (result) return(result);
    }
}

typedef __malloc_alloc_template<0> malloc_alloc;

template<class T, class Alloc>
class simple_alloc {

public:
    static T *allocate(size_t n)
                { return 0 == n? 0 : (T*) Alloc::allocate(n * sizeof (T)); }
    static T *allocate(void)
                { return (T*) Alloc::allocate(sizeof (T)); }
    static void deallocate(T *p, size_t n)
                { if (0 != n) Alloc::deallocate(p, n * sizeof (T)); }
    static void deallocate(T *p)
                { Alloc::deallocate(p, sizeof (T)); }
};

 
 
 
 
 
template <class Alloc>
class debug_alloc {

private:

enum {extra = 8};        
                         
                         

public:

static void * allocate(size_t n)
{
    char *result = (char *)Alloc::allocate(n + extra);
    *(size_t *)result = n;
    return result + extra;
}

static void deallocate(void *p, size_t n)
{
    char * real_p = (char *)p - extra;
    ((void) (( *(size_t *)real_p == n ) ? 0 : (__eprintf ("%s:%u: failed assertion `%s'\n",	  "/u/tveldhui/software/egcs-irix/include/g++/stl_alloc.h" ,   256 ,  "*(size_t *)real_p == n" ), 0) )) ;
    Alloc::deallocate(real_p, n + extra);
}

static void * reallocate(void *p, size_t old_sz, size_t new_sz)
{
    char * real_p = (char *)p - extra;
    ((void) (( *(size_t *)real_p == old_sz ) ? 0 : (__eprintf ("%s:%u: failed assertion `%s'\n",	  "/u/tveldhui/software/egcs-irix/include/g++/stl_alloc.h" ,   263 ,  "*(size_t *)real_p == old_sz" ), 0) )) ;
    char * result = (char *)
                  Alloc::reallocate(real_p, old_sz + extra, new_sz + extra);
    *(size_t *)result = new_sz;
    return result + extra;
}


};










 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 







template <bool threads, int inst>
class __default_alloc_template {

private:
   
   

    enum {__ALIGN = 8};
    enum {__MAX_BYTES = 128};
    enum {__NFREELISTS = __MAX_BYTES/__ALIGN};

  static size_t ROUND_UP(size_t bytes) {
        return (((bytes) + __ALIGN-1) & ~(__ALIGN - 1));
  }
private :
  union obj {
        union obj * free_list_link;
        char client_data[1];     
  };
private:




    static obj *   free_list[__NFREELISTS]; 

  static  size_t FREELIST_INDEX(size_t bytes) {
        return (((bytes) + __ALIGN-1)/__ALIGN - 1);
  }

   
  static void *refill(size_t n);
   
   
  static char *chunk_alloc(size_t size, int &nobjs);

   
  static char *start_free;
  static char *end_free;
  static size_t heap_size;











# 378 "/u/tveldhui/software/egcs-irix/include/g++/stl_alloc.h" 3


    class lock {
        public:
            lock() {  ; }
            ~lock() {  ; }
    };
    friend class lock;

public:

   
  static void * allocate(size_t n)
  {
    obj *   * my_free_list;
    obj *   result;

    if (n > (size_t) __MAX_BYTES) {
        return(malloc_alloc::allocate(n));
    }
    my_free_list = free_list + FREELIST_INDEX(n);
     
     
     




    result = *my_free_list;
    if (result == 0) {
        void *r = refill(ROUND_UP(n));
        return r;
    }
    *my_free_list = result -> free_list_link;
    return (result);
  };

   
  static void deallocate(void *p, size_t n)
  {
    obj *q = (obj *)p;
    obj *   * my_free_list;

    if (n > (size_t) __MAX_BYTES) {
        malloc_alloc::deallocate(p, n);
        return;
    }
    my_free_list = free_list + FREELIST_INDEX(n);
     




    q -> free_list_link = *my_free_list;
    *my_free_list = q;
     
  }

  static void * reallocate(void *p, size_t old_sz, size_t new_sz);

} ;

typedef __default_alloc_template< false , 0> alloc;
typedef __default_alloc_template<false, 0> single_client_alloc;



 
 
 
 
template <bool threads, int inst>
char*
__default_alloc_template<threads, inst>::chunk_alloc(size_t size, int& nobjs)
{
    char * result;
    size_t total_bytes = size * nobjs;
    size_t bytes_left = end_free - start_free;

    if (bytes_left >= total_bytes) {
        result = start_free;
        start_free += total_bytes;
        return(result);
    } else if (bytes_left >= size) {
        nobjs = bytes_left/size;
        total_bytes = size * nobjs;
        result = start_free;
        start_free += total_bytes;
        return(result);
    } else {
        size_t bytes_to_get = 2 * total_bytes + ROUND_UP(heap_size >> 4);
         
        if (bytes_left > 0) {
            obj *   * my_free_list =
                        free_list + FREELIST_INDEX(bytes_left);

            ((obj *)start_free) -> free_list_link = *my_free_list;
            *my_free_list = (obj *)start_free;
        }
        start_free = (char *)malloc(bytes_to_get);
        if (0 == start_free) {
            int i;
            obj *   * my_free_list, *p;
             
             
             
            for (i = size; i <= __MAX_BYTES; i += __ALIGN) {
                my_free_list = free_list + FREELIST_INDEX(i);
                p = *my_free_list;
                if (0 != p) {
                    *my_free_list = p -> free_list_link;
                    start_free = (char *)p;
                    end_free = start_free + i;
                    return(chunk_alloc(size, nobjs));
                     
                     
                }
            }
	    end_free = 0;	 
            start_free = (char *)malloc_alloc::allocate(bytes_to_get);
             
             
             
        }
        heap_size += bytes_to_get;
        end_free = start_free + bytes_to_get;
        return(chunk_alloc(size, nobjs));
    }
}


 
 
 
template <bool threads, int inst>
void* __default_alloc_template<threads, inst>::refill(size_t n)
{
    int nobjs = 20;
    char * chunk = chunk_alloc(n, nobjs);
    obj *   * my_free_list;
    obj * result;
    obj * current_obj, * next_obj;
    int i;

    if (1 == nobjs) return(chunk);
    my_free_list = free_list + FREELIST_INDEX(n);

     
      result = (obj *)chunk;
      *my_free_list = next_obj = (obj *)(chunk + n);
      for (i = 1; ; i++) {
        current_obj = next_obj;
        next_obj = (obj *)((char *)next_obj + n);
        if (nobjs - 1 == i) {
            current_obj -> free_list_link = 0;
            break;
        } else {
            current_obj -> free_list_link = next_obj;
        }
      }
    return(result);
}

template <bool threads, int inst>
void*
__default_alloc_template<threads, inst>::reallocate(void *p,
                                                    size_t old_sz,
                                                    size_t new_sz)
{
    void * result;
    size_t copy_sz;

    if (old_sz > (size_t) __MAX_BYTES && new_sz > (size_t) __MAX_BYTES) {
        return(realloc(p, new_sz));
    }
    if (ROUND_UP(old_sz) == ROUND_UP(new_sz)) return(p);
    result = allocate(new_sz);
    copy_sz = new_sz > old_sz? old_sz : new_sz;
    memcpy(result, p, copy_sz);
    deallocate(p, old_sz);
    return(result);
}

















# 653 "/u/tveldhui/software/egcs-irix/include/g++/stl_alloc.h" 3


template <bool threads, int inst>
char *__default_alloc_template<threads, inst>::start_free = 0;

template <bool threads, int inst>
char *__default_alloc_template<threads, inst>::end_free = 0;

template <bool threads, int inst>
size_t __default_alloc_template<threads, inst>::heap_size = 0;

template <bool threads, int inst>
__default_alloc_template<threads, inst>::obj *  
__default_alloc_template<threads, inst> ::free_list[



    __default_alloc_template<threads, inst>::__NFREELISTS

] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };
 
 
 














 





 
 
 
# 21 "/u/tveldhui/software/egcs-irix/include/g++/alloc.h" 2 3



# 38 "/u/tveldhui/software/egcs-irix/include/g++/alloc.h" 3




 
 
 
# 39 "/u/tveldhui/software/egcs-irix/include/g++/std/bastring.h" 2 3


extern "C++" {
class istream; class ostream;

# 1 "/u/tveldhui/software/egcs-irix/include/g++/iterator" 1 3
 





























# 1 "/u/tveldhui/software/egcs-irix/include/g++/stl_relops.h" 1 3
 

























 






 

template <class T>
inline bool operator!=(const T& x, const T& y) {
  return !(x == y);
}

template <class T>
inline bool operator>(const T& x, const T& y) {
  return y < x;
}

template <class T>
inline bool operator<=(const T& x, const T& y) {
  return !(y < x);
}

template <class T>
inline bool operator>=(const T& x, const T& y) {
  return !(x < y);
}

 



 
 
 
# 31 "/u/tveldhui/software/egcs-irix/include/g++/iterator" 2 3

# 1 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/stddef.h" 1 3
# 342 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/stddef.h" 3

# 32 "/u/tveldhui/software/egcs-irix/include/g++/iterator" 2 3


# 1 "/u/tveldhui/software/egcs-irix/include/g++/stl_iterator.h" 1 3
 

























 






 

struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag : public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};

template <class T, class Distance> struct input_iterator {
  typedef input_iterator_tag iterator_category;
  typedef T                  value_type;
  typedef Distance           difference_type;
  typedef T*                 pointer;
  typedef T&                 reference;
};

struct output_iterator {
  typedef output_iterator_tag iterator_category;
  typedef void                value_type;
  typedef void                difference_type;
  typedef void                pointer;
  typedef void                reference;
};

template <class T, class Distance> struct forward_iterator {
  typedef forward_iterator_tag iterator_category;
  typedef T                    value_type;
  typedef Distance             difference_type;
  typedef T*                   pointer;
  typedef T&                   reference;
};


template <class T, class Distance> struct bidirectional_iterator {
  typedef bidirectional_iterator_tag iterator_category;
  typedef T                          value_type;
  typedef Distance                   difference_type;
  typedef T*                         pointer;
  typedef T&                         reference;
};

template <class T, class Distance> struct random_access_iterator {
  typedef random_access_iterator_tag iterator_category;
  typedef T                          value_type;
  typedef Distance                   difference_type;
  typedef T*                         pointer;
  typedef T&                         reference;
};

# 93 "/u/tveldhui/software/egcs-irix/include/g++/stl_iterator.h" 3




template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type        value_type;
  typedef typename Iterator::difference_type   difference_type;
  typedef typename Iterator::pointer           pointer;
  typedef typename Iterator::reference         reference;
};

template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T                          value_type;
  typedef ptrdiff_t                  difference_type;
  typedef T*                         pointer;
  typedef T&                         reference;
};

template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T                          value_type;
  typedef ptrdiff_t                  difference_type;
  typedef const T*                   pointer;
  typedef const T&                   reference;
};

template <class Iterator>
inline typename iterator_traits<Iterator>::iterator_category
iterator_category(const Iterator&) {
  typedef typename iterator_traits<Iterator>::iterator_category category;
  return category();
}

template <class Iterator>
inline typename iterator_traits<Iterator>::difference_type*
distance_type(const Iterator&) {
  return static_cast<typename iterator_traits<Iterator>::difference_type*>(0);
}

template <class Iterator>
inline typename iterator_traits<Iterator>::value_type*
value_type(const Iterator&) {
  return static_cast<typename iterator_traits<Iterator>::value_type*>(0);
}

# 226 "/u/tveldhui/software/egcs-irix/include/g++/stl_iterator.h" 3


template <class InputIterator, class Distance>
inline void __distance(InputIterator first, InputIterator last, Distance& n, 
                       input_iterator_tag) {
  while (first != last) { ++first; ++n; }
}

template <class RandomAccessIterator, class Distance>
inline void __distance(RandomAccessIterator first, RandomAccessIterator last, 
                       Distance& n, random_access_iterator_tag) {
  n += last - first;
}

template <class InputIterator, class Distance>
inline void distance(InputIterator first, InputIterator last, Distance& n) {
  __distance(first, last, n, iterator_category(first));
}



template <class InputIterator>
inline iterator_traits<InputIterator>::difference_type
__distance(InputIterator first, InputIterator last, input_iterator_tag) {
  iterator_traits<InputIterator>::difference_type n = 0;
  while (first != last) {
    ++first; ++n;
  }
  return n;
}

template <class RandomAccessIterator>
inline iterator_traits<RandomAccessIterator>::difference_type
__distance(RandomAccessIterator first, RandomAccessIterator last,
           random_access_iterator_tag) {
  return last - first;
}

template <class InputIterator>
inline iterator_traits<InputIterator>::difference_type
distance(InputIterator first, InputIterator last) {
  typedef typename iterator_traits<InputIterator>::iterator_category category;
  return __distance(first, last, category());
}



template <class InputIterator, class Distance>
inline void __advance(InputIterator& i, Distance n, input_iterator_tag) {
  while (n--) ++i;
}





template <class BidirectionalIterator, class Distance>
inline void __advance(BidirectionalIterator& i, Distance n, 
                      bidirectional_iterator_tag) {
  if (n >= 0)
    while (n--) ++i;
  else
    while (n++) --i;
}





template <class RandomAccessIterator, class Distance>
inline void __advance(RandomAccessIterator& i, Distance n, 
                      random_access_iterator_tag) {
  i += n;
}

template <class InputIterator, class Distance>
inline void advance(InputIterator& i, Distance n) {
  __advance(i, n, iterator_category(i));
}

template <class Container>
class back_insert_iterator {
protected:
  Container* container;
public:
  typedef output_iterator_tag iterator_category;
  typedef void                value_type;
  typedef void                difference_type;
  typedef void                pointer;
  typedef void                reference;

  explicit back_insert_iterator(Container& x) : container(&x) {}
  back_insert_iterator<Container>&
  operator=(const typename Container::value_type& value) { 
    container->push_back(value);
    return *this;
  }
  back_insert_iterator<Container>& operator*() { return *this; }
  back_insert_iterator<Container>& operator++() { return *this; }
  back_insert_iterator<Container>& operator++(int) { return *this; }
};

# 337 "/u/tveldhui/software/egcs-irix/include/g++/stl_iterator.h" 3


template <class Container>
inline back_insert_iterator<Container> back_inserter(Container& x) {
  return back_insert_iterator<Container>(x);
}

template <class Container>
class front_insert_iterator {
protected:
  Container* container;
public:
  typedef output_iterator_tag iterator_category;
  typedef void                value_type;
  typedef void                difference_type;
  typedef void                pointer;
  typedef void                reference;

  explicit front_insert_iterator(Container& x) : container(&x) {}
  front_insert_iterator<Container>&
  operator=(const typename Container::value_type& value) { 
    container->push_front(value);
    return *this;
  }
  front_insert_iterator<Container>& operator*() { return *this; }
  front_insert_iterator<Container>& operator++() { return *this; }
  front_insert_iterator<Container>& operator++(int) { return *this; }
};

# 375 "/u/tveldhui/software/egcs-irix/include/g++/stl_iterator.h" 3


template <class Container>
inline front_insert_iterator<Container> front_inserter(Container& x) {
  return front_insert_iterator<Container>(x);
}

template <class Container>
class insert_iterator {
protected:
  Container* container;
  typename Container::iterator iter;
public:
  typedef output_iterator_tag iterator_category;
  typedef void                value_type;
  typedef void                difference_type;
  typedef void                pointer;
  typedef void                reference;

  insert_iterator(Container& x, typename Container::iterator i) 
    : container(&x), iter(i) {}
  insert_iterator<Container>&
  operator=(const typename Container::value_type& value) { 
    iter = container->insert(iter, value);
    ++iter;
    return *this;
  }
  insert_iterator<Container>& operator*() { return *this; }
  insert_iterator<Container>& operator++() { return *this; }
  insert_iterator<Container>& operator++(int) { return *this; }
};

# 416 "/u/tveldhui/software/egcs-irix/include/g++/stl_iterator.h" 3


template <class Container, class Iterator>
inline insert_iterator<Container> inserter(Container& x, Iterator i) {
  typedef typename Container::iterator iter;
  return insert_iterator<Container>(x, iter(i));
}


template <class BidirectionalIterator, class T, class Reference = T&, 
          class Distance = ptrdiff_t> 




class reverse_bidirectional_iterator {
  typedef reverse_bidirectional_iterator<BidirectionalIterator, T, Reference,
                                         Distance> self;
protected:
  BidirectionalIterator current;
public:
  typedef bidirectional_iterator_tag iterator_category;
  typedef T                          value_type;
  typedef Distance                   difference_type;
  typedef T*                         pointer;
  typedef Reference                  reference;

  reverse_bidirectional_iterator() {}
  explicit reverse_bidirectional_iterator(BidirectionalIterator x)
    : current(x) {}
  BidirectionalIterator base() const { return current; }
  Reference operator*() const {
    BidirectionalIterator tmp = current;
    return *--tmp;
  }

  pointer operator->() const { return &(operator*()); }

  self& operator++() {
    --current;
    return *this;
  }
  self operator++(int) {
    self tmp = *this;
    --current;
    return tmp;
  }
  self& operator--() {
    ++current;
    return *this;
  }
  self operator--(int) {
    self tmp = *this;
    ++current;
    return tmp;
  }
};

# 501 "/u/tveldhui/software/egcs-irix/include/g++/stl_iterator.h" 3


template <class BidirectionalIterator, class T, class Reference,
          class Distance>
inline bool operator==(
    const reverse_bidirectional_iterator<BidirectionalIterator, T, Reference,
                                         Distance>& x, 
    const reverse_bidirectional_iterator<BidirectionalIterator, T, Reference,
                                         Distance>& y) {
  return x.base() == y.base();
}



 
 
 
 
 

template <class Iterator>
class reverse_iterator 
{
protected:
  Iterator current;
public:
  typedef typename iterator_traits<Iterator>::iterator_category
          iterator_category;
  typedef typename iterator_traits<Iterator>::value_type
          value_type;
  typedef typename iterator_traits<Iterator>::difference_type
          difference_type;
  typedef typename iterator_traits<Iterator>::pointer
          pointer;
  typedef typename iterator_traits<Iterator>::reference
          reference;

  typedef Iterator iterator_type;
  typedef reverse_iterator<Iterator> self;

public:
  reverse_iterator() {}
  explicit reverse_iterator(iterator_type x) : current(x) {}

  reverse_iterator(const self& x) : current(x.current) {}

  template <class Iter>
  reverse_iterator(const reverse_iterator<Iter>& x) : current(x.current) {}

    
  iterator_type base() const { return current; }
  reference operator*() const {
    Iterator tmp = current;
    return *--tmp;
  }

  pointer operator->() const { return &(operator*()); }


  self& operator++() {
    --current;
    return *this;
  }
  self operator++(int) {
    self tmp = *this;
    --current;
    return tmp;
  }
  self& operator--() {
    ++current;
    return *this;
  }
  self operator--(int) {
    self tmp = *this;
    ++current;
    return tmp;
  }

  self operator+(difference_type n) const {
    return self(current - n);
  }
  self& operator+=(difference_type n) {
    current -= n;
    return *this;
  }
  self operator-(difference_type n) const {
    return self(current + n);
  }
  self& operator-=(difference_type n) {
    current += n;
    return *this;
  }
  reference operator[](difference_type n) const { return *(*this + n); }  
}; 
 
template <class Iterator>
inline bool operator==(const reverse_iterator<Iterator>& x, 
                       const reverse_iterator<Iterator>& y) {
  return x.base() == y.base();
}

template <class Iterator>
inline bool operator<(const reverse_iterator<Iterator>& x, 
                      const reverse_iterator<Iterator>& y) {
  return y.base() < x.base();
}

template <class Iterator>
inline typename reverse_iterator<Iterator>::difference_type
operator-(const reverse_iterator<Iterator>& x, 
          const reverse_iterator<Iterator>& y) {
  return y.base() - x.base();
}

template <class Iterator>
inline reverse_iterator<Iterator> 
operator+(reverse_iterator<Iterator>::difference_type n,
          const reverse_iterator<Iterator>& x) {
  return reverse_iterator<Iterator>(x.base() - n);
}

# 738 "/u/tveldhui/software/egcs-irix/include/g++/stl_iterator.h" 3


template <class T, class Distance = ptrdiff_t> 
class istream_iterator {
  friend bool
  operator== <>  (const istream_iterator<T, Distance>& x,
                                   const istream_iterator<T, Distance>& y);
protected:
  istream* stream;
  T value;
  bool end_marker;
  void read() {
    end_marker = (*stream) ? true : false;
    if (end_marker) *stream >> value;
    end_marker = (*stream) ? true : false;
  }
public:
  typedef input_iterator_tag iterator_category;
  typedef T                  value_type;
  typedef Distance           difference_type;
  typedef const T*           pointer;
  typedef const T&           reference;

  istream_iterator() : stream(&cin), end_marker(false) {}
  istream_iterator(istream& s) : stream(&s) { read(); }
  reference operator*() const { return value; }

  pointer operator->() const { return &(operator*()); }

  istream_iterator<T, Distance>& operator++() { 
    read(); 
    return *this;
  }
  istream_iterator<T, Distance> operator++(int)  {
    istream_iterator<T, Distance> tmp = *this;
    read();
    return tmp;
  }
};

# 794 "/u/tveldhui/software/egcs-irix/include/g++/stl_iterator.h" 3


template <class T, class Distance>
inline bool operator==(const istream_iterator<T, Distance>& x,
                       const istream_iterator<T, Distance>& y) {
  return x.stream == y.stream && x.end_marker == y.end_marker ||
         x.end_marker == false && y.end_marker == false;
}

template <class T>
class ostream_iterator {
protected:
  ostream* stream;
  const char* string;
public:
  typedef output_iterator_tag iterator_category;
  typedef void                value_type;
  typedef void                difference_type;
  typedef void                pointer;
  typedef void                reference;

  ostream_iterator(ostream& s) : stream(&s), string(0) {}
  ostream_iterator(ostream& s, const char* c) : stream(&s), string(c)  {}
  ostream_iterator<T>& operator=(const T& value) { 
    *stream << value;
    if (string) *stream << string;
    return *this;
  }
  ostream_iterator<T>& operator*() { return *this; }
  ostream_iterator<T>& operator++() { return *this; } 
  ostream_iterator<T>& operator++(int) { return *this; } 
};

# 835 "/u/tveldhui/software/egcs-irix/include/g++/stl_iterator.h" 3


 



 
 
 
# 34 "/u/tveldhui/software/egcs-irix/include/g++/iterator" 2 3




 
 
 
# 44 "/u/tveldhui/software/egcs-irix/include/g++/std/bastring.h" 2 3




extern void __out_of_range (const char *);
extern void __length_error (const char *);














template <class charT, class traits = string_char_traits<charT>,
	  class Allocator = alloc >
class basic_string
{
private:
  struct Rep {
    size_t len, res, ref;
    bool selfish;

    charT* data () { return reinterpret_cast<charT *>(this + 1); }
    charT& operator[] (size_t s) { return data () [s]; }
    charT* grab () { if (selfish) return clone (); ++ref; return data (); }
    void release () { if (--ref == 0) delete this; }

    inline static void * operator new (size_t, size_t);
    inline static void operator delete (void *);
    inline static Rep* create (size_t);
    charT* clone ();

    inline void copy (size_t, const charT *, size_t);
    inline void move (size_t, const charT *, size_t);
    inline void set  (size_t, const charT,   size_t);

    inline static bool excess_slop (size_t, size_t);
    inline static size_t frob_size (size_t);

  private:
    Rep &operator= (const Rep &);
  };

public:
 
  typedef	   traits		traits_type;
  typedef typename traits::char_type	value_type;
  typedef	   Allocator		allocator_type;

  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef charT& reference;
  typedef const charT& const_reference;
  typedef charT* pointer;
  typedef const charT* const_pointer;
  typedef pointer iterator;
  typedef const_pointer const_iterator;
  typedef ::reverse_iterator<iterator> reverse_iterator;
  typedef ::reverse_iterator<const_iterator> const_reverse_iterator;
  static const size_type npos = static_cast<size_type>(-1);

private:
  Rep *rep () const { return reinterpret_cast<Rep *>(dat) - 1; }
  void repup (Rep *p) { rep ()->release (); dat = p->data (); }

public:
  const charT* data () const
    { return rep ()->data(); }
  size_type length () const
    { return rep ()->len; }
  size_type size () const
    { return rep ()->len; }
  size_type capacity () const
    { return rep ()->res; }
  size_type max_size () const
    { return (npos - 1)/sizeof (charT); }		 
  bool empty () const
    { return size () == 0; }

 
  basic_string& operator= (const basic_string& str)
    {
      if (&str != this) { rep ()->release (); dat = str.rep ()->grab (); }
      return *this;
    }

  explicit basic_string (): dat (nilRep.grab ()) { }
  basic_string (const basic_string& str): dat (str.rep ()->grab ()) { }
  basic_string (const basic_string& str, size_type pos, size_type n = npos)
    : dat (nilRep.grab ()) { assign (str, pos, n); }
  basic_string (const charT* s, size_type n)
    : dat (nilRep.grab ()) { assign (s, n); }
  basic_string (const charT* s)
    : dat (nilRep.grab ()) { assign (s); }
  basic_string (size_type n, charT c)
    : dat (nilRep.grab ()) { assign (n, c); }

  template<class InputIterator>
    basic_string(InputIterator begin, InputIterator end)



    : dat (nilRep.grab ()) { assign (begin, end); }

  ~basic_string ()
    { rep ()->release (); }

  void swap (basic_string &s) { charT *d = dat; dat = s.dat; s.dat = d; }

  basic_string& append (const basic_string& str, size_type pos = 0,
			size_type n = npos)
    { return replace (length (), 0, str, pos, n); }
  basic_string& append (const charT* s, size_type n)
    { return replace (length (), 0, s, n); }
  basic_string& append (const charT* s)
    { return append (s, traits::length (s)); }
  basic_string& append (size_type n, charT c)
    { return replace (length (), 0, n, c); }

  template<class InputIterator>
    basic_string& append(InputIterator first, InputIterator last)



    { return replace (iend (), iend (), first, last); }

  basic_string& assign (const basic_string& str, size_type pos = 0,
			size_type n = npos)
    { return replace (0, npos, str, pos, n); }
  basic_string& assign (const charT* s, size_type n)
    { return replace (0, npos, s, n); }
  basic_string& assign (const charT* s)
    { return assign (s, traits::length (s)); }
  basic_string& assign (size_type n, charT c)
    { return replace (0, npos, n, c); }

  template<class InputIterator>
    basic_string& assign(InputIterator first, InputIterator last)



    { return replace (ibegin (), iend (), first, last); }

  basic_string& operator= (const charT* s)
    { return assign (s); }
  basic_string& operator= (charT c)
    { return assign (1, c); }

  basic_string& operator+= (const basic_string& rhs)
    { return append (rhs); }
  basic_string& operator+= (const charT* s)
    { return append (s); }
  basic_string& operator+= (charT c)
    { return append (1, c); }

  basic_string& insert (size_type pos1, const basic_string& str,
			size_type pos2 = 0, size_type n = npos)
    { return replace (pos1, 0, str, pos2, n); }
  basic_string& insert (size_type pos, const charT* s, size_type n)
    { return replace (pos, 0, s, n); }
  basic_string& insert (size_type pos, const charT* s)
    { return insert (pos, s, traits::length (s)); }
  basic_string& insert (size_type pos, size_type n, charT c)
    { return replace (pos, 0, n, c); }
  iterator insert(iterator p, charT c)
    { size_type __o = p - ibegin ();
      insert (p - ibegin (), 1, c); selfish ();
      return ibegin () + __o; }
  iterator insert(iterator p, size_type n, charT c)
    { size_type __o = p - ibegin ();
      insert (p - ibegin (), n, c); selfish ();
      return ibegin () + __o; }

  template<class InputIterator>
    void insert(iterator p, InputIterator first, InputIterator last)



    { replace (p, p, first, last); }

  basic_string& erase (size_type pos = 0, size_type n = npos)
    { return replace (pos, n, (size_type)0, (charT)0); }
  iterator erase(iterator p)
    { size_type __o = p - begin();
      replace (__o, 1, (size_type)0, (charT)0); selfish ();
      return ibegin() + __o; }
  iterator erase(iterator f, iterator l)
    { size_type __o = f - ibegin();
      replace (__o, l-f, (size_type)0, (charT)0);selfish ();
      return ibegin() + __o; }

  basic_string& replace (size_type pos1, size_type n1, const basic_string& str,
			 size_type pos2 = 0, size_type n2 = npos);
  basic_string& replace (size_type pos, size_type n1, const charT* s,
			 size_type n2);
  basic_string& replace (size_type pos, size_type n1, const charT* s)
    { return replace (pos, n1, s, traits::length (s)); }
  basic_string& replace (size_type pos, size_type n1, size_type n2, charT c);
  basic_string& replace (size_type pos, size_type n, charT c)
    { return replace (pos, n, 1, c); }
  basic_string& replace (iterator i1, iterator i2, const basic_string& str)
    { return replace (i1 - ibegin (), i2 - i1, str); }
  basic_string& replace (iterator i1, iterator i2, const charT* s, size_type n)
    { return replace (i1 - ibegin (), i2 - i1, s, n); }
  basic_string& replace (iterator i1, iterator i2, const charT* s)
    { return replace (i1 - ibegin (), i2 - i1, s); }
  basic_string& replace (iterator i1, iterator i2, size_type n, charT c)
    { return replace (i1 - ibegin (), i2 - i1, n, c); }

  template<class InputIterator>
    basic_string& replace(iterator i1, iterator i2,
			  InputIterator j1, InputIterator j2);





private:
  static charT eos () { return traits::eos (); }
  void unique () { if (rep ()->ref > 1) alloc (length (), true); }
  void selfish () { unique (); rep ()->selfish = true; }

public:
  charT operator[] (size_type pos) const
    {
      if (pos == length ())
	return eos ();
      return data ()[pos];
    }

  reference operator[] (size_type pos)
    { selfish (); return (*rep ())[pos]; }

  reference at (size_type pos)
    {
      do { if ( pos >= length () ) __out_of_range ("pos >= length ()"); } while (0) ;
      return (*this)[pos];
    }
  const_reference at (size_type pos) const
    {
      do { if ( pos >= length () ) __out_of_range ("pos >= length ()"); } while (0) ;
      return data ()[pos];
    }

private:
  void terminate () const
    { traits::assign ((*rep ())[length ()], eos ()); }

public:
  const charT* c_str () const
    { if (length () == 0) return ""; terminate (); return data (); }
  void resize (size_type n, charT c);
  void resize (size_type n)
    { resize (n, eos ()); }
  void reserve (size_type) { }

  size_type copy (charT* s, size_type n, size_type pos = 0) const;

  size_type find (const basic_string& str, size_type pos = 0) const
    { return find (str.data(), pos, str.length()); }
  size_type find (const charT* s, size_type pos, size_type n) const;
  size_type find (const charT* s, size_type pos = 0) const
    { return find (s, pos, traits::length (s)); }
  size_type find (charT c, size_type pos = 0) const;

  size_type rfind (const basic_string& str, size_type pos = npos) const
    { return rfind (str.data(), pos, str.length()); }
  size_type rfind (const charT* s, size_type pos, size_type n) const;
  size_type rfind (const charT* s, size_type pos = npos) const
    { return rfind (s, pos, traits::length (s)); }
  size_type rfind (charT c, size_type pos = npos) const;

  size_type find_first_of (const basic_string& str, size_type pos = 0) const
    { return find_first_of (str.data(), pos, str.length()); }
  size_type find_first_of (const charT* s, size_type pos, size_type n) const;
  size_type find_first_of (const charT* s, size_type pos = 0) const
    { return find_first_of (s, pos, traits::length (s)); }
  size_type find_first_of (charT c, size_type pos = 0) const
    { return find (c, pos); }

  size_type find_last_of (const basic_string& str, size_type pos = npos) const
    { return find_last_of (str.data(), pos, str.length()); }
  size_type find_last_of (const charT* s, size_type pos, size_type n) const;
  size_type find_last_of (const charT* s, size_type pos = npos) const
    { return find_last_of (s, pos, traits::length (s)); }
  size_type find_last_of (charT c, size_type pos = npos) const
    { return rfind (c, pos); }

  size_type find_first_not_of (const basic_string& str, size_type pos = 0) const
    { return find_first_not_of (str.data(), pos, str.length()); }
  size_type find_first_not_of (const charT* s, size_type pos, size_type n) const;
  size_type find_first_not_of (const charT* s, size_type pos = 0) const
    { return find_first_not_of (s, pos, traits::length (s)); }
  size_type find_first_not_of (charT c, size_type pos = 0) const;

  size_type find_last_not_of (const basic_string& str, size_type pos = npos) const
    { return find_last_not_of (str.data(), pos, str.length()); }
  size_type find_last_not_of (const charT* s, size_type pos, size_type n) const;
  size_type find_last_not_of (const charT* s, size_type pos = npos) const
    { return find_last_not_of (s, pos, traits::length (s)); }
  size_type find_last_not_of (charT c, size_type pos = npos) const;

  basic_string substr (size_type pos = 0, size_type n = npos) const
    { return basic_string (*this, pos, n); }

  int compare (const basic_string& str, size_type pos = 0, size_type n = npos) const;
   
  int compare (const charT* s, size_type pos, size_type n) const;
  int compare (const charT* s, size_type pos = 0) const
    { return compare (s, pos, traits::length (s)); }

  iterator begin () { selfish (); return &(*this)[0]; }
  iterator end () { selfish (); return &(*this)[length ()]; }

private:
  iterator ibegin () const { return &(*rep ())[0]; }
  iterator iend () const { return &(*rep ())[length ()]; }

public:
  const_iterator begin () const { return ibegin (); }
  const_iterator end () const { return iend (); }

  reverse_iterator       rbegin() { return reverse_iterator (end ()); }
  const_reverse_iterator rbegin() const
    { return const_reverse_iterator (end ()); }
  reverse_iterator       rend() { return reverse_iterator (begin ()); }
  const_reverse_iterator rend() const
    { return const_reverse_iterator (begin ()); }

private:
  void alloc (size_type size, bool save);
  static size_type _find (const charT* ptr, charT c, size_type xpos, size_type len);
  inline bool check_realloc (size_type s) const;

  static Rep nilRep;
  charT *dat;
};


template <class charT, class traits, class Allocator> template <class InputIterator>
basic_string <charT, traits, Allocator>& basic_string <charT, traits, Allocator>::
replace (iterator i1, iterator i2, InputIterator j1, InputIterator j2)





{
  const size_type len = length ();
  size_type pos = i1 - ibegin ();
  size_type n1 = i2 - i1;
  size_type n2 = j2 - j1;

  do { if ( pos > len ) __out_of_range ("pos > len"); } while (0) ;
  if (n1 > len - pos)
    n1 = len - pos;
  do { if ( len - n1 > max_size () - n2 ) __length_error ("len - n1 > max_size () - n2"); } while (0) ;
  size_t newlen = len - n1 + n2;

  if (check_realloc (newlen))
    {
      Rep *p = Rep::create (newlen);
      p->copy (0, data (), pos);
      p->copy (pos + n2, data () + pos + n1, len - (pos + n1));
      for (; j1 != j2; ++j1, ++pos)
	traits::assign ((*p)[pos], *j1);
      repup (p);
    }
  else
    {
      rep ()->move (pos + n2, data () + pos + n1, len - (pos + n1));
      for (; j1 != j2; ++j1, ++pos)
	traits::assign ((*rep ())[pos], *j1);
    }
  rep ()->len = newlen;

  return *this;
}

template <class charT, class traits, class Allocator>
inline basic_string <charT, traits, Allocator>
operator+ (const basic_string <charT, traits, Allocator>& lhs,
	   const basic_string <charT, traits, Allocator>& rhs)
{
  basic_string <charT, traits, Allocator> str (lhs);
  str.append (rhs);
  return str;
}

template <class charT, class traits, class Allocator>
inline basic_string <charT, traits, Allocator>
operator+ (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)
{
  basic_string <charT, traits, Allocator> str (lhs);
  str.append (rhs);
  return str;
}

template <class charT, class traits, class Allocator>
inline basic_string <charT, traits, Allocator>
operator+ (charT lhs, const basic_string <charT, traits, Allocator>& rhs)
{
  basic_string <charT, traits, Allocator> str (1, lhs);
  str.append (rhs);
  return str;
}

template <class charT, class traits, class Allocator>
inline basic_string <charT, traits, Allocator>
operator+ (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)
{
  basic_string <charT, traits, Allocator> str (lhs);
  str.append (rhs);
  return str;
}

template <class charT, class traits, class Allocator>
inline basic_string <charT, traits, Allocator>
operator+ (const basic_string <charT, traits, Allocator>& lhs, charT rhs)
{
  basic_string <charT, traits, Allocator> str (lhs);
  str.append (1, rhs);
  return str;
}

template <class charT, class traits, class Allocator>
inline bool
operator== (const basic_string <charT, traits, Allocator>& lhs,
	    const basic_string <charT, traits, Allocator>& rhs)
{
  return (lhs.compare (rhs) == 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator== (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)
{
  return (rhs.compare (lhs) == 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator== (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)
{
  return (lhs.compare (rhs) == 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator!= (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)
{
  return (rhs.compare (lhs) != 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator!= (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)
{
  return (lhs.compare (rhs) != 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator< (const basic_string <charT, traits, Allocator>& lhs,
	    const basic_string <charT, traits, Allocator>& rhs)
{
  return (lhs.compare (rhs) < 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator< (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)
{
  return (rhs.compare (lhs) > 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator< (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)
{
  return (lhs.compare (rhs) < 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator> (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)
{
  return (rhs.compare (lhs) < 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator> (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)
{
  return (lhs.compare (rhs) > 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator<= (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)
{
  return (rhs.compare (lhs) >= 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator<= (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)
{
  return (lhs.compare (rhs) <= 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator>= (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)
{
  return (rhs.compare (lhs) <= 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator>= (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)
{
  return (lhs.compare (rhs) >= 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator!= (const basic_string <charT, traits, Allocator>& lhs,
	    const basic_string <charT, traits, Allocator>& rhs)
{
  return (lhs.compare (rhs) != 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator> (const basic_string <charT, traits, Allocator>& lhs,
	   const basic_string <charT, traits, Allocator>& rhs)
{
  return (lhs.compare (rhs) > 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator<= (const basic_string <charT, traits, Allocator>& lhs,
	    const basic_string <charT, traits, Allocator>& rhs)
{
  return (lhs.compare (rhs) <= 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator>= (const basic_string <charT, traits, Allocator>& lhs,
	    const basic_string <charT, traits, Allocator>& rhs)
{
  return (lhs.compare (rhs) >= 0);
}

class istream; class ostream;
template <class charT, class traits, class Allocator> istream&
operator>> (istream&, basic_string <charT, traits, Allocator>&);
template <class charT, class traits, class Allocator> ostream&
operator<< (ostream&, const basic_string <charT, traits, Allocator>&);
template <class charT, class traits, class Allocator> istream&
getline (istream&, basic_string <charT, traits, Allocator>&, charT delim = '\n');

}  

# 1 "/u/tveldhui/software/egcs-irix/include/g++/std/bastring.cc" 1 3
 
 

 
 
 
 
 

 
 
 
 

 
 
 

 
 
 
 
 

 
 

extern "C++" {
template <class charT, class traits, class Allocator>
inline void * basic_string <charT, traits, Allocator>::Rep::
operator new (size_t s, size_t extra)
{
  return Allocator::allocate(s + extra * sizeof (charT));
}

template <class charT, class traits, class Allocator>
inline void basic_string <charT, traits, Allocator>::Rep::
operator delete (void * ptr)
{
  Allocator::deallocate(ptr, sizeof(Rep) +
			reinterpret_cast<Rep *>(ptr)->res *
			sizeof (charT)); 
}

template <class charT, class traits, class Allocator>
inline size_t basic_string <charT, traits, Allocator>::Rep::
frob_size (size_t s)
{
  size_t i = 16;
  while (i < s) i *= 2;
  return i;
}

template <class charT, class traits, class Allocator>
inline basic_string <charT, traits, Allocator>::Rep *
basic_string <charT, traits, Allocator>::Rep::
create (size_t extra)
{
  extra = frob_size (extra + 1);
  Rep *p = new (extra) Rep;
  p->res = extra;
  p->ref = 1;
  p->selfish = false;
  return p;
}

template <class charT, class traits, class Allocator>
charT * basic_string <charT, traits, Allocator>::Rep::
clone ()
{
  Rep *p = Rep::create (len);
  p->copy (0, data (), len);
  p->len = len;
  return p->data ();
}

template <class charT, class traits, class Allocator>
inline bool basic_string <charT, traits, Allocator>::Rep::
excess_slop (size_t s, size_t r)
{
  return 2 * (s <= 16 ? 16 : s) < r;
}

template <class charT, class traits, class Allocator>
inline bool basic_string <charT, traits, Allocator>::
check_realloc (basic_string::size_type s) const
{
  s += sizeof (charT);
  rep ()->selfish = false;
  return (rep ()->ref > 1
	  || s > capacity ()
	  || Rep::excess_slop (s, capacity ()));
}

template <class charT, class traits, class Allocator>
void basic_string <charT, traits, Allocator>::
alloc (basic_string::size_type size, bool save)
{
  if (! check_realloc (size))
    return;

  Rep *p = Rep::create (size);

  if (save)
    {
      p->copy (0, data (), length ());
      p->len = length ();
    }
  else
    p->len = 0;

  repup (p);
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>&
basic_string <charT, traits, Allocator>::
replace (size_type pos1, size_type n1,
	 const basic_string& str, size_type pos2, size_type n2)
{
  const size_t len2 = str.length ();

  if (pos1 == 0 && n1 >= length () && pos2 == 0 && n2 >= len2)
    return operator= (str);

  do { if ( pos2 > len2 ) __out_of_range ("pos2 > len2"); } while (0) ;

  if (n2 > len2 - pos2)
    n2 = len2 - pos2;

  return replace (pos1, n1, str.data () + pos2, n2);
}

template <class charT, class traits, class Allocator>
inline void basic_string <charT, traits, Allocator>::Rep::
copy (size_t pos, const charT *s, size_t n)
{
  if (n)
    traits::copy (data () + pos, s, n);
}

template <class charT, class traits, class Allocator>
inline void basic_string <charT, traits, Allocator>::Rep::
move (size_t pos, const charT *s, size_t n)
{
  if (n)
    traits::move (data () + pos, s, n);
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>&
basic_string <charT, traits, Allocator>::
replace (size_type pos, size_type n1, const charT* s, size_type n2)
{
  const size_type len = length ();
  do { if ( pos > len ) __out_of_range ("pos > len"); } while (0) ;
  if (n1 > len - pos)
    n1 = len - pos;
  do { if ( len - n1 > max_size () - n2 ) __length_error ("len - n1 > max_size () - n2"); } while (0) ;
  size_t newlen = len - n1 + n2;

  if (check_realloc (newlen))
    {
      Rep *p = Rep::create (newlen);
      p->copy (0, data (), pos);
      p->copy (pos + n2, data () + pos + n1, len - (pos + n1));
      p->copy (pos, s, n2);
      repup (p);
    }
  else
    {
      rep ()->move (pos + n2, data () + pos + n1, len - (pos + n1));
      rep ()->copy (pos, s, n2);
    }
  rep ()->len = newlen;

  return *this;
}

template <class charT, class traits, class Allocator>
inline void basic_string <charT, traits, Allocator>::Rep::
set (size_t pos, const charT c, size_t n)
{
  traits::set  (data () + pos, c, n);
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>& basic_string <charT, traits, Allocator>::
replace (size_type pos, size_type n1, size_type n2, charT c)
{
  const size_t len = length ();
  do { if ( pos > len ) __out_of_range ("pos > len"); } while (0) ;
  if (n1 > len - pos)
    n1 = len - pos;
  do { if ( len - n1 > max_size () - n2 ) __length_error ("len - n1 > max_size () - n2"); } while (0) ;
  size_t newlen = len - n1 + n2;

  if (check_realloc (newlen))
    {
      Rep *p = Rep::create (newlen);
      p->copy (0, data (), pos);
      p->copy (pos + n2, data () + pos + n1, len - (pos + n1));
      p->set  (pos, c, n2);
      repup (p);
    }
  else
    {
      rep ()->move (pos + n2, data () + pos + n1, len - (pos + n1));
      rep ()->set  (pos, c, n2);
    }
  rep ()->len = newlen;

  return *this;
}

template <class charT, class traits, class Allocator>
void basic_string <charT, traits, Allocator>::
resize (size_type n, charT c)
{
  do { if ( n > max_size () ) __length_error ("n > max_size ()"); } while (0) ;

  if (n > length ())
    append (n - length (), c);
  else
    erase (n);
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
copy (charT* s, size_type n, size_type pos) const
{
  do { if ( pos > length () ) __out_of_range ("pos > length ()"); } while (0) ;

  if (n > length () - pos)
    n = length () - pos;

  traits::copy (s, data () + pos, n);
  return n;
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find (const charT* s, size_type pos, size_type n) const
{
  size_t xpos = pos;
  for (; xpos + n <= length (); ++xpos)
    if (traits::eq (data () [xpos], *s)
	&& traits::compare (data () + xpos, s, n) == 0)
      return xpos;
  return npos;
}

template <class charT, class traits, class Allocator>
inline basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
_find (const charT* ptr, charT c, size_type xpos, size_type len)
{
  for (; xpos < len; ++xpos)
    if (traits::eq (ptr [xpos], c))
      return xpos;
  return npos;
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find (charT c, size_type pos) const
{
  return _find (data (), c, pos, length ());
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
rfind (const charT* s, size_type pos, size_type n) const
{
  if (n > length ())
    return npos;

  size_t xpos = length () - n;
  if (xpos > pos)
    xpos = pos;

  for (++xpos; xpos-- > 0; )
    if (traits::eq (data () [xpos], *s)
	&& traits::compare (data () + xpos, s, n) == 0)
      return xpos;
  return npos;
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
rfind (charT c, size_type pos) const
{
  if (1 > length ())
    return npos;

  size_t xpos = length () - 1;
  if (xpos > pos)
    xpos = pos;

  for (++xpos; xpos-- > 0; )
    if (traits::eq (data () [xpos], c))
      return xpos;
  return npos;
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find_first_of (const charT* s, size_type pos, size_type n) const
{
  size_t xpos = pos;
  for (; xpos < length (); ++xpos)
    if (_find (s, data () [xpos], 0, n) != npos)
      return xpos;
  return npos;
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find_last_of (const charT* s, size_type pos, size_type n) const
{
  if (length() == 0)
    return npos;
  size_t xpos = length () - 1;
  if (xpos > pos)
    xpos = pos;
  for (++xpos; xpos-- > 0;)
    if (_find (s, data () [xpos], 0, n) != npos)
      return xpos;
  return npos;
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find_first_not_of (const charT* s, size_type pos, size_type n) const
{
  size_t xpos = pos;
  for (; xpos < length (); ++xpos)
    if (_find (s, data () [xpos], 0, n) == npos)
      return xpos;
  return npos;
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find_first_not_of (charT c, size_type pos) const
{
  size_t xpos = pos;
  for (; xpos < length (); ++xpos)
    if (traits::ne (data () [xpos], c))
      return xpos;
  return npos;
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find_last_not_of (const charT* s, size_type pos, size_type n) const
{
  if (length() == 0)
    return npos;
  size_t xpos = length () - 1;
  if (xpos > pos)
    xpos = pos;
  for (++xpos; xpos-- > 0;)
    if (_find (s, data () [xpos], 0, n) == npos)
      return xpos;
  return npos;
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find_last_not_of (charT c, size_type pos) const
{
  if (length() == 0)
    return npos;
  size_t xpos = length () - 1;
  if (xpos > pos)
    xpos = pos;
  for (++xpos; xpos-- > 0;)
    if (traits::ne (data () [xpos], c))
      return xpos;
  return npos;
}

template <class charT, class traits, class Allocator>
int basic_string <charT, traits, Allocator>::
compare (const basic_string& str, size_type pos, size_type n) const
{
  do { if ( pos > length () ) __out_of_range ("pos > length ()"); } while (0) ;

  size_t rlen = length () - pos;
  if (rlen > n)
    rlen = n;
  if (rlen > str.length ())
    rlen = str.length ();
  int r = traits::compare (data () + pos, str.data (), rlen);
  if (r != 0)
    return r;
  if (rlen == n)
    return 0;
  return (length () - pos) - str.length ();
}

template <class charT, class traits, class Allocator>
int basic_string <charT, traits, Allocator>::
compare (const charT* s, size_type pos, size_type n) const
{
  do { if ( pos > length () ) __out_of_range ("pos > length ()"); } while (0) ;

  size_t rlen = length () - pos;
  if (rlen > n)
    rlen = n;
  int r = traits::compare (data () + pos, s, rlen);
  if (r != 0)
    return r;
  return (length () - pos) - n;
}



template <class charT, class traits, class Allocator>
istream &
operator>> (istream &is, basic_string <charT, traits, Allocator> &s)
{
  int w = is.width (0);
  if (is.ipfx0 ())
    {
      register streambuf *sb = is.rdbuf ();
      s.resize (0);
      while (1)
	{
	  int ch = sb->sbumpc ();
	  if (ch == (-1) )
	    {
	      is.setstate (ios::eofbit);
	      break;
	    }
	  else if (traits::is_del (ch))
	    {
	      sb->sungetc ();
	      break;
	    }
	  s += ch;
	  if (--w == 1)
	    break;
	}
    }

  is.isfx ();
  if (s.length () == 0)
    is.setstate (ios::failbit);

  return is;
}

template <class charT, class traits, class Allocator>
ostream &
operator<< (ostream &o, const basic_string <charT, traits, Allocator>& s)
{
  return o.write (s.data (), s.length ());
}

template <class charT, class traits, class Allocator>
istream&
getline (istream &is, basic_string <charT, traits, Allocator>& s, charT delim)
{
  if (is.ipfx1 ())
    {
      _G_size_t  count = 0;
      streambuf *sb = is.rdbuf ();
      s.resize (0);

      while (1)
	{
	  int ch = sb->sbumpc ();
	  if (ch == (-1) )
	    {
	      is.setstate (count == 0
			   ? (ios::failbit|ios::eofbit)
			   : ios::eofbit);
	      break;
	    }

	  ++count;

	  if (ch == delim)
	    break;

	  s += ch;

	  if (s.length () == s.npos - 1)
	    {
	      is.setstate (ios::failbit);
	      break;
	    }
	}
    }

   
   
  is.isfx ();

  return is;
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::Rep
basic_string<charT, traits, Allocator>::nilRep = { 0, 0, 1, false };

template <class charT, class traits, class Allocator>
const basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::npos;

}  
# 618 "/u/tveldhui/software/egcs-irix/include/g++/std/bastring.h" 2 3



# 6 "/u/tveldhui/software/egcs-irix/include/g++/string" 2 3


extern "C++" {
typedef basic_string <char> string;
 
}  


# 73 "../blitz/blitz.h" 2

# 1 "/usr/include/stdio.h" 1 3



extern "C" {

#ident  "$Revision$"
 
















 
 

 
 
 

 








# 48 "/usr/include/stdio.h" 3


# 59 "/usr/include/stdio.h" 3



typedef __int64_t	fpos_t;





 


 
typedef	__int64_t	off64_t;	 









typedef __int64_t	off_t;		 

















 


typedef char *va_list;


























# 140 "/usr/include/stdio.h" 3

































typedef struct	 
# 184 "/usr/include/stdio.h" 3

{

	int		_cnt;	 




	unsigned char	*_ptr;	 
	unsigned char	*_base;	 





	unsigned char	_flag;	 
	unsigned char	_o_file;	 
	unsigned short	_file;	 




} FILE;

extern FILE		__iob[100 ];	






extern int	remove(const char *);
extern int	rename(const char *, const char *);
extern FILE	*tmpfile(void);
extern char	*tmpnam(char *);
extern int	fclose(FILE *);
extern int	fflush(FILE *);
extern FILE	*fopen(const char *, const char *);
extern FILE	*freopen(const char *, const char *, FILE *);
extern void	setbuf(FILE *, char *);
extern int	setvbuf(FILE *, char *, int, size_t);
 
extern int	fprintf(FILE *, const char *, ...);
 
extern int	fscanf(FILE *, const char *, ...);
 
extern int	printf(const char *, ...);
 
extern int	scanf(const char *, ...);




 
extern int	sprintf(char *, const char *, ...);
 
extern int	sscanf(const char *, const char *, ...);
extern int	vfprintf(FILE *, const char *,   char *);
extern int	vprintf(const char *,   char *);



extern int	vsprintf(char *, const char *,   char *);
# 256 "/usr/include/stdio.h" 3

extern int	fgetc(FILE *);
extern char	*fgets(char *, int, FILE *); 
extern int	fputc(int, FILE *);
extern int	fputs(const char *, FILE *);
extern int	getc(FILE *);
extern int	getchar(void);
extern char	*gets(char *);
extern int	putc(int, FILE *);
extern int	putchar(int);
extern int	puts(const char *);
extern int	ungetc(int, FILE *);
extern size_t	fread(void *, size_t, size_t, FILE *);
#pragma int_to_unsigned fread
extern size_t	fwrite(const void *, size_t, size_t, FILE *);
#pragma int_to_unsigned fwrite
extern int	fgetpos(FILE *, fpos_t *);
extern int	fseek(FILE *, long, int);
extern int	fsetpos(FILE *, const fpos_t *);
extern long	ftell(FILE *);
extern void	rewind(FILE *);
extern void	clearerr(FILE *);
extern int	feof(FILE *);
extern int	ferror(FILE *);
extern void	perror(const char *);

extern int	__filbuf(FILE *);	
extern int	__flsbuf(int, FILE *);	


	 
extern FILE    *fdopen(int, const char *);
extern int	fileno(FILE *);


# 300 "/usr/include/stdio.h" 3



extern FILE	*popen(const char *, const char *);
extern int	pclose(FILE *);


	 
# 1 "/usr/include/getopt.h" 1 3


#ident  "$Revision$"

extern "C" {


 




















extern int	getopt(int, char *const *, const char *);

extern char	*optarg;
extern int	opterr;
extern int	optind;
extern int	optopt;

# 47 "/usr/include/getopt.h" 3



}



# 308 "/usr/include/stdio.h" 2 3

extern char	*ctermid(char *);
extern char	*cuserid(char *);
extern char	*tempnam(const char *, const char *);
extern int	getw(FILE *);
extern int	putw(int, FILE *);


















# 343 "/usr/include/stdio.h" 3














# 428 "/usr/include/stdio.h" 3


 























}


# 74 "../blitz/blitz.h" 2



  
# 1 "/u/tveldhui/software/egcs-irix/include/g++/iostream" 1 3
 
 





# 77 "../blitz/blitz.h" 2

  
# 1 "/u/tveldhui/software/egcs-irix/include/g++/iomanip" 1 3
 
 



# 1 "/u/tveldhui/software/egcs-irix/include/g++/iomanip.h" 1 3
 

























#pragma interface





extern "C++" {
 
 
 

 
 
 
 
template<class TP> class smanip;  

template<class TP> class sapp {
    ios& (*_f)(ios&, TP);
public: 
    sapp(ios& (*f)(ios&, TP)) : _f(f) {}
     
    smanip<TP> operator()(TP a) 
      { return smanip<TP>(_f, a); }
};

template<class TP>
inline istream& operator>>(istream& i, const smanip<TP>& m);
template<class TP>
inline ostream& operator<<(ostream& o, const smanip<TP>& m);

template <class TP> class smanip {
    ios& (*_f)(ios&, TP);
    TP _a;
public:
    smanip(ios& (*f)(ios&, TP), TP a) : _f(f), _a(a) {}
     
    friend 
      istream& operator>> <>(istream& i, const smanip<TP>& m);
    friend
      ostream& operator<< <>(ostream& o, const smanip<TP>& m);
};


extern template class smanip<int>;
extern template class smanip<ios::fmtflags>;


template<class TP>
inline istream& operator>>(istream& i, const smanip<TP>& m)
{ (*m._f)(i, m._a); return i; }

template<class TP>
inline ostream& operator<<(ostream& o, const smanip<TP>& m)
{ (*m._f)(o, m._a); return o;}


extern template istream& operator>>(istream&, const smanip<int>&);
extern template istream& operator>>(istream&, const smanip<ios::fmtflags>&);
extern template ostream& operator<<(ostream&, const smanip<int>&);
extern template ostream& operator<<(ostream&, const smanip<ios::fmtflags>&);


 
 
 
 
template<class TP> class imanip; 

template<class TP> class iapp {
    istream& (*_f)(istream&, TP);
public: 
    iapp(istream& (*f)(istream&,TP)) : _f(f) {}
     
    imanip<TP> operator()(TP a)
       { return imanip<TP>(_f, a); }
};

template <class TP>
inline istream& operator>>(istream&, const imanip<TP>&);

template <class TP> class imanip {
    istream& (*_f)(istream&, TP);
    TP _a;
public:
    imanip(istream& (*f)(istream&, TP), TP a) : _f(f), _a(a) {}
     
    friend
      istream& operator>> <>(istream& i, const imanip<TP>& m);
};

template <class TP>
inline istream& operator>>(istream& i, const imanip<TP>& m)
{ return (*m._f)( i, m._a); }

 
 
 
 
template<class TP> class omanip; 

template<class TP> class oapp {
    ostream& (*_f)(ostream&, TP);
public: 
    oapp(ostream& (*f)(ostream&,TP)) : _f(f) {}
     
    omanip<TP> operator()(TP a)
      { return omanip<TP>(_f, a); }
};

template <class TP>
inline ostream& operator<<(ostream&, const omanip<TP>&);

template <class TP> class omanip {
    ostream& (*_f)(ostream&, TP);
    TP _a;
public:
    omanip(ostream& (*f)(ostream&, TP), TP a) : _f(f), _a(a) {}
     
    friend
      ostream& operator<< <>(ostream& o, const omanip<TP>& m);
};

template <class TP>
inline ostream& operator<<(ostream& o, const omanip<TP>& m)
{ return (*m._f)(o, m._a); }

 
 
 

 
 
 
 





extern ios& __iomanip_setbase  (ios&,   int ); inline   smanip <  int >   setbase  (  int  n) { return   smanip <  int > (__iomanip_setbase , n); } 
extern ios& __iomanip_setfill  (ios&,   int ); inline   smanip <  int >   setfill  (  int  n) { return   smanip <  int > (__iomanip_setfill , n); } 
extern ios& __iomanip_setprecision  (ios&,   int ); inline   smanip <  int >   setprecision  (  int  n) { return   smanip <  int > (__iomanip_setprecision , n); } 
extern ios& __iomanip_setw  (ios&,   int ); inline   smanip <  int >   setw  (  int  n) { return   smanip <  int > (__iomanip_setw , n); } 

extern ios& __iomanip_resetiosflags  (ios&,   ios::fmtflags ); inline   smanip <  ios::fmtflags >   resetiosflags  (  ios::fmtflags  n) { return   smanip <  ios::fmtflags > (__iomanip_resetiosflags , n); } 
extern ios& __iomanip_setiosflags  (ios&,   ios::fmtflags ); inline   smanip <  ios::fmtflags >   setiosflags  (  ios::fmtflags  n) { return   smanip <  ios::fmtflags > (__iomanip_setiosflags , n); } 
}  


# 6 "/u/tveldhui/software/egcs-irix/include/g++/iomanip" 2 3


# 78 "../blitz/blitz.h" 2







  
# 1 "/u/tveldhui/software/egcs-irix/include/g++/cmath" 1 3
 
 




# 1 "/usr/include/math.h" 1 3




extern "C" {





 
 
 
 
 
 
 
 

 

 













 














 






 



# 78 "/usr/include/math.h" 3


 

extern const double __infinity;




# 95 "/usr/include/math.h" 3


 



extern double	acos(double);




extern float	acosf(float);




extern double	asin(double);




extern float	asinf(float);




extern double	atan(double);




extern float	atanf(float);




# 139 "/usr/include/math.h" 3


extern double	atan2(double, double);




extern float	atan2f(float, float);




extern double	cos(double);




extern float	cosf(float);




extern double	sin(double);




extern float	sinf(float);




extern double	tan(double);




extern float	tanf(float);




# 189 "/usr/include/math.h" 3


extern double	cosh(double);




extern float	coshf(float);




extern double	sinh(double);




extern float	sinhf(float);




extern double	tanh(double);




extern float	tanhf(float);




extern double	exp(double);




extern float	expf(float);










extern double	frexp(double, int *);






extern double	ldexp(double, int);






extern double	log(double);




extern float	logf(float);




extern double	log10(double);




extern float	log10f(float);












extern double	modf(double, double *);

 

extern float	modff(float, float *); 

extern double	pow(double, double);




 
extern float	powf(float, float);




extern double	sqrt(double);




extern float	sqrtf(float);




extern double	ceil(double);




extern float	ceilf(float);




extern double	fabs(double);




 

extern float	fabsf(float);




extern double	floor(double);




extern float	floorf(float);




extern double	fmod(double, double);




 

extern float	fmodf(float, float);





 


 














extern int signgam;

extern double	gamma(double);
extern double	lgamma(double);

extern int	isnan(double);











extern double	erf(double);




extern double	erfc(double);




extern double	hypot(double, double);




extern double	j0(double);




extern double	j1(double);




extern double	jn(int, double);




extern double	y0(double);




extern double	y1(double);




extern double	yn(int, double);













 


extern double	rint(double);




extern double	asinh(double);




extern double	acosh(double);




extern double	atanh(double);




extern double	cbrt(double);




extern double	log1p(double);




extern double	expm1(double);




extern double	logb(double);




extern int	ilogb(double);




extern double	nextafter(double, double);




extern double	remainder(double, double);




extern double	scalb(double, double);






# 655 "/usr/include/math.h" 3


# 952 "/usr/include/math.h" 3


# 972 "/usr/include/math.h" 3



}  


 




# 996 "/usr/include/math.h" 3


# 1210 "/usr/include/math.h" 3




# 7 "/u/tveldhui/software/egcs-irix/include/g++/cmath" 2 3



#pragma interface "cmath"


extern "C++" {
# 38 "/u/tveldhui/software/egcs-irix/include/g++/cmath" 3


inline float  abs (float  x) { return fabs (x); }

inline double abs (double x) { return fabs (x); }


# 71 "/u/tveldhui/software/egcs-irix/include/g++/cmath" 3

inline long double abs (long double x) { return fabs (x); }

}  


# 85 "../blitz/blitz.h" 2






  
# 1 "/u/tveldhui/software/egcs-irix/include/g++/complex" 1 3
 
 




# 1 "/u/tveldhui/software/egcs-irix/include/g++/std/complext.h" 1 3
 
 

 
 
 
 

 
 
 
 

 
 
 

 
 
 
 
 

 
 





#pragma interface








class istream;
class ostream;

extern "C++" {
template <class _FLT> class complex;
template <class _FLT> complex<_FLT>&
  __doapl (complex<_FLT>* ths, const complex<_FLT>& r);
template <class _FLT> complex<_FLT>&
  __doami (complex<_FLT>* ths, const complex<_FLT>& r);
template <class _FLT> complex<_FLT>&
  __doaml (complex<_FLT>* ths, const complex<_FLT>& r);
template <class _FLT> complex<_FLT>&
  __doadv (complex<_FLT>* ths, const complex<_FLT>& r);

template <class _FLT>
class complex
{
public:
  complex (_FLT r = 0, _FLT i = 0): re (r), im (i) { }
  complex& operator += (const complex&);
  complex& operator -= (const complex&);
  complex& operator *= (const complex&);
  complex& operator /= (const complex&);
  _FLT real () const { return re; }
  _FLT imag () const { return im; }
private:
  _FLT re, im;

  friend complex& __doapl<> (complex *, const complex&);
  friend complex& __doami<> (complex *, const complex&);
  friend complex& __doaml<> (complex *, const complex&);
  friend complex& __doadv<> (complex *, const complex&);
};

 
class complex<float>;
class complex<double>;
class complex<long double>;

template <class _FLT>
inline complex<_FLT>&
__doapl (complex<_FLT>* ths, const complex<_FLT>& r)
{
  ths->re += r.re;
  ths->im += r.im;
  return *ths;
}
template <class _FLT>
inline complex<_FLT>&
complex<_FLT>::operator += (const complex<_FLT>& r)
{
  return __doapl (this, r);
}

template <class _FLT>
inline complex<_FLT>&
__doami (complex<_FLT>* ths, const complex<_FLT>& r)
{
  ths->re -= r.re;
  ths->im -= r.im;
  return *ths;
}
template <class _FLT>
inline complex<_FLT>&
complex<_FLT>::operator -= (const complex<_FLT>& r)
{
  return __doami (this, r);
}

template <class _FLT>
inline complex<_FLT>&
__doaml (complex<_FLT>* ths, const complex<_FLT>& r)
{
  _FLT f = ths->re * r.re - ths->im * r.im;
  ths->im = ths->re * r.im + ths->im * r.re;
  ths->re = f;
  return *ths;
}
template <class _FLT>
inline complex<_FLT>&
complex<_FLT>::operator *= (const complex<_FLT>& r)
{
  return __doaml (this, r);
}

template <class _FLT>
inline complex<_FLT>&
complex<_FLT>::operator /= (const complex<_FLT>& r)
{
  return __doadv (this, r);
}

template <class _FLT> inline _FLT
imag (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline _FLT
imag (const complex<_FLT>& x)
{
  return x.imag ();
}

template <class _FLT> inline _FLT
real (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline _FLT
real (const complex<_FLT>& x)
{
  return x.real ();
}

template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x, const complex<_FLT>& y)
{
  return complex<_FLT> (real (x) + real (y), imag (x) + imag (y));
}

template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x, _FLT y)
{
  return complex<_FLT> (real (x) + y, imag (x));
}

template <class _FLT> inline complex<_FLT>
operator + (_FLT x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator + (_FLT x, const complex<_FLT>& y)
{
  return complex<_FLT> (x + real (y), imag (y));
}

template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x, const complex<_FLT>& y)
{
  return complex<_FLT> (real (x) - real (y), imag (x) - imag (y));
}

template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x, _FLT y)
{
  return complex<_FLT> (real (x) - y, imag (x));
}

template <class _FLT> inline complex<_FLT>
operator - (_FLT x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator - (_FLT x, const complex<_FLT>& y)
{
  return complex<_FLT> (x - real (y), - imag (y));
}

template <class _FLT> inline complex<_FLT>
operator * (const complex<_FLT>& x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator * (const complex<_FLT>& x, const complex<_FLT>& y)
{
  return complex<_FLT> (real (x) * real (y) - imag (x) * imag (y),
			   real (x) * imag (y) + imag (x) * real (y));
}

template <class _FLT> inline complex<_FLT>
operator * (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator * (const complex<_FLT>& x, _FLT y)
{
  return complex<_FLT> (real (x) * y, imag (x) * y);
}

template <class _FLT> inline complex<_FLT>
operator * (_FLT x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator * (_FLT x, const complex<_FLT>& y)
{
  return complex<_FLT> (x * real (y), x * imag (y));
}

template <class _FLT> complex<_FLT>
operator / (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> complex<_FLT>
operator / (const complex<_FLT>& x, _FLT y)
{
  return complex<_FLT> (real (x) / y, imag (x) / y);
}

template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator + (const complex<_FLT>& x)
{
  return x;
}

template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
operator - (const complex<_FLT>& x)
{
  return complex<_FLT> (-real (x), -imag (x));
}

template <class _FLT> inline bool
operator == (const complex<_FLT>& x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline bool
operator == (const complex<_FLT>& x, const complex<_FLT>& y)
{
  return real (x) == real (y) && imag (x) == imag (y);
}

template <class _FLT> inline bool
operator == (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> inline bool
operator == (const complex<_FLT>& x, _FLT y)
{
  return real (x) == y && imag (x) == 0;
}

template <class _FLT> inline bool
operator == (_FLT x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline bool
operator == (_FLT x, const complex<_FLT>& y)
{
  return x == real (y) && imag (y) == 0;
}

template <class _FLT> inline bool
operator != (const complex<_FLT>& x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline bool
operator != (const complex<_FLT>& x, const complex<_FLT>& y)
{
  return real (x) != real (y) || imag (x) != imag (y);
}

template <class _FLT> inline bool
operator != (const complex<_FLT>& x, _FLT y) __attribute__ ((const));

template <class _FLT> inline bool
operator != (const complex<_FLT>& x, _FLT y)
{
  return real (x) != y || imag (x) != 0;
}

template <class _FLT> inline bool
operator != (_FLT x, const complex<_FLT>& y) __attribute__ ((const));

template <class _FLT> inline bool
operator != (_FLT x, const complex<_FLT>& y)
{
  return x != real (y) || imag (y) != 0;
}

 
extern "C" double hypot (double, double) __attribute__ ((const));

template <class _FLT> inline _FLT
abs (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline _FLT
abs (const complex<_FLT>& x)
{
  return hypot (real (x), imag (x));
}

template <class _FLT> inline _FLT
arg (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline _FLT
arg (const complex<_FLT>& x)
{
  return atan2 (imag (x), real (x));
}

template <class _FLT> inline complex<_FLT>
polar (_FLT r, _FLT t) __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
polar (_FLT r, _FLT t)
{
  return complex<_FLT> (r * cos (t), r * sin (t));
}

template <class _FLT> inline complex<_FLT>
conj (const complex<_FLT>& x)  __attribute__ ((const));

template <class _FLT> inline complex<_FLT>
conj (const complex<_FLT>& x) 
{
  return complex<_FLT> (real (x), -imag (x));
}

template <class _FLT> inline _FLT
norm (const complex<_FLT>& x) __attribute__ ((const));

template <class _FLT> inline _FLT
norm (const complex<_FLT>& x)
{
  return real (x) * real (x) + imag (x) * imag (x);
}

 

template <class _FLT> complex<_FLT>
  operator / (const complex<_FLT>&, const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  operator / (_FLT, const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  cos (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  cosh (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  exp (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  log (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  pow (const complex<_FLT>&, const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  pow (const complex<_FLT>&, _FLT) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  pow (const complex<_FLT>&, int) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  pow (_FLT, const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  sin (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  sinh (const complex<_FLT>&) __attribute__ ((const));
template <class _FLT> complex<_FLT>
  sqrt (const complex<_FLT>&) __attribute__ ((const));

template <class _FLT> istream& operator >> (istream&, complex<_FLT>&);
template <class _FLT> ostream& operator << (ostream&, const complex<_FLT>&);
}  

 

# 1 "/u/tveldhui/software/egcs-irix/include/g++/std/fcomplex.h" 1 3
 
 

 
 
 
 
 

 
 
 
 

 
 
 

 
 
 
 
 

 
 





#pragma interface "fcomplex"


extern "C++" {
class complex<float>
{
public:
  complex (float r = 0, float i = 0): re (r), im (i) { }
  explicit complex (const complex<double>& r);
  explicit complex (const complex<long double>& r);

  complex& operator+= (const complex& r) { return __doapl (this, r); }
  complex& operator-= (const complex& r) { return __doami (this, r); }
  complex& operator*= (const complex& r) { return __doaml (this, r); }
  complex& operator/= (const complex& r) { return __doadv (this, r); }

  float real () const { return re; }
  float imag () const { return im; }
private:
  float re, im;

  friend complex& __doapl<> (complex *, const complex&);
  friend complex& __doami<> (complex *, const complex&);
  friend complex& __doaml<> (complex *, const complex&);
  friend complex& __doadv<> (complex *, const complex&);


  friend inline complex operator + (const complex& x, float y)
    { return operator+<> (x, y); }
  friend inline complex operator + (float x, const complex& y)
    { return operator+<> (x, y); }
  friend inline complex operator - (const complex& x, float y)
    { return operator-<> (x, y); }
  friend inline complex operator - (float x, const complex& y)
    { return operator-<> (x, y); }
  friend inline complex operator * (const complex& x, float y)
    { return operator*<> (x, y); }
  friend inline complex operator * (float x, const complex& y)
    { return operator*<> (x, y); }
  friend inline complex operator / (const complex& x, float y)
    { return operator/<> (x, y); }
  friend inline complex operator / (float x, const complex& y)
    { return operator/<> (x, y); }
  friend inline bool operator == (const complex& x, float y)
    { return operator==<> (x, y); }
  friend inline bool operator == (float x, const complex& y)
    { return operator==<> (x, y); }
  friend inline bool operator != (const complex& x, float y)
    { return operator!=<> (x, y); }
  friend inline bool operator != (float x, const complex& y)
    { return operator!=<> (x, y); }

};
}  


# 396 "/u/tveldhui/software/egcs-irix/include/g++/std/complext.h" 2 3

# 1 "/u/tveldhui/software/egcs-irix/include/g++/std/dcomplex.h" 1 3
 
 

 
 
 
 
 

 
 
 
 

 
 
 

 
 
 
 
 

 
 





#pragma interface "dcomplex"


extern "C++" {
class complex<double>
{
public:
  complex (double r = 0, double i = 0): re (r), im (i) { }
  complex (const complex<float>& r): re (r.real ()), im (r.imag ()) { }
  explicit complex (const complex<long double>& r);

  complex& operator+= (const complex& r) { return __doapl (this, r); }
  complex& operator-= (const complex& r) { return __doami (this, r); }
  complex& operator*= (const complex& r) { return __doaml (this, r); }
  complex& operator/= (const complex& r) { return __doadv (this, r); }

  double real () const { return re; }
  double imag () const { return im; }
private:
  double re, im;

  friend complex& __doapl<> (complex *, const complex&);
  friend complex& __doami<> (complex *, const complex&);
  friend complex& __doaml<> (complex *, const complex&);
  friend complex& __doadv<> (complex *, const complex&);


  friend inline complex operator + (const complex& x, double y)
    { return operator+<> (x, y); }
  friend inline complex operator + (double x, const complex& y)
    { return operator+<> (x, y); }
  friend inline complex operator - (const complex& x, double y)
    { return operator-<> (x, y); }
  friend inline complex operator - (double x, const complex& y)
    { return operator-<> (x, y); }
  friend inline complex operator * (const complex& x, double y)
    { return operator*<> (x, y); }
  friend inline complex operator * (double x, const complex& y)
    { return operator*<> (x, y); }
  friend inline complex operator / (const complex& x, double y)
    { return operator/<> (x, y); }
  friend inline complex operator / (double x, const complex& y)
    { return operator/<> (x, y); }
  friend inline bool operator == (const complex& x, double y)
    { return operator==<> (x, y); }
  friend inline bool operator == (double x, const complex& y)
    { return operator==<> (x, y); }
  friend inline bool operator != (const complex& x, double y)
    { return operator!=<> (x, y); }
  friend inline bool operator != (double x, const complex& y)
    { return operator!=<> (x, y); }

};

inline complex<float>::complex (const complex<double>& r)
: re (r.real ()), im (r.imag ())
{ }
}  


# 397 "/u/tveldhui/software/egcs-irix/include/g++/std/complext.h" 2 3

# 1 "/u/tveldhui/software/egcs-irix/include/g++/std/ldcomplex.h" 1 3
 
 

 
 
 
 
 

 
 
 
 

 
 
 

 
 
 
 
 

 
 





#pragma interface "ldcomplex"


extern "C++" {
class complex<long double>
{
public:
  complex (long double r = 0, long double i = 0): re (r), im (i) { }
  complex (const complex<float>& r): re (r.real ()), im (r.imag ()) { }
  complex (const complex<double>& r): re (r.real ()), im (r.imag ()) { }

  complex& operator+= (const complex& r) { return __doapl (this, r); }
  complex& operator-= (const complex& r) { return __doami (this, r); }
  complex& operator*= (const complex& r) { return __doaml (this, r); }
  complex& operator/= (const complex& r) { return __doadv (this, r); }

  long double real () const { return re; }
  long double imag () const { return im; }
private:
  long double re, im;

  friend complex& __doapl<> (complex *, const complex&);
  friend complex& __doami<> (complex *, const complex&);
  friend complex& __doaml<> (complex *, const complex&);
  friend complex& __doadv<> (complex *, const complex&);


  friend inline complex operator + (const complex& x, long double y)
    { return operator+<> (x, y); }
  friend inline complex operator + (long double x, const complex& y)
    { return operator+<> (x, y); }
  friend inline complex operator - (const complex& x, long double y)
    { return operator-<> (x, y); }
  friend inline complex operator - (long double x, const complex& y)
    { return operator-<> (x, y); }
  friend inline complex operator * (const complex& x, long double y)
    { return operator*<> (x, y); }
  friend inline complex operator * (long double x, const complex& y)
    { return operator*<> (x, y); }
  friend inline complex operator / (const complex& x, long double y)
    { return operator/<> (x, y); }
  friend inline complex operator / (long double x, const complex& y)
    { return operator/<> (x, y); }
  friend inline bool operator == (const complex& x, long double y)
    { return operator==<> (x, y); }
  friend inline bool operator == (long double x, const complex& y)
    { return operator==<> (x, y); }
  friend inline bool operator != (const complex& x, long double y)
    { return operator!=<> (x, y); }
  friend inline bool operator != (long double x, const complex& y)
    { return operator!=<> (x, y); }

};

inline complex<float>::complex (const complex<long double>& r)
: re (r.real ()), im (r.imag ())
{ }

inline complex<double>::complex (const complex<long double>& r)
: re (r.real ()), im (r.imag ())
{ }
}  


# 398 "/u/tveldhui/software/egcs-irix/include/g++/std/complext.h" 2 3



# 7 "/u/tveldhui/software/egcs-irix/include/g++/complex" 2 3


extern "C++" {


 
typedef complex<float> float_complex;
typedef complex<double> double_complex;
typedef complex<long double> long_double_complex;
}


# 91 "../blitz/blitz.h" 2





namespace  blitz  { 


 using namespace  std ; 






 
 


} 

# 1 "../blitz/bzdebug.h" 1
 




















































# 1 "/u/tveldhui/software/egcs-irix/mips-sgi-irix6.5/include/assert.h" 1 3
 








# 19 "/u/tveldhui/software/egcs-irix/mips-sgi-irix6.5/include/assert.h" 3




 

extern "C" {
extern void __eprintf (const char *, const char *, unsigned, const char *)
    __attribute__ ((noreturn));
}












# 52 "/u/tveldhui/software/egcs-irix/mips-sgi-irix6.5/include/assert.h" 3



# 54 "../blitz/bzdebug.h" 2



 
# 1 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/typeinfo" 1 3
 
 




#pragma interface "typeinfo"

# 1 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/exception" 1 3
 
 




#pragma interface "exception"

extern "C++" {





class exception {
public:
  exception () { }
  virtual ~exception () { }
  virtual const char* what () const;
};

class bad_exception : public exception {
public:
  bad_exception () { }
  virtual ~bad_exception () { }
};

typedef void (*terminate_handler) ();
typedef void (*unexpected_handler) ();

terminate_handler set_terminate (terminate_handler);
void terminate () __attribute__ ((__noreturn__));
unexpected_handler set_unexpected (unexpected_handler);
void unexpected () __attribute__ ((__noreturn__));
bool uncaught_exception ();





}  


# 9 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/typeinfo" 2 3


extern "C++" {





class type_info {
private:
   
  type_info& operator= (const type_info&);
  type_info (const type_info&);

protected:
  type_info (const char *n): _name (n) { }

  const char *_name;

public:
   
  virtual ~type_info ();
    
  bool before (const type_info& arg) const;
  const char* name () const
    { return _name; }
  bool operator== (const type_info& arg) const;
  bool operator!= (const type_info& arg) const;
};

inline bool type_info::
operator!= (const type_info& arg) const
{
  return !operator== (arg);
}

class bad_cast : public exception {
public:
  bad_cast() { }
  virtual ~bad_cast() { }
};

class bad_typeid : public exception {
 public:
  bad_typeid () { }
  virtual ~bad_typeid () { }
};





}  

# 57 "../blitz/bzdebug.h" 2



namespace  blitz  { 

 





extern  bool  assertFailMode      ;
extern  int      assertFailCount     ;
extern  int      assertSuccessCount  ;


# 148 "../blitz/bzdebug.h"

# 171 "../blitz/bzdebug.h"

    
    
    
    
    
    
    



 
 
void _bz_debug_marker();







# 234 "../blitz/bzdebug.h"


} 


# 112 "../blitz/blitz.h" 2



# 49 "../blitz/array.h" 2




 
# 1 "../blitz/memblock.h" 1
 































































 
# 1 "../blitz/numtrait.h" 1
 

















































namespace  blitz  { 













template<class P_numtype>
class NumericTypeTraits {
public:
    typedef P_numtype T_sumtype;     
    typedef P_numtype T_difftype;    
    typedef P_numtype T_floattype;   
                                     
    typedef P_numtype T_signedtype;  
    enum { hasTrivialCtor = 0 };     
};


# 86 "../blitz/numtrait.h"


    template<> class NumericTypeTraits< bool > { public: typedef  unsigned  T_sumtype; typedef  int  T_difftype; typedef  float  T_floattype; typedef  int  T_signedtype; enum { hasTrivialCtor = 1 }; } ;


template<> class NumericTypeTraits< char > { public: typedef  int  T_sumtype; typedef  int  T_difftype; typedef  float  T_floattype; typedef  char  T_signedtype; enum { hasTrivialCtor = 1 }; } ;
template<> class NumericTypeTraits< unsigned char > { public: typedef   unsigned  T_sumtype; typedef   int  T_difftype; typedef   float  T_floattype; typedef  int  T_signedtype; enum { hasTrivialCtor = 1 }; } ;
template<> class NumericTypeTraits< short int > { public: typedef   int  T_sumtype; typedef   int  T_difftype; typedef   float  T_floattype; typedef   short int  T_signedtype; enum { hasTrivialCtor = 1 }; } ;
template<> class NumericTypeTraits< short unsigned int > { public: typedef   unsigned int  T_sumtype; typedef   int  T_difftype; typedef   float  T_floattype; typedef   int  T_signedtype; enum { hasTrivialCtor = 1 }; } ;
template<> class NumericTypeTraits< int > { public: typedef   long  T_sumtype; typedef   int  T_difftype; typedef   float  T_floattype; typedef   int  T_signedtype; enum { hasTrivialCtor = 1 }; } ;
template<> class NumericTypeTraits< unsigned int > { public: typedef   unsigned long  T_sumtype; typedef   int  T_difftype; typedef   float  T_floattype; typedef   long  T_signedtype; enum { hasTrivialCtor = 1 }; } ;
template<> class NumericTypeTraits< long > { public: typedef   long  T_sumtype; typedef   long  T_difftype; typedef   double  T_floattype; typedef   long  T_signedtype; enum { hasTrivialCtor = 1 }; } ;
template<> class NumericTypeTraits< unsigned long > { public: typedef   unsigned long  T_sumtype; typedef   long  T_difftype; typedef   double  T_floattype; typedef   long  T_signedtype; enum { hasTrivialCtor = 1 }; } ;
template<> class NumericTypeTraits< float > { public: typedef   double  T_sumtype; typedef   float  T_difftype; typedef   float  T_floattype; typedef   float  T_signedtype; enum { hasTrivialCtor = 1 }; } ;
template<> class NumericTypeTraits< double > { public: typedef   double  T_sumtype; typedef   double  T_difftype; typedef   double  T_floattype; typedef   double  T_signedtype; enum { hasTrivialCtor = 1 }; } ;


 
 




} 


# 65 "../blitz/memblock.h" 2



# 1 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/stddef.h" 1 3
# 342 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/stddef.h" 3

# 68 "../blitz/memblock.h" 2


namespace  blitz  { 

enum preexistingMemoryPolicy { 
  duplicateData, 
  deleteDataWhenDone, 
  neverDeleteData 
};

 
template<class T_type> class MemoryBlockReference;

 
 
 
 
template<class P_type>
class MemoryBlock {

    friend class MemoryBlockReference<P_type>;

public:
    typedef P_type T_type;

protected:
    MemoryBlock()
    {
        length_ = 0;
        data_ = 0;
        dataBlockAddress_ = 0;
        references_ = 0;
    }

    explicit  MemoryBlock(size_t items)
    {
        length_ = items;
        allocate(length_);






         ;

        references_ = 0;
    }

    MemoryBlock(size_t length, T_type*   data)
    {
        length_ = length;
        data_ = data;
        dataBlockAddress_ = 0;
        references_ = 0;
    }

    virtual ~MemoryBlock()
    {
        if (dataBlockAddress_) 
        {






            deallocate();
        }
    }

    void          addReference()
    { 
        ++references_; 







    }

    T_type*        data() 
    { 
        return data_; 
    }

    const T_type*   data()      const
    { 
        return data_; 
    }

    size_t        length()    const
    { 
        return length_; 
    }

    void          removeReference()
    {
        --references_;







        if (!references_)
        {





            delete this;
        }
    }

    int references() const
    {
        return references_;
    }

protected:
    inline void allocate(int length);
    void deallocate();

private:    
    MemoryBlock(const MemoryBlock<T_type>&)
    { }

    void operator=(const MemoryBlock<T_type>&)
    { }

private:    
    T_type *   data_;
    T_type *   dataBlockAddress_;
    int     references_;
    size_t  length_;
};

template<class P_type>
class UnownedMemoryBlock : public MemoryBlock<P_type> {
public:
    UnownedMemoryBlock(size_t length, P_type*   data)
        : MemoryBlock<P_type>(length,data)
    {
    }

    virtual ~UnownedMemoryBlock()
    {
    }
};

template<class P_type>
class NullMemoryBlock : public MemoryBlock<P_type> {
public:
    NullMemoryBlock()
    { 
         
         
        this->addReference();        
    }

    virtual ~NullMemoryBlock()  
    { }
};

template<class P_type>
class MemoryBlockReference {

public:
    typedef P_type T_type;

    MemoryBlockReference()
    {
        block_ = &nullBlock_;
        block_->addReference();

         
         
         
         
         
        block_->addReference();

        data_ = 0;
    }

    MemoryBlockReference(MemoryBlockReference<T_type>& ref)
    {
        block_ = ref.block_;
        block_->addReference();
        data_ = block_->data();
    }

    MemoryBlockReference(MemoryBlockReference<T_type>& ref, size_t offset)
    {
        block_ = ref.block_;
        block_->addReference();
        data_ = block_->data() + offset;
    }

    MemoryBlockReference(size_t length, T_type* data, 
        preexistingMemoryPolicy deletionPolicy)
    {
         

         
         
         
         

        if ((deletionPolicy == neverDeleteData) 
          || (deletionPolicy == duplicateData))
            block_ = new UnownedMemoryBlock<T_type>(length, data);
        else if (deletionPolicy == deleteDataWhenDone)
            block_ = new MemoryBlock<T_type>(length, data);
        block_->addReference();






        data_ = data;
    }

    explicit  MemoryBlockReference(size_t items)
    {
        block_ = new MemoryBlock<T_type>(items);
        block_->addReference();
        data_ = block_->data();






    }

   ~MemoryBlockReference()
    {
        block_->removeReference();
    }

    int numReferences() const
    {
        return block_->references();
    }

protected:

    void changeToNullBlock()
    {
        block_->removeReference();
        block_ = &nullBlock_;
        block_->addReference();
        data_ = 0;
    }

    void changeBlock(MemoryBlockReference<T_type>& ref, size_t offset)
    {
        block_->removeReference();
        block_ = ref.block_;
        block_->addReference();
        data_ = block_->data() + offset;
    }

    void newBlock(size_t items)
    {
        block_->removeReference();
        block_ = new MemoryBlock<T_type>(items);
        block_->addReference();
        data_ = block_->data();





    }

private:
    void operator=(const MemoryBlockReference<T_type>&)
    { }

protected:
    T_type *   data_;

private:
    MemoryBlock<T_type>* block_;
    static NullMemoryBlock<T_type> nullBlock_;
};


} 

# 1 "../blitz/memblock.cc" 1
 






















 
# 1 "../blitz/memblock.h" 1
 























































# 368 "../blitz/memblock.h"

# 24 "../blitz/memblock.cc" 2







namespace  blitz  { 

 
template<class P_type> 
NullMemoryBlock<P_type> MemoryBlockReference<P_type>::nullBlock_;

template<class P_type>
void MemoryBlock<P_type>::deallocate()
{

    delete [] dataBlockAddress_;
# 51 "../blitz/memblock.cc"

}

template<class P_type>
inline void MemoryBlock<P_type>::allocate(int length)
{
     ;

     ;


    data_ =  new T_type[length];
    dataBlockAddress_ = data_;
# 100 "../blitz/memblock.cc"

}


} 


# 366 "../blitz/memblock.h" 2



# 53 "../blitz/array.h" 2




 
# 1 "../blitz/range.h" 1
 





















































 
# 1 "../blitz/vecexprwrap.h" 1
 







































namespace  blitz  { 

template<class P_expr>
class _bz_VecExpr {

public:
    typedef P_expr T_expr;
    typedef typename  T_expr::T_numtype T_numtype;


    _bz_VecExpr(T_expr a)
        : iter_(a)
    { }







    _bz_VecExpr(const _bz_VecExpr<T_expr>& a)
        : iter_(a.iter_)
    { }


    T_numtype operator[](int i) const
    { return iter_[i]; }

    T_numtype operator()(int i) const
    { return iter_(i); }

    int length(int recommendedLength) const
    { return iter_.length(recommendedLength); }

    enum { _bz_staticLengthCount = (int) P_expr::_bz_staticLengthCount  ,
           _bz_dynamicLengthCount = (int) P_expr::_bz_dynamicLengthCount  ,
           _bz_staticLength = (int) P_expr::_bz_staticLength   };

    int _bz_suggestLength() const
    { return iter_._bz_suggestLength(); }

    bool  _bz_hasFastAccess() const
    { return iter_._bz_hasFastAccess(); }

    T_numtype _bz_fastAccess(int i) const
    { return iter_._bz_fastAccess(i); }

private:
    _bz_VecExpr();

    T_expr iter_;
};

} 


# 55 "../blitz/range.h" 2



# 1 "../blitz/wrap-climits.h" 1






 
# 1 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/limits.h" 1 3
 


 





 
# 1 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/syslimits.h" 1 3
 
















 
 

 
 
 



#ident  "$Revision$"




extern "C" {

 



 





































 




















 













# 124 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/syslimits.h" 3




















 



 









































 















 


















































# 303 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/syslimits.h" 3


# 324 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/syslimits.h" 3



}


# 11 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/limits.h" 2 3





 



 



 




 





 



 












 

 




 



 








 



 













 




 








 






 









# 7 "../blitz/wrap-climits.h" 2




# 58 "../blitz/range.h" 2


namespace  blitz  { 

 
 
 
 
 
 
 

enum { fromStart = (- 2147483647  -1) , toEnd = (- 2147483647  -1)  };

 
class Range {

public:
     
     
     

    typedef int T_numtype;

    enum { fromStart = (- 2147483647  -1) , toEnd = (- 2147483647  -1)  };

    Range()
    {
        first_ = fromStart;
        last_ = toEnd;
        stride_ = 1;
    }

     

    Range(const Range& r)
    {
        first_ = r.first_;
        last_ = r.last_;
        stride_ = r.stride_;
    }


    explicit  Range(int slicePosition)
    {
        first_ = slicePosition;
        last_ = slicePosition;
        stride_ = 1;
    }

    Range(int first, int last, int stride=1)
        : first_(first), last_(last), stride_(stride)
    { 
         ;



         ;

    }

    int first(int lowRange = 0) const
    { 
        if (first_ == fromStart)
            return lowRange;
        return first_; 
    }

    int last(int highRange = 0) const
    {
        if (last_ == toEnd)
            return highRange;
        return last_;
    }

    unsigned length(int recommendedLength = 0) const
    {
         ;
         ;
         ;
        return (last_ - first_) / stride_ + 1;
    }

    int stride() const
    { return stride_; }

    bool  isAscendingContiguous() const
    {
        return (first_ < last_) && (stride_ == 1);
    }

    void setRange(int first, int last, int stride=1)
    {
         ;


         ;
        first_ = first;
        last_ = last;
        stride_ = stride;
    }

    static Range all() 
    { return Range(fromStart,toEnd,1); }

    bool isUnitStride() const
    { return stride_ == 1; }

     
    Range operator-(int shift) const
    { 
         ;
         ;
        return Range(first_ - shift, last_ - shift, stride_); 
    }

    Range operator+(int shift) const
    { 
         ;
         ;
        return Range(first_ + shift, last_ + shift, stride_); 
    }

    int operator[](unsigned i) const
    {
        return first_ + i * stride_;
    }

    int operator()(unsigned i) const
    {
        return first_ + i * stride_;
    }

    friend inline ostream& operator<<(ostream& os, const Range& range)
    {
        os << "Range(" << range.first() << "," << range.last() << ","
           << range.stride() << ")";

        return os;
    }

     
     
     
     
     

    enum { _bz_staticLengthCount = 0,
           _bz_dynamicLengthCount = 0,
           _bz_staticLength = 0 };

    bool  _bz_hasFastAccess() const
    { return stride_ == 1; }

    T_numtype _bz_fastAccess(unsigned i) const
    { return first_ + i; }

    unsigned _bz_suggestLength() const
    { 
        return length();
    }

    _bz_VecExpr<Range> _bz_asVecExpr() const
    { return _bz_VecExpr<Range>(*this); }

private:
    int first_, last_, stride_;
};

} 


# 57 "../blitz/array.h" 2




 
# 1 "../blitz/tinyvec.h" 1
 












































 
# 1 "../blitz/listinit.h" 1
 
































 












namespace  blitz  { 

template<class T_numtype, class T_iterator>
class ListInitializer {

public:
    ListInitializer(T_iterator iter)
        : iter_(iter)
    {
    }

    ListInitializer<T_numtype, T_iterator> operator,(T_numtype x)
    {
        *iter_ = x;
        return ListInitializer<T_numtype, T_iterator>(iter_ + 1);
    }

private:
    ListInitializer();

protected:
    T_iterator iter_;
};

template<class T_array, class T_iterator = typename  T_array::T_numtype*>
class ListInitializationSwitch {

public:
    typedef typename  T_array::T_numtype T_numtype;

    ListInitializationSwitch(const ListInitializationSwitch<T_array>& lis)
        : array_(lis.array_), value_(lis.value_), 
          wipeOnDestruct_(true )
    {
        lis.disable();
    }

    ListInitializationSwitch(T_array& array, T_numtype value)
        : array_(array), value_(value), wipeOnDestruct_(true )
    { }

    ~ListInitializationSwitch()
    {
        if (wipeOnDestruct_)
            array_.initialize(value_);
    }

    ListInitializer<T_numtype, T_iterator> operator,(T_numtype x)
    {
        wipeOnDestruct_ = false ;
        T_iterator iter = array_.getInitializationIterator();
        *iter = value_;
        T_iterator iter2 = iter + 1;
        *iter2 = x;
        return ListInitializer<T_numtype, T_iterator>(iter2 + 1);
    }

    void disable() const
    {
        wipeOnDestruct_ = false ;
    }

private:
    ListInitializationSwitch();

protected:
    T_array& array_;
    T_numtype value_;
    mutable bool  wipeOnDestruct_;
};

} 



# 46 "../blitz/tinyvec.h" 2



# 1 "../blitz/tiny.h" 1
 








































namespace  blitz  { 

class _bz_tinyBase {
};

} 



# 49 "../blitz/tinyvec.h" 2


namespace  blitz  { 

 



template<class P_numtype, int N_length, int N_stride =  1   >
class TinyVectorIter;

template<class P_numtype, int N_length, int N_stride =  1   >
class TinyVectorIterConst;

template<class P_numtype>
class Vector;

template<class P_expr>
class _bz_VecExpr;

template<class P_distribution>
class Random;

template<class P_numtype>
class VectorPick;

template<class T_numtype1, class T_numtype2, int N_rows, int N_columns,
    int N_vecStride>
class _bz_matrixVectorProduct;



 



template<class P_numtype, int N_length>
class TinyVector {

public:
     
     
     

    typedef P_numtype                                    T_numtype;
    typedef TinyVector<T_numtype,N_length>               T_vector;
    typedef TinyVectorIter<T_numtype,N_length,1>         T_iterator;
    typedef TinyVectorIterConst<T_numtype,N_length,1>    T_constIterator;
    typedef T_iterator iterator;
    typedef T_constIterator const_iterator;
    enum { numElements = N_length };

    TinyVector()
    { }

    ~TinyVector() 
    { }

    inline TinyVector(const TinyVector<P_numtype,N_length>& x);

    inline TinyVector(T_numtype initValue);

    TinyVector(T_numtype x0, T_numtype x1)
    {
        data_[0] = x0;
        data_[1] = x1;
    }

    TinyVector(T_numtype x0, T_numtype x1, T_numtype x2)
    {
        data_[0] = x0;
        data_[1] = x1;
        data_[2] = x2;
    }

    TinyVector(T_numtype x0, T_numtype x1, T_numtype x2,
        T_numtype x3)
    {
        data_[0] = x0;
        data_[1] = x1;
        data_[2] = x2;
        data_[3] = x3;
    }

    TinyVector(T_numtype x0, T_numtype x1, T_numtype x2,
        T_numtype x3, T_numtype x4)
    {
        data_[0] = x0;
        data_[1] = x1;
        data_[2] = x2;
        data_[3] = x3;
        data_[4] = x4;
    }

    TinyVector(T_numtype x0, T_numtype x1, T_numtype x2,
        T_numtype x3, T_numtype x4, T_numtype x5)
    {
        data_[0] = x0;
        data_[1] = x1;
        data_[2] = x2;
        data_[3] = x3;
        data_[4] = x4;
        data_[5] = x5;
    }

    TinyVector(T_numtype x0, T_numtype x1, T_numtype x2,
        T_numtype x3, T_numtype x4, T_numtype x5, T_numtype x6)
    {
        data_[0] = x0;
        data_[1] = x1;
        data_[2] = x2;
        data_[3] = x3;
        data_[4] = x4;
        data_[5] = x5;
        data_[6] = x6;
    }

    TinyVector(T_numtype x0, T_numtype x1, T_numtype x2,
        T_numtype x3, T_numtype x4, T_numtype x5, T_numtype x6,
        T_numtype x7)
    {
        data_[0] = x0;
        data_[1] = x1;
        data_[2] = x2;
        data_[3] = x3;
        data_[4] = x4;
        data_[5] = x5;
        data_[6] = x6;
        data_[7] = x7;
    }

    TinyVector(T_numtype x0, T_numtype x1, T_numtype x2,
        T_numtype x3, T_numtype x4, T_numtype x5, T_numtype x6,
        T_numtype x7, T_numtype x8)
    {
        data_[0] = x0;
        data_[1] = x1;
        data_[2] = x2;
        data_[3] = x3;
        data_[4] = x4;
        data_[5] = x5;
        data_[6] = x6;
        data_[7] = x7;
        data_[8] = x8;
    }

    TinyVector(T_numtype x0, T_numtype x1, T_numtype x2,
        T_numtype x3, T_numtype x4, T_numtype x5, T_numtype x6,
        T_numtype x7, T_numtype x8, T_numtype x9)
    {
        data_[0] = x0;
        data_[1] = x1;
        data_[2] = x2;
        data_[3] = x3;
        data_[4] = x4;
        data_[5] = x5;
        data_[6] = x6;
        data_[7] = x7;
        data_[8] = x8;
        data_[9] = x9;
    }

    TinyVector(T_numtype x0, T_numtype x1, T_numtype x2,
        T_numtype x3, T_numtype x4, T_numtype x5, T_numtype x6,
        T_numtype x7, T_numtype x8, T_numtype x9, T_numtype x10)
    {
        data_[0] = x0;
        data_[1] = x1;
        data_[2] = x2;
        data_[3] = x3;
        data_[4] = x4;
        data_[5] = x5;
        data_[6] = x6;
        data_[7] = x7;
        data_[8] = x8;
        data_[9] = x9;
        data_[10] = x10;
    }

     
    template<class P_expr>
    inline TinyVector(_bz_VecExpr<P_expr> expr);

    T_iterator begin()
    { return T_iterator(*this); }

    T_constIterator begin() const
    { return T_constIterator(*this); }

     
     

    T_numtype *   data()
    { return data_; }

    const T_numtype *   data() const
    { return data_; }

    T_numtype *   dataFirst()
    { return data_; }

    const T_numtype *   dataFirst() const
    { return data_; }

    unsigned length() const
    { return N_length; }

     
     
     
     
     

    unsigned        _bz_suggestLength() const
    { return N_length; }

    bool         _bz_hasFastAccess() const
    { return true ; }

    T_numtype&       _bz_fastAccess(unsigned i)
    { return data_[i]; }

    T_numtype       _bz_fastAccess(unsigned i) const
    { return data_[i]; }

    template<class P_expr, class P_updater>
    void _bz_assign(P_expr, P_updater);

    _bz_VecExpr<T_constIterator> _bz_asVecExpr() const
    { return _bz_VecExpr<T_constIterator>(begin()); }
   
     
     
     

    int lengthCheck(unsigned i) const
    {
         ;


        return 1;
    }

    T_numtype operator()(unsigned i) const
    {
         ;
        return data_[i];
    }

    T_numtype&   operator()(unsigned i)
    { 
         ;
        return data_[i];
    }

    T_numtype operator[](unsigned i) const
    {
         ;
        return data_[i];
    }

    T_numtype&   operator[](unsigned i)
    {
         ;
        return data_[i];
    }

     
     
     

     
    ListInitializationSwitch<T_vector> operator=(T_numtype x)
    {
        return ListInitializationSwitch<T_vector>(*this, x);
    }

    T_vector& initialize(T_numtype);
    T_vector& operator+=(T_numtype);
    T_vector& operator-=(T_numtype);
    T_vector& operator*=(T_numtype);
    T_vector& operator/=(T_numtype);
    T_vector& operator%=(T_numtype);
    T_vector& operator^=(T_numtype);
    T_vector& operator&=(T_numtype);
    T_vector& operator|=(T_numtype);
    T_vector& operator>>=(int);
    T_vector& operator<<=(int);

    template<class P_numtype2> 
    T_vector& operator=(const TinyVector<P_numtype2, N_length> &);
    template<class P_numtype2>
    T_vector& operator+=(const TinyVector<P_numtype2, N_length> &);
    template<class P_numtype2>
    T_vector& operator-=(const TinyVector<P_numtype2, N_length> &);
    template<class P_numtype2>
    T_vector& operator*=(const TinyVector<P_numtype2, N_length> &);
    template<class P_numtype2>
    T_vector& operator/=(const TinyVector<P_numtype2, N_length> &);
    template<class P_numtype2>
    T_vector& operator%=(const TinyVector<P_numtype2, N_length> &);
    template<class P_numtype2>
    T_vector& operator^=(const TinyVector<P_numtype2, N_length> &);
    template<class P_numtype2>
    T_vector& operator&=(const TinyVector<P_numtype2, N_length> &);
    template<class P_numtype2>
    T_vector& operator|=(const TinyVector<P_numtype2, N_length> &);
    template<class P_numtype2>
    T_vector& operator>>=(const TinyVector<P_numtype2, N_length> &);
    template<class P_numtype2>
    T_vector& operator<<=(const TinyVector<P_numtype2, N_length> &);

    template<class P_numtype2> T_vector& operator=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_vector& operator+=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_vector& operator-=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_vector& operator*=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_vector& operator/=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_vector& operator%=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_vector& operator^=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_vector& operator&=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_vector& operator|=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_vector& operator>>=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_vector& operator<<=(const Vector<P_numtype2> &);

     
    template<class P_expr> T_vector& operator=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_vector& operator+=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_vector& operator-=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_vector& operator*=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_vector& operator/=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_vector& operator%=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_vector& operator^=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_vector& operator&=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_vector& operator|=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_vector& operator>>=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_vector& operator<<=(_bz_VecExpr<P_expr>);

     
    template<class P_numtype2>
    T_vector& operator=(const VectorPick<P_numtype2> &);
    template<class P_numtype2>
    T_vector& operator+=(const VectorPick<P_numtype2> &);
    template<class P_numtype2>
    T_vector& operator-=(const VectorPick<P_numtype2> &);
    template<class P_numtype2>
    T_vector& operator*=(const VectorPick<P_numtype2> &);
    template<class P_numtype2>
    T_vector& operator/=(const VectorPick<P_numtype2> &);
    template<class P_numtype2>
    T_vector& operator%=(const VectorPick<P_numtype2> &);
    template<class P_numtype2>
    T_vector& operator^=(const VectorPick<P_numtype2> &);
    template<class P_numtype2>
    T_vector& operator&=(const VectorPick<P_numtype2> &);
    template<class P_numtype2>
    T_vector& operator|=(const VectorPick<P_numtype2> &);
    template<class P_numtype2>
    T_vector& operator>>=(const VectorPick<P_numtype2> &);
    template<class P_numtype2>
    T_vector& operator<<=(const VectorPick<P_numtype2> &);

     
    T_vector& operator=(Range);
    T_vector& operator+=(Range);
    T_vector& operator-=(Range);
    T_vector& operator*=(Range);
    T_vector& operator/=(Range);
    T_vector& operator%=(Range);
    T_vector& operator^=(Range);
    T_vector& operator&=(Range);
    T_vector& operator|=(Range);
    T_vector& operator>>=(Range);
    T_vector& operator<<=(Range);

    T_numtype*   getInitializationIterator()
    { return dataFirst(); }

private:
    T_numtype data_[N_length];
};


 
 

template<class T>
class TinyVector<T,0> {
};

} 

# 1 "../blitz/tinyveciter.h" 1
 












































namespace  blitz  { 

 
template<class P_numtype, int N_length, int N_stride>
class TinyVectorIter {
public:
    typedef P_numtype T_numtype;

    explicit  TinyVectorIter(TinyVector<T_numtype, N_length>& x)
        : data_(x.data())
    { }


    TinyVectorIter(const TinyVectorIter<T_numtype, N_length, N_stride>& iter)
        : data_(iter.data_)
    {
    }


    T_numtype operator[](unsigned i) const
    {
         ;
        return data_[i * N_stride];
    }

    T_numtype&   operator[](unsigned i)
    {
         ;
        return data_[i * N_stride];
    }

    T_numtype operator()(unsigned i) const
    {
         ;
        return data_[i * N_stride];
    }

    T_numtype&   operator()(unsigned i)
    {
         ;
        return data_[i * N_stride];
    }

    unsigned length(unsigned) const
    { return N_length; }

    enum { _bz_staticLengthCount = 1,
           _bz_dynamicLengthCount = 0,
           _bz_staticLength = 0 };

    bool  _bz_hasFastAccess() const
    { return true ; }

    T_numtype _bz_fastAccess(unsigned i) const
    { return data_[i * N_stride]; }

    T_numtype& _bz_fastAccess(unsigned i)
    { return data_[i * N_stride]; }

    unsigned _bz_suggestLength() const
    { return N_length; }

private:
    T_numtype *   data_;
};

 
template<class P_numtype, int N_length, int N_stride>
class TinyVectorIterConst {
public:
    typedef P_numtype T_numtype;

    explicit  TinyVectorIterConst(const TinyVector<T_numtype, N_length>& x)
        : data_(x.data())
    { }


    TinyVectorIterConst(const TinyVectorIterConst<T_numtype, N_length, 
        N_stride>& iter)
        : data_(iter.data_)
    {
    }

    void operator=(const TinyVectorIterConst<T_numtype, N_length, N_stride>& 
        iter)
    {
        data_ = iter.data_;
    }


    T_numtype operator[](unsigned i) const
    {
         ;
        return data_[i * N_stride];
    }

    T_numtype operator()(unsigned i) const
    {
         ;
        return data_[i * N_stride];
    }

    unsigned length(unsigned) const
    { return N_length; }

    enum { _bz_staticLengthCount = 1,
           _bz_dynamicLengthCount = 0,
           _bz_staticLength = 0 };

    bool  _bz_hasFastAccess() const
    { return true ; }

    T_numtype _bz_fastAccess(unsigned i) const
    { return data_[i * N_stride]; }

    unsigned _bz_suggestLength() const
    { return N_length; }

private:
    const T_numtype *   data_;
};

} 


# 440 "../blitz/tinyvec.h" 2

# 1 "../blitz/tvecglobs.h" 1
 


































 
# 1 "../blitz/meta/metaprog.h" 1
 



































namespace  blitz  { 

 

class _bz_meta_nullOperand {
public:
    _bz_meta_nullOperand() { }
};

template<class T> inline T operator+(const T& a, _bz_meta_nullOperand)
{ return a; }
template<class T> inline T operator*(const T& a, _bz_meta_nullOperand)
{ return a; }


 

template<int N1, int N2>
class _bz_meta_max {
public:
    enum { max = (N1 > N2) ? N1 : N2 };
};

 

template<int N1, int N2>
class _bz_meta_min {
public:
    enum { min = (N1 < N2) ? N1 : N2 };
};

}  


# 36 "../blitz/tvecglobs.h" 2







# 1 "../blitz/tvcross.h" 1
 




































namespace  blitz  { 

 






template<class T_numtype>
TinyVector<T_numtype,3> cross(const TinyVector<T_numtype,3>& x, 
    const TinyVector<T_numtype,3>& y)
{
    return TinyVector<T_numtype,3>(x[1]*y[2] - y[1]*x[2],
        y[0]*x[2] - x[0]*y[2], x[0]*y[1] - y[0]*x[1]);
}


} 


# 43 "../blitz/tvecglobs.h" 2

# 1 "../blitz/meta/dot.h" 1
 




































 
# 1 "../blitz/promote.h" 1
 





























namespace  blitz  { 


    






 





template<class T>
struct precision_trait {
    enum { precisionRank = 0,
           knowPrecisionRank = 0 };
};








template<> struct precision_trait<  int  > { enum { precisionRank =  100 , knowPrecisionRank = 1 }; }; 
template<> struct precision_trait<  unsigned int  > { enum { precisionRank =  200 , knowPrecisionRank = 1 }; }; 
template<> struct precision_trait<  long  > { enum { precisionRank =  300 , knowPrecisionRank = 1 }; }; 
template<> struct precision_trait<  unsigned long  > { enum { precisionRank =  400 , knowPrecisionRank = 1 }; }; 
template<> struct precision_trait<  float  > { enum { precisionRank =  500 , knowPrecisionRank = 1 }; }; 
template<> struct precision_trait<  double  > { enum { precisionRank =  600 , knowPrecisionRank = 1 }; }; 
template<> struct precision_trait<  long double  > { enum { precisionRank =  700 , knowPrecisionRank = 1 }; }; 


template<> struct precision_trait<  complex<float>  > { enum { precisionRank =  800 , knowPrecisionRank = 1 }; }; 
template<> struct precision_trait<  complex<double>  > { enum { precisionRank =  900 , knowPrecisionRank = 1 }; }; 
template<> struct precision_trait<  complex<long double>  > { enum { precisionRank =  1000 , knowPrecisionRank = 1 }; }; 


template<class T>
struct autopromote_trait {
    typedef T T_numtype;
};







 
 
 
template<> struct autopromote_trait< bool > { typedef   int  T_numtype; }; 
template<> struct autopromote_trait< char > { typedef   int  T_numtype; }; 
template<> struct autopromote_trait< unsigned char > { typedef   int  T_numtype; }; 
template<> struct autopromote_trait< short int > { typedef   int  T_numtype; }; 
template<> struct autopromote_trait< short unsigned int > { typedef   unsigned int  T_numtype; }; 

template<class T1, class T2, int promoteToT1>
struct _bz_promote2 {
    typedef T1 T_promote;
};

template<class T1, class T2>
struct _bz_promote2<T1,T2,0> {
    typedef T2 T_promote;
};

template<class T1_orig, class T2_orig>
struct promote_trait {
     
    typedef typename  autopromote_trait<T1_orig>::T_numtype T1;
    typedef typename  autopromote_trait<T2_orig>::T_numtype T2;

     
    enum {
      T1IsBetter =
        (int) precision_trait<T1>::precisionRank   >
          (int) precision_trait<T2>::precisionRank  ,

     
      knowBothRanks =
        (int) precision_trait<T1>::knowPrecisionRank  
      && (int) precision_trait<T2>::knowPrecisionRank  ,

     
      knowT1butNotT2 =  (int) precision_trait<T1>::knowPrecisionRank  
        && !((int) precision_trait<T2>::knowPrecisionRank  ),

     
      knowT2butNotT1 =  (int) precision_trait<T2>::knowPrecisionRank  
        && !((int) precision_trait<T1>::knowPrecisionRank  ),

     
      T1IsLarger = sizeof(T1) >= sizeof(T2),

     
     
     
      defaultPromotion = knowT1butNotT2 ? false  : 
         (knowT2butNotT1 ? true  : T1IsLarger)
    };

     
     
     

    enum {
      promoteToT1 = ((int) knowBothRanks   ? (int) T1IsBetter  
        : (int) defaultPromotion  ) ? 1 : 0
    };

    typedef typename _bz_promote2<T1,T2,promoteToT1>::T_promote T_promote;
};








} 


# 38 "../blitz/meta/dot.h" 2




 


namespace  blitz  { 

template<int N, int I>
class _bz_meta_vectorDot {
public:
    enum { loopFlag = (I < N-1) ? 1 : 0 };

    template<class T_expr1, class T_expr2>
    static inline typename  promote_trait< typename  T_expr1::T_numtype , 
        typename  T_expr2::T_numtype >::T_promote 
    f(const T_expr1& a, const T_expr2& b)
    {
        return a[I] * b[I]
            + _bz_meta_vectorDot<loopFlag * N, loopFlag * (I+1)>::f(a,b);
    }

    template<class T_expr1, class T_expr2>
    static inline typename  promote_trait< typename  T_expr1::T_numtype , 
        typename  T_expr2::T_numtype >::T_promote 
    f_value_ref(T_expr1 a, const T_expr2& b)
    {
        return a[I] * b[I]
            + _bz_meta_vectorDot<loopFlag * N, loopFlag * (I+1)>::f(a,b);
    }

    template<class T_expr1, class T_expr2>
    static inline typename  promote_trait< typename  T_expr1::T_numtype , 
        typename  T_expr2::T_numtype >::T_promote 
    f_ref_value(const T_expr1& a, T_expr2 b)
    {
        return a[I] * b[I]
            + _bz_meta_vectorDot<loopFlag * N, loopFlag * (I+1)>::f(a,b);
    }

    template<class T_expr1, class P_numtype2>
    static inline typename  promote_trait< typename  T_expr1::T_numtype , 
        P_numtype2 >::T_promote 
    dotWithArgs(const T_expr1& a, P_numtype2 i1, P_numtype2 i2=0,
        P_numtype2 i3=0, P_numtype2 i4=0, P_numtype2 i5=0, P_numtype2 i6=0,
        P_numtype2 i7=0, P_numtype2 i8=0, P_numtype2 i9=0, P_numtype2 i10=0)
    {
        return a[I] * i1  
            + _bz_meta_vectorDot<loopFlag * N, loopFlag * (I+1)>::dotWithArgs
                 (a, i2, i3, i4, i5, i6, i7, i8, i9);
    }
};

template<>
class _bz_meta_vectorDot<0,0> {
public:
    template<class T_expr1, class T_expr2>
    static inline _bz_meta_nullOperand f(const T_expr1&, const T_expr2&)
    { return _bz_meta_nullOperand(); }

    template<class T_expr1, class P_numtype2>
    static inline _bz_meta_nullOperand 
    dotWithArgs(const T_expr1& a, P_numtype2 i1, P_numtype2 i2=0,
        P_numtype2 i3=0, P_numtype2 i4=0, P_numtype2 i5=0, P_numtype2 i6=0,
        P_numtype2 i7=0, P_numtype2 i8=0, P_numtype2 i9=0, P_numtype2 i10=0)
    {
        return _bz_meta_nullOperand(); 
    }

};

} 


# 44 "../blitz/tvecglobs.h" 2

# 1 "../blitz/meta/product.h" 1
 








































 


namespace  blitz  { 

template<int N, int I>
class _bz_meta_vectorProduct {
public:
    enum { loopFlag = (I < N-1) ? 1 : 0 };

    template<class T_expr1>
    static inline typename  NumericTypeTraits< typename  T_expr1::T_numtype >::T_sumtype 
    f(const T_expr1& a)
    {
        return a[I] * _bz_meta_vectorProduct<loopFlag * N, 
            loopFlag * (I+1)>::f(a);
    }
};

template<>
class _bz_meta_vectorProduct<0,0> {
public:
    template<class T_expr1>
    static inline _bz_meta_nullOperand f(const T_expr1&)
    { return _bz_meta_nullOperand(); }
};

} 


# 45 "../blitz/tvecglobs.h" 2

# 1 "../blitz/meta/sum.h" 1
 




































 


namespace  blitz  { 

template<int N, int I>
class _bz_meta_vectorSum {
public:
    enum { loopFlag = (I < N-1) ? 1 : 0 };

    template<class T_expr1>
    static inline typename  T_expr1::T_numtype
    f(const T_expr1& a)
    {
        return a[I] +
            + _bz_meta_vectorSum<loopFlag * N, loopFlag * (I+1)>::f(a);
    }
};

template<>
class _bz_meta_vectorSum<0,0> {
public:
    template<class T_expr1>
    static inline _bz_meta_nullOperand f(const T_expr1&)
    { return _bz_meta_nullOperand(); }

};

} 


# 46 "../blitz/tvecglobs.h" 2


namespace  blitz  { 

template<class T_numtype1, class T_numtype2, int N_length>
inline typename  promote_trait< T_numtype1 ,  T_numtype2 >::T_promote 
dot(const TinyVector<T_numtype1, N_length>& a, 
    const TinyVector<T_numtype2, N_length>& b)
{
    return _bz_meta_vectorDot<N_length, 0>::f(a,b);
}

template<class T_expr1, class T_numtype2, int N_length>
inline typename  promote_trait< typename  T_expr1::T_numtype ,  T_numtype2 >::T_promote 
dot(_bz_VecExpr<T_expr1> a, const TinyVector<T_numtype2, N_length>& b)
{
    return _bz_meta_vectorDot<N_length, 0>::f_value_ref(a,b);
}

template<class T_numtype1, class T_expr2, int N_length>
inline typename  promote_trait< T_numtype1 ,  typename  T_expr2::T_numtype >::T_promote 
dot(const TinyVector<T_numtype1, N_length>& a, _bz_VecExpr<T_expr2> b)
{
    return _bz_meta_vectorDot<N_length, 0>::f_ref_value(a,b);
}

template<class T_numtype1, int N_length>
inline typename  NumericTypeTraits< T_numtype1 >::T_sumtype 
product(const TinyVector<T_numtype1, N_length>& a)
{
    return _bz_meta_vectorProduct<N_length, 0>::f(a);
}

template<class T_numtype, int N_length>
inline T_numtype
sum(const TinyVector<T_numtype, N_length>& a)
{
    return _bz_meta_vectorSum<N_length, 0>::f(a);
}

} 



# 441 "../blitz/tinyvec.h" 2

# 1 "../blitz/vector.h" 1
 














































 

















 










namespace  blitz  { 

 
template<class P_numtype> class VectorIter;
template<class P_numtype> class VectorIterConst;
template<class P_expr>    class _bz_VecExpr;       
template<class P_numtype> class VectorPick;
template<class P_numtype> class Random;

 

template<class P_numtype>
class Vector : protected MemoryBlockReference<P_numtype> {

public:
     
     
     

    typedef P_numtype                  T_numtype;
    typedef Vector<T_numtype>          T_vector;
    typedef VectorIter<T_numtype>      T_iterator;
    typedef VectorIterConst<T_numtype> T_constIterator;
    typedef VectorPick<T_numtype>      T_pick;
    typedef Vector<int>                T_indexVector;

     
     
     
     
     
     

    Vector()
    { 
        length_ = 0;
        stride_ = 0;
    }

     
     
    Vector(Vector<T_numtype>& vec)
        : MemoryBlockReference<T_numtype>(vec)
    {
        length_ = vec.length_;
        stride_ = vec.stride_;
    }

     
    Vector(const Vector<T_numtype>& vec)
        : MemoryBlockReference<T_numtype>
           (const_cast<Vector<T_numtype>& >(vec))
    {
        length_ = vec.length_;
        stride_ = vec.stride_;
    }

    explicit  Vector(int length)
        : MemoryBlockReference<T_numtype>(length)
    {
        length_ = length;
        stride_ = 1;
    }

    Vector(Vector<T_numtype>& vec, Range r)
        : MemoryBlockReference<T_numtype>(vec, 
            r.first() * vec.stride())
    {
         ;
         ;

        length_ = (r.last(vec.length()-1) - r.first()) / r.stride() + 1;
        stride_ = vec.stride_ * r.stride();
    }

    Vector(int length, T_numtype initValue)
        : MemoryBlockReference<T_numtype>(length)
    {
        length_ = length;
        stride_ = 1;
        (*this) = initValue;
    }

    Vector(int length, T_numtype firstValue, T_numtype delta)
        : MemoryBlockReference<T_numtype>(length)
    {
        length_ = length;
        stride_ = 1;
        for (int i=0; i < length; ++i)
            data_[i] = firstValue + i * delta;
    }

    template<class P_distribution>
    Vector(int length, Random<P_distribution>& random)
        : MemoryBlockReference<T_numtype>(length)
    {
        length_ = length;
        stride_ = 1;
        (*this) = random;
    }

    template<class P_expr>
    Vector(_bz_VecExpr<P_expr> expr)
        : MemoryBlockReference<T_numtype>(expr._bz_suggestLength())
    {
        length_ = expr._bz_suggestLength();
        stride_ = 1;
        (*this) = expr;
    }

     
     
     
    Vector(int length, T_numtype*   data, int stride = 1)
        : MemoryBlockReference<T_numtype>(length, data)
    {
        length_ = length;
        stride_ = stride;
    }

     
    Vector(Range r)
        : MemoryBlockReference<T_numtype>(r._bz_suggestLength())
    {
        length_ = r._bz_suggestLength();
        stride_ = 1;
        (*this) = _bz_VecExpr<Range>(r);
    }
    
     
     
     

     
     
     
     
     
     
     
    void            assertUnitStride()
    {
         ;
        stride_ = 1;
    }

    T_iterator      begin()
    { return T_iterator(*this); }

    T_constIterator begin()  const
    { return T_constIterator(*this); }

    T_vector        copy()   const;

     
     

    T_numtype *   data()  
    { return data_; }

    const T_numtype *   data() const
    { return data_; }

    bool         isUnitStride() const
    { return stride_ == 1; }

    int        length() const
    { return length_; }

    void            makeUnique();

     

     

    void            reference(T_vector&);

    void            resize(int length);

    void            resizeAndPreserve(int newLength);

     

    T_vector        reverse()
    { return T_vector(*this,Range(length()-1,0,-1)); }

    int             stride() const
    { return stride_; }

    operator _bz_VecExpr<VectorIterConst<T_numtype> > () const
    { return _bz_VecExpr<VectorIterConst<T_numtype> >(begin()); }

     
     
     
     
     

    int        _bz_suggestLength() const
    { return length_; }

    bool         _bz_hasFastAccess() const
    { return stride_ == 1; }

    T_numtype&      _bz_fastAccess(int i)
    { return data_[i]; }

    T_numtype       _bz_fastAccess(int i) const
    { return data_[i]; }

    template<class P_expr, class P_updater>
    void            _bz_assign(P_expr, P_updater);

    _bz_VecExpr<T_constIterator> _bz_asVecExpr() const
    { return _bz_VecExpr<T_constIterator>(begin()); }

     
     
     

     
     
    T_numtype        operator()(int i) const
    {
         ;
         ;
        return data_[i];
    }

     
     
    T_numtype&   operator()(int i) 
    {
         ;
         ;
        return data_[i];
    }

    T_numtype        operator[](int i) const
    {
         ;
        return data_[i * stride_];
    }

    T_numtype&   operator[](int i)
    {
         ;
        return data_[i * stride_];
    }

    T_vector      operator()(Range r)
    {
        return T_vector(*this, r);
    }

    T_vector      operator[](Range r)
    {
        return T_vector(*this, r);
    }

    T_pick        operator()(T_indexVector i)
    {
        return T_pick(*this, i);
    }

    T_pick        operator[](T_indexVector i)
    {
        return T_pick(*this, i);
    }

     

     
     
     

     
    ListInitializationSwitch<T_vector,T_iterator> operator=(T_numtype x)
    {
        return ListInitializationSwitch<T_vector,T_iterator>(*this, x);
    }

    T_iterator getInitializationIterator()
    { return begin(); }

    T_vector& initialize(T_numtype);
    T_vector& operator+=(T_numtype);
    T_vector& operator-=(T_numtype);
    T_vector& operator*=(T_numtype);
    T_vector& operator/=(T_numtype);
    T_vector& operator%=(T_numtype);
    T_vector& operator^=(T_numtype);
    T_vector& operator&=(T_numtype);
    T_vector& operator|=(T_numtype);
    T_vector& operator>>=(int);
    T_vector& operator<<=(int); 

     
   
    template<class P_numtype2> T_vector& operator=(const Vector<P_numtype2> &);

     
     
     
     

    template<class P_numtype2> T_vector& operator+=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_vector& operator-=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_vector& operator*=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_vector& operator/=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_vector& operator%=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_vector& operator^=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_vector& operator&=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_vector& operator|=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_vector& operator>>=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_vector& operator<<=(const Vector<P_numtype2> &);

     
    template<class P_expr> T_vector& operator=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_vector& operator+=(_bz_VecExpr<P_expr>); 
    template<class P_expr> T_vector& operator-=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_vector& operator*=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_vector& operator/=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_vector& operator%=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_vector& operator^=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_vector& operator&=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_vector& operator|=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_vector& operator>>=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_vector& operator<<=(_bz_VecExpr<P_expr>);
    
     
    template<class P_numtype2> 
    T_vector& operator=(const VectorPick<P_numtype2> &);
    template<class P_numtype2> 
    T_vector& operator+=(const VectorPick<P_numtype2> &);
    template<class P_numtype2> 
    T_vector& operator-=(const VectorPick<P_numtype2> &);
    template<class P_numtype2> 
    T_vector& operator*=(const VectorPick<P_numtype2> &);
    template<class P_numtype2> 
    T_vector& operator/=(const VectorPick<P_numtype2> &);
    template<class P_numtype2>
    T_vector& operator%=(const VectorPick<P_numtype2> &);
    template<class P_numtype2>
    T_vector& operator^=(const VectorPick<P_numtype2> &);
    template<class P_numtype2>
    T_vector& operator&=(const VectorPick<P_numtype2> &);
    template<class P_numtype2>
    T_vector& operator|=(const VectorPick<P_numtype2> &);
    template<class P_numtype2>
    T_vector& operator>>=(const VectorPick<P_numtype2> &);
    template<class P_numtype2>
    T_vector& operator<<=(const VectorPick<P_numtype2> &);

     
    T_vector& operator=(Range);
    T_vector& operator+=(Range);
    T_vector& operator-=(Range);
    T_vector& operator*=(Range);
    T_vector& operator/=(Range);
    T_vector& operator%=(Range);
    T_vector& operator^=(Range);
    T_vector& operator&=(Range);
    T_vector& operator|=(Range);
    T_vector& operator>>=(Range);
    T_vector& operator<<=(Range);

     
    template<class P_distribution>
    T_vector& operator=(Random<P_distribution>& random);
    template<class P_distribution>
    T_vector& operator+=(Random<P_distribution>& random);
    template<class P_distribution>
    T_vector& operator-=(Random<P_distribution>& random);
    template<class P_distribution>
    T_vector& operator*=(Random<P_distribution>& random);
    template<class P_distribution>
    T_vector& operator/=(Random<P_distribution>& random);
    template<class P_distribution>
    T_vector& operator%=(Random<P_distribution>& random);
    template<class P_distribution>
    T_vector& operator^=(Random<P_distribution>& random);
    template<class P_distribution>
    T_vector& operator&=(Random<P_distribution>& random);
    template<class P_distribution>
    T_vector& operator|=(Random<P_distribution>& random);

     
     
     

 
 
 
 
    
private:
    int      length_;
    int      stride_;
};

 

template<class P_numtype>
ostream& operator<<(ostream& os, const Vector<P_numtype>& x);

template<class P_expr>
ostream& operator<<(ostream& os, _bz_VecExpr<P_expr> expr);

} 

# 1 "../blitz/veciter.h" 1
 


















































namespace  blitz  { 

 
template<class P_numtype>
class VectorIter {
public:
    typedef P_numtype T_numtype;

    explicit  VectorIter(Vector<P_numtype>& x)
        : data_(x.data())
    {
        stride_ = x.stride();
        length_ = x.length();
    }

    VectorIter(P_numtype*   data, int stride, int length)
        : data_(data), stride_(stride), length_(length)
    { }


    VectorIter(const VectorIter<P_numtype>& x)
    {
        data_ = x.data_;
        stride_ = x.stride_;
        length_ = x.length_;
    }


    P_numtype operator[](int i) const
    { 
         ;
        return data_[i*stride_]; 
    }

    P_numtype&   operator[](int i)
    { 
         ;
        return data_[i*stride_]; 
    }

    P_numtype operator()(int i) const
    {
         ;
        return data_[i*stride_];
    }

    P_numtype&   operator()(int i) 
    {
         ;
        return data_[i*stride_];
    }

    P_numtype operator*() const
    { return *data_; }

    P_numtype& operator*()
    { return *data_; }

    VectorIter<P_numtype> operator+(int i)
    {
         
        return VectorIter<P_numtype>(data_+i*stride_, stride_, length_-i);
    }

    int length(int) const
    { return length_; }

    bool  isUnitStride() const
    { return (stride_ == 1); }

     
     
     
     
     

    enum { _bz_staticLengthCount = 0,
           _bz_dynamicLengthCount = 1,
           _bz_staticLength = 0 };

    bool  _bz_hasFastAccess() const
    { return isUnitStride(); }

    P_numtype _bz_fastAccess(int i) const
    { return data_[i]; }

    P_numtype&   _bz_fastAccess(int i)
    { return data_[i]; }

    int _bz_suggestLength() const
    { return length_; }

private:
    VectorIter() { }
    P_numtype *   data_;
    int stride_;
    int length_;
};


template<class P_numtype>
class VectorIterConst {
public:
    typedef P_numtype T_numtype;

    explicit  VectorIterConst(const Vector<P_numtype>& x)
        : data_(x.data())
    {
        stride_ = x.stride();
        length_ = x.length();
    }


    VectorIterConst(const VectorIterConst<P_numtype>& x)
    {
        data_ = x.data_;
        stride_ = x.stride_;
        length_ = x.length_;
    }


    P_numtype operator[](int i) const
    { 
         ;
        return data_[i*stride_]; 
    }

    P_numtype operator()(int i) const
    {
         ;
        return data_[i*stride_];
    }

    int length(int) const
    { return length_; }

    bool  isUnitStride() const
    { return (stride_ == 1); }

     
     
     
     
     

    enum { _bz_staticLengthCount = 0,
           _bz_dynamicLengthCount = 1,
           _bz_staticLength = 0 };

    bool   _bz_hasFastAccess() const
    { return isUnitStride(); }

    P_numtype _bz_fastAccess(int i) const
    {
        return data_[i];
    }

    int _bz_suggestLength() const
    { return length_; }

private:
    const P_numtype *   data_;
    int stride_;
    int length_;
};

} 


# 488 "../blitz/vector.h" 2

# 1 "../blitz/vecpick.h" 1
 

















































namespace  blitz  { 

 

template<class P_numtype> class VectorPickIter;
template<class P_numtype> class VectorPickIterConst;

 

template<class P_numtype>
class VectorPick {

public:
     
     
     

    typedef P_numtype                      T_numtype;
    typedef Vector<T_numtype>              T_vector;
    typedef Vector<int>                    T_indexVector;
    typedef VectorPick<T_numtype>          T_pick;
    typedef VectorPickIter<T_numtype>      T_iterator;
    typedef VectorPickIterConst<T_numtype> T_constIterator;

     
     
     

    VectorPick(T_vector& vector, T_indexVector& indexarg)
        : vector_(vector), index_(indexarg)
    { }

    VectorPick(const T_pick& vecpick)
        : vector_(const_cast<T_vector&>(vecpick.vector_)), 
          index_(const_cast<T_indexVector&>(vecpick.index_))
    { }

    VectorPick(T_pick& vecpick, Range r)
        : vector_(vecpick.vector_), index_(vecpick.index_[r])
    { }
 
     
     
     

    T_iterator         begin()
    { return VectorPickIter<T_numtype>(*this); }

    T_constIterator    begin()      const
    { return VectorPickIterConst<T_numtype>(*this); }

     

     

     

    T_indexVector&     indexSet()
    { return index_; }
 
    const T_indexVector& indexSet()      const
    { return index_; }

    int           length()     const
    { return index_.length(); }

    void               setVector(Vector<T_numtype>& x)
    { vector_.reference(x); }

    void               setIndex(Vector<int>& index)
    { index_.reference(index); }

    T_vector&          vector()
    { return vector_; }

    const T_vector&    vector()     const
    { return vector_; }

     
     
     
     
     

    int        _bz_suggestLength() const
    { return index_.length(); }

    bool         _bz_hasFastAccess() const
    { return vector_._bz_hasFastAccess() && index_._bz_hasFastAccess(); }

    T_numtype&      _bz_fastAccess(int i)
    { return vector_._bz_fastAccess(index_._bz_fastAccess(i)); }

    T_numtype       _bz_fastAccess(int i) const
    { return vector_._bz_fastAccess(index_._bz_fastAccess(i)); }

    _bz_VecExpr<T_constIterator> _bz_asVecExpr() const
    { return _bz_VecExpr<T_constIterator>(begin()); }

     
     
     

    T_numtype       operator()(int i) const
    { 
         ;
         ;
         ;
         ;
        return vector_(index_(i));
    }

    T_numtype&      operator()(int i)
    {
         ;
         ;
         ;
         ;
        return vector_(index_(i));
    }

    T_numtype       operator[](int i) const
    {
         ;
         ;
         ;
         ;
        return vector_[index_[i]];
    }

    T_numtype&      operator[](int i)
    {
         ;
         ;
         ;
         ;
        return vector_[index_[i]];
    }

    T_pick          operator()(Range r)
    {
        return T_pick(*this, index_[r]);
    }

    T_pick          operator[](Range r)
    {
        return T_pick(*this, index_[r]);
    }

     
     
     

     
    T_pick& operator=(T_numtype);
    T_pick& operator+=(T_numtype);
    T_pick& operator-=(T_numtype);
    T_pick& operator*=(T_numtype);
    T_pick& operator/=(T_numtype);
    T_pick& operator%=(T_numtype);
    T_pick& operator^=(T_numtype);
    T_pick& operator&=(T_numtype);
    T_pick& operator|=(T_numtype);
    T_pick& operator>>=(int);
    T_pick& operator<<=(int);

     
    template<class P_numtype2> T_pick& operator=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_pick& operator+=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_pick& operator-=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_pick& operator*=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_pick& operator/=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_pick& operator%=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_pick& operator^=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_pick& operator&=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_pick& operator|=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_pick& operator>>=(const Vector<P_numtype2> &);
    template<class P_numtype2> T_pick& operator<<=(const Vector<P_numtype2> &);

     
    template<class P_expr> T_pick& operator=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_pick& operator+=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_pick& operator-=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_pick& operator*=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_pick& operator/=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_pick& operator%=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_pick& operator^=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_pick& operator&=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_pick& operator|=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_pick& operator>>=(_bz_VecExpr<P_expr>);
    template<class P_expr> T_pick& operator<<=(_bz_VecExpr<P_expr>);

     
    T_pick& operator=(Range);
    T_pick& operator+=(Range);
    T_pick& operator-=(Range);
    T_pick& operator*=(Range);
    T_pick& operator/=(Range);
    T_pick& operator%=(Range);
    T_pick& operator^=(Range);
    T_pick& operator&=(Range);
    T_pick& operator|=(Range);
    T_pick& operator>>=(Range);
    T_pick& operator<<=(Range);

     
    template<class P_numtype2> 
    T_pick& operator=(const VectorPick<P_numtype2> &);
    template<class P_numtype2> 
    T_pick& operator+=(const VectorPick<P_numtype2> &);
    template<class P_numtype2> 
    T_pick& operator-=(const VectorPick<P_numtype2> &);
    template<class P_numtype2> 
    T_pick& operator*=(const VectorPick<P_numtype2> &);
    template<class P_numtype2> 
    T_pick& operator/=(const VectorPick<P_numtype2> &);
    template<class P_numtype2> 
    T_pick& operator%=(const VectorPick<P_numtype2> &);
    template<class P_numtype2> 
    T_pick& operator^=(const VectorPick<P_numtype2> &);
    template<class P_numtype2> 
    T_pick& operator&=(const VectorPick<P_numtype2> &);
    template<class P_numtype2> 
    T_pick& operator|=(const VectorPick<P_numtype2> &);
    template<class P_numtype2> 
    T_pick& operator>>=(const VectorPick<P_numtype2> &);
    template<class P_numtype2> 
    T_pick& operator<<=(const VectorPick<P_numtype2> &);

     
    template<class P_distribution>
    T_pick& operator=(Random<P_distribution>& random);
    template<class P_distribution>
    T_pick& operator+=(Random<P_distribution>& random);
    template<class P_distribution>
    T_pick& operator-=(Random<P_distribution>& random);
    template<class P_distribution>
    T_pick& operator*=(Random<P_distribution>& random);
    template<class P_distribution>
    T_pick& operator/=(Random<P_distribution>& random);
    template<class P_distribution>
    T_pick& operator%=(Random<P_distribution>& random);
    template<class P_distribution>
    T_pick& operator^=(Random<P_distribution>& random);
    template<class P_distribution>
    T_pick& operator&=(Random<P_distribution>& random);
    template<class P_distribution>
    T_pick& operator|=(Random<P_distribution>& random);

private:
    VectorPick() { }

    template<class P_expr, class P_updater>
    inline void _bz_assign(P_expr, P_updater);

private:
    T_vector vector_;
    T_indexVector index_;
};

} 

# 1 "../blitz/vecpick.cc" 1
 


























 
# 1 "../blitz/update.h" 1
 

















































namespace  blitz  { 

class _bz_updater_base { };


# 64 "../blitz/update.h"

template<class X, class Y>
class _bz_update : public _bz_updater_base {
  public:
    static inline void update(X&   x, Y y)
    { x = (X)y; }

    static void prettyPrint(string& str)
    { str += "="; }
};

template<class X, class Y> class  _bz_plus_update  : public _bz_updater_base { public: static inline void update(X&   x, Y y) { x   +=  y; } static void prettyPrint(string& str) { str +=   "+=" ; } } ;
template<class X, class Y> class  _bz_minus_update  : public _bz_updater_base { public: static inline void update(X&   x, Y y) { x   -=  y; } static void prettyPrint(string& str) { str +=   "-=" ; } } ;
template<class X, class Y> class  _bz_multiply_update  : public _bz_updater_base { public: static inline void update(X&   x, Y y) { x   *=  y; } static void prettyPrint(string& str) { str +=   "*=" ; } } ;
template<class X, class Y> class  _bz_divide_update  : public _bz_updater_base { public: static inline void update(X&   x, Y y) { x   /=  y; } static void prettyPrint(string& str) { str +=   "/=" ; } } ;
template<class X, class Y> class  _bz_mod_update  : public _bz_updater_base { public: static inline void update(X&   x, Y y) { x   %=  y; } static void prettyPrint(string& str) { str +=   "%=" ; } } ;
template<class X, class Y> class  _bz_xor_update  : public _bz_updater_base { public: static inline void update(X&   x, Y y) { x   ^=  y; } static void prettyPrint(string& str) { str +=   "^=" ; } } ;
template<class X, class Y> class  _bz_bitand_update  : public _bz_updater_base { public: static inline void update(X&   x, Y y) { x   &=  y; } static void prettyPrint(string& str) { str +=   "&=" ; } } ;
template<class X, class Y> class  _bz_bitor_update  : public _bz_updater_base { public: static inline void update(X&   x, Y y) { x   |=  y; } static void prettyPrint(string& str) { str +=   "|=" ; } } ;
template<class X, class Y> class  _bz_shiftl_update  : public _bz_updater_base { public: static inline void update(X&   x, Y y) { x   <<=  y; } static void prettyPrint(string& str) { str +=   "<<=" ; } } ;
template<class X, class Y> class  _bz_shiftr_update  : public _bz_updater_base { public: static inline void update(X&   x, Y y) { x   >>=  y; } static void prettyPrint(string& str) { str +=   ">>=" ; } } ;

} 



# 28 "../blitz/vecpick.cc" 2




 
# 1 "../blitz/random.h" 1
 










































namespace  blitz  { 

template<class P_distribution>
class Random {

public:
    typedef P_distribution T_distribution;
    typedef typename  T_distribution::T_numtype T_numtype;

    Random(double parm1=0.0, double parm2=1.0, double parm3=0.0)
        : generator_(parm1, parm2, parm3)
    { }

    void randomize()
    { generator_.randomize(); }
   
    T_numtype random()
    { return generator_.random(); }

    operator T_numtype()
    { return generator_.random(); }

protected: 
    T_distribution generator_;
};

} 

# 1 "../blitz/randref.h" 1
 








































namespace  blitz  { 

template<class P_distribution>
class _bz_VecExprRandom {

public:
    typedef typename  Random<P_distribution>::T_numtype T_numtype;

    _bz_VecExprRandom(Random<P_distribution>& random)
        : random_(random)
    { }


    _bz_VecExprRandom(_bz_VecExprRandom<P_distribution>& x)
        : random_(x.random_)
    { }


    T_numtype operator[](unsigned) const
    { return random_.random(); }

    T_numtype operator()(unsigned) const
    { return random_.random(); }

    unsigned length(unsigned recommendedLength) const
    { return recommendedLength; }

    unsigned _bz_suggestLength() const
    { return 0; }

    bool  _bz_hasFastAccess() const
    { return 1; }

    T_numtype _bz_fastAccess(unsigned) const
    { return random_.random(); }

private:
    _bz_VecExprRandom() { }

    Random<P_distribution>& random_;
};

} 



# 72 "../blitz/random.h" 2




# 32 "../blitz/vecpick.cc" 2




 
# 1 "../blitz/vecexpr.h" 1
 



















































 
# 1 "../blitz/applics.h" 1
 






















































namespace  blitz  { 

 
 
 
class ApplicativeTemplatesBase { };
class TwoOperandApplicativeTemplatesBase : public ApplicativeTemplatesBase { };
class OneOperandApplicativeTemplatesBase : public ApplicativeTemplatesBase { };

template<class P_numtype1, class P_numtype2>
class _bz_Add : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef typename  promote_trait< T_numtype1 , T_numtype2 >::T_promote  T_promote; 
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x + y; }
};

template<class P_numtype1, class P_numtype2>
class _bz_Subtract : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef typename  promote_trait< T_numtype1 , T_numtype2 >::T_promote  T_promote;
    typedef T_promote  T_numtype;
 
    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x - y; }
};

template<class P_numtype1, class P_numtype2>
class _bz_Multiply : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef typename  promote_trait< T_numtype1 , T_numtype2 >::T_promote  T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x * y; }
};

template<class P_numtype1, class P_numtype2>
class _bz_Divide : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef typename  promote_trait< T_numtype1 , T_numtype2 >::T_promote  T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x / y; }
};

template<class P_numtype1, class P_numtype2>
class _bz_Mod : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef typename  promote_trait< T_numtype1 , T_numtype2 >::T_promote  T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x % y; }
};

template<class P_numtype1, class P_numtype2>
class _bz_BitwiseXOR : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef typename  promote_trait< T_numtype1 , T_numtype2 >::T_promote  T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x ^ y; }
};

template<class P_numtype1, class P_numtype2>
class _bz_BitwiseAnd : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef typename  promote_trait< T_numtype1 , T_numtype2 >::T_promote  T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x & y; }
};

template<class P_numtype1, class P_numtype2>
class _bz_BitwiseOr : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef typename  promote_trait< T_numtype1 , T_numtype2 >::T_promote  T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x | y; }
};

template<class P_numtype1, class P_numtype2>
class _bz_ShiftRight : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef typename  promote_trait< T_numtype1 , T_numtype2 >::T_promote  T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x >> y; }
};

template<class P_numtype1, class P_numtype2>
class _bz_ShiftLeft : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef typename  promote_trait< T_numtype1 , T_numtype2 >::T_promote  T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x << y; }
};

template<class P_numtype1, class P_numtype2>
class _bz_Greater : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef bool    T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x > y; }
};

template<class P_numtype1, class P_numtype2>
class _bz_Less : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef bool    T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x < y; }
};

template<class P_numtype1, class P_numtype2>
class _bz_GreaterOrEqual : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef bool    T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x >= y; }
};

template<class P_numtype1, class P_numtype2>
class _bz_LessOrEqual : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef bool    T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x <= y; }
};

template<class P_numtype1, class P_numtype2>
class _bz_Equal : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef bool    T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x == y; }
};

template<class P_numtype1, class P_numtype2>
class _bz_NotEqual : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef bool    T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x != y; }
};

template<class P_numtype1, class P_numtype2>
class _bz_LogicalAnd : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef bool    T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x && y; }
};

template<class P_numtype1, class P_numtype2>
class _bz_LogicalOr : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef bool    T_promote;
    typedef T_promote  T_numtype;

    static inline T_promote apply(P_numtype1 x, P_numtype2 y)
    { return x || y; }
};

template<class P_numtype_in, class P_numtype_out>
class _bz_Cast : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype_in T_numtype1;
    typedef P_numtype_out T_promote;
    typedef T_promote     T_numtype;

    static inline P_numtype_out apply(P_numtype_in x)
    { return P_numtype_out(x); }
};

template<class P_numtype>
class _bz_LogicalNot : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype     T_numtype1;
    typedef bool       T_promote;
    typedef T_promote     T_numtype;

    static inline P_numtype apply(P_numtype x)
    { return !x; }
};

template<class P_numtype>
class _bz_BitwiseNot : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype     T_numtype1;
    typedef T_numtype1    T_promote;
    typedef T_promote     T_numtype;

    static inline P_numtype apply(P_numtype x)
    { return ~x; }
};

 



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


} 


 
# 1 "../blitz/mathfunc.h" 1
 










 
# 1 "../blitz/prettyprint.h" 1
 

































namespace  blitz  { 

class prettyPrintFormat {

public:
    prettyPrintFormat(bool  terse = false )
      : tersePrintingSelected_(terse)
    {
        arrayOperandCounter_ = 0;
        scalarOperandCounter_ = 0;
        dumpArrayShapes_ = false ;
    }

    void setDumpArrayShapesMode()
    {
        dumpArrayShapes_ = true ;
    }

    char nextArrayOperandSymbol()
    {
        return 'A' + ((arrayOperandCounter_++) % 26);
    }

    char nextScalarOperandSymbol()
    {
        return 's' + ((scalarOperandCounter_++) % 26);
    }

    bool  tersePrintingSelected() const
    { 
        return tersePrintingSelected_;
    }

    bool  dumpArrayShapesMode() const
    {
        return dumpArrayShapes_;
    }

private:
    bool  tersePrintingSelected_;
    bool  dumpArrayShapes_;
    int arrayOperandCounter_;
    int scalarOperandCounter_;
};

} 


# 12 "../blitz/mathfunc.h" 2



namespace  blitz  { 

 
template<class P_numtype1>
class _bz_abs : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype1 T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: abs  (x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "abs(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_abs<long> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long T_numtype1;
    typedef long T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: labs  ((long)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "labs(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_abs<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: fabs  ((float)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "fabs(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_abs<double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef double T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: fabs  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "fabs(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_abs<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: fabs  ((long double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "fabs(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
# 137 "../blitz/mathfunc.h"


 
# 159 "../blitz/mathfunc.h"


 
# 181 "../blitz/mathfunc.h"


 
template<class P_numtype1>
class _bz_acos : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: acos  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "acos(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_acos<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: acos  ((float)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "acos(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_acos<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: acos  ((long double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "acos(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 

template<class P_numtype1>
class _bz_acosh : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return :: acosh  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "acosh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};


 
template<class P_numtype1>
class _bz_asin : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: asin  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "asin(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_asin<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: asin  ((float)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "asin(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_asin<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: asin  ((long double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "asin(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 

template<class P_numtype1>
class _bz_asinh : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return :: asinh  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "asinh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};


 
# 367 "../blitz/mathfunc.h"


 
# 389 "../blitz/mathfunc.h"


 
# 411 "../blitz/mathfunc.h"


 
# 433 "../blitz/mathfunc.h"


 
template<class P_numtype1>
class _bz_atan : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: atan  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "atan(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_atan<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: atan  ((float)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "atan(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_atan<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: atan  ((long double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "atan(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 

template<class P_numtype1>
class _bz_atanh : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return :: atanh  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "atanh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};


 
template<class P_numtype1, class P_numtype2>
class _bz_atan2 : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return std:: atan2  ((double)x,(double)y); }

    template<class T1, class T2>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "atan2(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_atan2<float, float > : public TwoOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype2;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return std:: atan2  ((float)x,(float)y); }

    template<class T1, class T2>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "atan2(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_atan2<long double, long double > : public TwoOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype2;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return std:: atan2  ((long double)x,(long double)y); }

    template<class T1, class T2>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "atan2(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};

 
# 606 "../blitz/mathfunc.h"


 

template<class P_numtype1>
class _bz_cbrt : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return :: cbrt  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "cbrt(";
        a.prettyPrint(str,format);
        str += ")";
    }
};


 
template<class P_numtype1>
class _bz_ceil : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: ceil  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "ceil(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_ceil<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: ceil  ((float)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "ceil(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_ceil<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: ceil  ((long double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "ceil(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
# 710 "../blitz/mathfunc.h"


 
template<class P_numtype1>
class _bz_cos : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: cos  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "cos(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_cos<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: cos  ((float)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "cos(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_cos<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: cos  ((long double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "cos(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
# 792 "../blitz/mathfunc.h"


 
# 814 "../blitz/mathfunc.h"


 
# 836 "../blitz/mathfunc.h"


 
# 861 "../blitz/mathfunc.h"


 
template<class P_numtype1>
class _bz_cosh : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: cosh  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "cosh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_cosh<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: cosh  ((float)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "cosh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_cosh<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: cosh  ((long double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "cosh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
# 943 "../blitz/mathfunc.h"


 
# 965 "../blitz/mathfunc.h"


 
# 987 "../blitz/mathfunc.h"


 
# 1012 "../blitz/mathfunc.h"


 
template<class P_numtype1>
class _bz_exp : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: exp  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "exp(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_exp<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: exp  ((float)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "exp(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_exp<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: exp  ((long double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "exp(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
# 1094 "../blitz/mathfunc.h"


 
# 1116 "../blitz/mathfunc.h"


 
# 1138 "../blitz/mathfunc.h"


 

template<class P_numtype1>
class _bz_expm1 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return :: expm1  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "expm1(";
        a.prettyPrint(str,format);
        str += ")";
    }
};


 

template<class P_numtype1>
class _bz_erf : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return :: erf  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "erf(";
        a.prettyPrint(str,format);
        str += ")";
    }
};


 

template<class P_numtype1>
class _bz_erfc : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return :: erfc  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "erfc(";
        a.prettyPrint(str,format);
        str += ")";
    }
};


 
template<class P_numtype1>
class _bz_floor : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: floor  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "floor(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_floor<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: floor  ((float)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "floor(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_floor<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: floor  ((long double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "floor(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
# 1289 "../blitz/mathfunc.h"


 
# 1314 "../blitz/mathfunc.h"


 
# 1336 "../blitz/mathfunc.h"


 

template<class P_numtype1>
class _bz_isnan : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef int T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return :: isnan  (x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "isnan(";
        a.prettyPrint(str,format);
        str += ")";
    }
};


 
# 1380 "../blitz/mathfunc.h"


 

template<class P_numtype1>
class _bz_j0 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return :: j0  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "j0(";
        a.prettyPrint(str,format);
        str += ")";
    }
};


 

template<class P_numtype1>
class _bz_j1 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return :: j1  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "j1(";
        a.prettyPrint(str,format);
        str += ")";
    }
};


 

template<class P_numtype1>
class _bz_lgamma : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return :: lgamma  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "lgamma(";
        a.prettyPrint(str,format);
        str += ")";
    }
};


 
template<class P_numtype1>
class _bz_log : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: log  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "log(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_log<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: log  ((float)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "log(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_log<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: log  ((long double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "log(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
# 1528 "../blitz/mathfunc.h"


 
# 1550 "../blitz/mathfunc.h"


 
# 1572 "../blitz/mathfunc.h"


 

template<class P_numtype1>
class _bz_logb : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return :: logb  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "logb(";
        a.prettyPrint(str,format);
        str += ")";
    }
};


 

template<class P_numtype1>
class _bz_log1p : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return :: log1p  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "log1p(";
        a.prettyPrint(str,format);
        str += ")";
    }
};


 
template<class P_numtype1>
class _bz_log10 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: log10  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "log10(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_log10<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: log10  ((float)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "log10(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_log10<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: log10  ((long double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "log10(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
# 1698 "../blitz/mathfunc.h"


 
# 1723 "../blitz/mathfunc.h"


template<class P_numtype>
class _bz_negate : public OneOperandApplicativeTemplatesBase {
public:
    typedef typename  NumericTypeTraits< P_numtype >::T_signedtype  T_numtype;

    static inline T_numtype apply(T_numtype x)
    { return -x; }
};

 
# 1754 "../blitz/mathfunc.h"


 
# 1779 "../blitz/mathfunc.h"


 
template<class P_numtype1, class P_numtype2>
class _bz_pow : public TwoOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype2 T_numtype2;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return std:: pow  ((double)x,(double)y); }

    template<class T1, class T2>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "pow(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_pow<float, float > : public TwoOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype2;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return std:: pow  ((float)x,(float)y); }

    template<class T1, class T2>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "pow(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_pow<long double, long double > : public TwoOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype2;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x, T_numtype2 y)
    { return std:: pow  ((long double)x,(long double)y); }

    template<class T1, class T2>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a, const T2& b)
    {
        str += "pow(";
        a.prettyPrint(str,format);
        str += ",";
        b.prettyPrint(str,format);
        str += ")";
    }
};

 
# 1873 "../blitz/mathfunc.h"


 
# 1898 "../blitz/mathfunc.h"


 
# 1923 "../blitz/mathfunc.h"


 
# 1948 "../blitz/mathfunc.h"


 

template<class P_numtype1>
class _bz_rint : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return :: rint  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "rint(";
        a.prettyPrint(str,format);
        str += ")";
    }
};


 
# 1992 "../blitz/mathfunc.h"


 
# 2017 "../blitz/mathfunc.h"


 
template<class P_numtype1>
class _bz_sin : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: sin  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sin(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_sin<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: sin  ((float)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sin(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_sin<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: sin  ((long double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sin(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
# 2099 "../blitz/mathfunc.h"


 
# 2121 "../blitz/mathfunc.h"


 
# 2143 "../blitz/mathfunc.h"


 
template<class P_numtype1>
class _bz_sinh : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: sinh  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sinh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_sinh<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: sinh  ((float)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sinh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_sinh<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: sinh  ((long double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sinh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
# 2225 "../blitz/mathfunc.h"


 
# 2247 "../blitz/mathfunc.h"


 
# 2269 "../blitz/mathfunc.h"


template<class P_numtype>
class _bz_sqr : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype T_numtype;

    static inline T_numtype apply(T_numtype x)
    { return x*x; }
    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sqr(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<class T>
class _bz_sqr<complex<T> > : public OneOperandApplicativeTemplatesBase {
public:
    typedef complex<T> T_numtype;

    static inline T_numtype apply(T_numtype x)
    {
        T r = x.real();  T i = x.imag();
        return T_numtype(r*r-i*i, 2*r*i);
    }
    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sqr(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<class P_numtype1>
class _bz_sqrt : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: sqrt  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sqrt(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_sqrt<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: sqrt  ((float)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sqrt(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_sqrt<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: sqrt  ((long double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "sqrt(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
# 2389 "../blitz/mathfunc.h"


 
# 2411 "../blitz/mathfunc.h"


 
# 2433 "../blitz/mathfunc.h"


 
template<class P_numtype1>
class _bz_tan : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: tan  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "tan(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_tan<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: tan  ((float)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "tan(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_tan<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: tan  ((long double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "tan(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
# 2515 "../blitz/mathfunc.h"


 
# 2537 "../blitz/mathfunc.h"


 
# 2559 "../blitz/mathfunc.h"


 
template<class P_numtype1>
class _bz_tanh : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: tanh  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "tanh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_tanh<float> : public OneOperandApplicativeTemplatesBase {
public:
    typedef float T_numtype1;
    typedef float T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: tanh  ((float)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "tanh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<>
class _bz_tanh<long double> : public OneOperandApplicativeTemplatesBase {
public:
    typedef long double T_numtype1;
    typedef long double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return std:: tanh  ((long double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "tanh(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
# 2641 "../blitz/mathfunc.h"


 
# 2663 "../blitz/mathfunc.h"


 
# 2685 "../blitz/mathfunc.h"


 
# 2707 "../blitz/mathfunc.h"


 
# 2732 "../blitz/mathfunc.h"


 

template<class P_numtype1>
class _bz_y0 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return :: y0  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "y0(";
        a.prettyPrint(str,format);
        str += ")";
    }
};


 

template<class P_numtype1>
class _bz_y1 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef double T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return :: y1  ((double)x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "y1(";
        a.prettyPrint(str,format);
        str += ")";
    }
};




} 


# 387 "../blitz/applics.h" 2




 
# 1 "../blitz/mathf2.h" 1











namespace  blitz  { 

 
template<class P_numtype1>
class _bz_cexp : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype1 T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return _bz_exp<T_numtype1>::apply(x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "cexp(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<class P_numtype1>
class _bz_csqrt : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype1 T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { return _bz_sqrt<T_numtype1>::apply(x); }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "csqrt(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<class P_numtype1>
class _bz_pow2 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype1 T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { 
        return  x   *  x  ;
    }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "pow2(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<class P_numtype1>
class _bz_pow3 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype1 T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { 
        return  x   *  x   *
           x  ;
    }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "pow3(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<class P_numtype1>
class _bz_pow4 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype1 T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    { 
        T_numtype t1 =  x   *  x  ;
        return  t1   *  t1  ;
    }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "pow4(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<class P_numtype1>
class _bz_pow5 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype1 T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    {
        T_numtype t1 =  x   *  x  ;
        return  t1   *  t1  
            *  t1  ;
    }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "pow5(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<class P_numtype1>
class _bz_pow6 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype1 T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    {
        T_numtype t1 =  x   *  x   
            *  x  ;
        return  t1   *  t1  ;
    }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "pow6(";
        a.prettyPrint(str,format);
        str += ")";
    }
};


 
template<class P_numtype1>
class _bz_pow7 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype1 T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    {
        T_numtype t1 =  x   *  x   
            *  x  ;
        return  t1   *  t1  
            *  x  ;
    }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "pow7(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 
template<class P_numtype1>
class _bz_pow8 : public OneOperandApplicativeTemplatesBase {
public:
    typedef P_numtype1 T_numtype1;
    typedef P_numtype1 T_numtype;

    static inline T_numtype apply(T_numtype1 x)
    {
        T_numtype t1 =  x   *  x  ;
        T_numtype t2 =  t1   *  t1  ;
        return  t2   *  t2  ;
    }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "pow8(";
        a.prettyPrint(str,format);
        str += ")";
    }
};

 






 
 










inline  int  pow2( int  x) { return x*x; } inline  int  pow3( int  x) { return x*x*x; } inline  int  pow4( int  x) {  int  t1 = x*x; return t1*t1; } inline  int  pow5( int  x) {  int  t1 = x*x; return t1*t1*x; } inline  int  pow6( int  x) {  int  t1 = x*x*x; return t1*t1; } inline  int  pow7( int  x) {  int  t1 = x*x; return t1*t1*t1*x; } inline  int  pow8( int  x) {  int  t1 = x*x, t2=t1*t1; return t2*t2; } 
inline  float  pow2( float  x) { return x*x; } inline  float  pow3( float  x) { return x*x*x; } inline  float  pow4( float  x) {  float  t1 = x*x; return t1*t1; } inline  float  pow5( float  x) {  float  t1 = x*x; return t1*t1*x; } inline  float  pow6( float  x) {  float  t1 = x*x*x; return t1*t1; } inline  float  pow7( float  x) {  float  t1 = x*x; return t1*t1*t1*x; } inline  float  pow8( float  x) {  float  t1 = x*x, t2=t1*t1; return t2*t2; } 
inline  double  pow2( double  x) { return x*x; } inline  double  pow3( double  x) { return x*x*x; } inline  double  pow4( double  x) {  double  t1 = x*x; return t1*t1; } inline  double  pow5( double  x) {  double  t1 = x*x; return t1*t1*x; } inline  double  pow6( double  x) {  double  t1 = x*x*x; return t1*t1; } inline  double  pow7( double  x) {  double  t1 = x*x; return t1*t1*t1*x; } inline  double  pow8( double  x) {  double  t1 = x*x, t2=t1*t1; return t2*t2; } 
inline  long double  pow2( long double  x) { return x*x; } inline  long double  pow3( long double  x) { return x*x*x; } inline  long double  pow4( long double  x) {  long double  t1 = x*x; return t1*t1; } inline  long double  pow5( long double  x) {  long double  t1 = x*x; return t1*t1*x; } inline  long double  pow6( long double  x) {  long double  t1 = x*x*x; return t1*t1; } inline  long double  pow7( long double  x) {  long double  t1 = x*x; return t1*t1*t1*x; } inline  long double  pow8( long double  x) {  long double  t1 = x*x, t2=t1*t1; return t2*t2; } 


inline  complex<float>  pow2( complex<float>  x) { return x*x; } inline  complex<float>  pow3( complex<float>  x) { return x*x*x; } inline  complex<float>  pow4( complex<float>  x) {  complex<float>  t1 = x*x; return t1*t1; } inline  complex<float>  pow5( complex<float>  x) {  complex<float>  t1 = x*x; return t1*t1*x; } inline  complex<float>  pow6( complex<float>  x) {  complex<float>  t1 = x*x*x; return t1*t1; } inline  complex<float>  pow7( complex<float>  x) {  complex<float>  t1 = x*x; return t1*t1*t1*x; } inline  complex<float>  pow8( complex<float>  x) {  complex<float>  t1 = x*x, t2=t1*t1; return t2*t2; } 
inline  complex<double>  pow2( complex<double>  x) { return x*x; } inline  complex<double>  pow3( complex<double>  x) { return x*x*x; } inline  complex<double>  pow4( complex<double>  x) {  complex<double>  t1 = x*x; return t1*t1; } inline  complex<double>  pow5( complex<double>  x) {  complex<double>  t1 = x*x; return t1*t1*x; } inline  complex<double>  pow6( complex<double>  x) {  complex<double>  t1 = x*x*x; return t1*t1; } inline  complex<double>  pow7( complex<double>  x) {  complex<double>  t1 = x*x; return t1*t1*t1*x; } inline  complex<double>  pow8( complex<double>  x) {  complex<double>  t1 = x*x, t2=t1*t1; return t2*t2; } 
inline  complex<long double>  pow2( complex<long double>  x) { return x*x; } inline  complex<long double>  pow3( complex<long double>  x) { return x*x*x; } inline  complex<long double>  pow4( complex<long double>  x) {  complex<long double>  t1 = x*x; return t1*t1; } inline  complex<long double>  pow5( complex<long double>  x) {  complex<long double>  t1 = x*x; return t1*t1*x; } inline  complex<long double>  pow6( complex<long double>  x) {  complex<long double>  t1 = x*x*x; return t1*t1; } inline  complex<long double>  pow7( complex<long double>  x) {  complex<long double>  t1 = x*x; return t1*t1*t1*x; } inline  complex<long double>  pow8( complex<long double>  x) {  complex<long double>  t1 = x*x, t2=t1*t1; return t2*t2; } 


} 


# 391 "../blitz/applics.h" 2




# 53 "../blitz/vecexpr.h" 2











namespace  blitz  { 

template<class P_expr1, class P_expr2, class P_op>
class _bz_VecExprOp {

public:
    typedef P_expr1 T_expr1;
    typedef P_expr2 T_expr2;
    typedef typename  T_expr1::T_numtype T_numtype1;
    typedef typename  T_expr2::T_numtype T_numtype2;
    typedef typename  promote_trait< T_numtype1 ,  T_numtype2 >::T_promote  T_numtype;
    typedef P_op    T_op;


    _bz_VecExprOp(T_expr1 a, T_expr2 b)
        : iter1_(a), iter2_(b)
    { }







    _bz_VecExprOp(const _bz_VecExprOp<P_expr1, P_expr2, P_op>& x)
        : iter1_(x.iter1_), iter2_(x.iter2_)
    { }


    T_numtype operator[](int i) const
    { return T_op::apply(iter1_[i], iter2_[i]); }

    T_numtype operator()(int i) const
    { return T_op::apply(iter1_(i), iter2_(i)); }

    int length(int recommendedLength) const
    { 
         ;

        return iter1_.length(recommendedLength); 
    }

    enum { 
           _bz_staticLengthCount = 
      (int) P_expr1::_bz_staticLengthCount   
         + (int) P_expr2::_bz_staticLengthCount  ,

           _bz_dynamicLengthCount = 
      (int) P_expr1::_bz_dynamicLengthCount   
        + (int) P_expr2::_bz_dynamicLengthCount  ,

           _bz_staticLength = ((int) P_expr1::_bz_staticLength   > (int) P_expr2::_bz_staticLength  ) ? (int) P_expr1::_bz_staticLength   : (int) P_expr2::_bz_staticLength  

 
    };

    int _bz_suggestLength() const
    {
        int length1 = iter1_._bz_suggestLength();
        if (length1 != 0)
            return length1;
        return iter2_._bz_suggestLength();
    }

    bool   _bz_hasFastAccess() const
    { return iter1_._bz_hasFastAccess() && iter2_._bz_hasFastAccess(); }

    T_numtype _bz_fastAccess(int i) const
    { 
        return T_op::apply(iter1_._bz_fastAccess(i),
            iter2_._bz_fastAccess(i)); 
    }
    
private:
    _bz_VecExprOp();

    T_expr1 iter1_;
    T_expr2 iter2_;
};

template<class P_expr, class P_unaryOp>
class _bz_VecExprUnaryOp {

public:
    typedef P_expr T_expr;
    typedef P_unaryOp T_unaryOp;
    typedef typename  T_unaryOp::T_numtype T_numtype;


    _bz_VecExprUnaryOp(T_expr iter)
        : iter_(iter)
    { }







    _bz_VecExprUnaryOp(const _bz_VecExprUnaryOp<P_expr, P_unaryOp>& x)
        : iter_(x.iter_)
    { }


    T_numtype operator[](int i) const
    { return T_unaryOp::apply(iter_[i]); }

    T_numtype operator()(int i) const
    { return T_unaryOp::apply(iter_(i)); }

    int length(int recommendedLength) const
    { return iter_.length(recommendedLength); }

    enum { _bz_staticLengthCount = (int) P_expr::_bz_staticLengthCount  ,
           _bz_dynamicLengthCount = (int) P_expr::_bz_dynamicLengthCount  ,
           _bz_staticLength = (int) P_expr::_bz_staticLength   };

    int _bz_suggestLength() const
    { return iter_._bz_suggestLength(); }

    bool  _bz_hasFastAccess() const
    { return iter_._bz_hasFastAccess(); }

    T_numtype _bz_fastAccess(int i) const
    { return T_unaryOp::apply(iter_._bz_fastAccess(i)); }

private:
    _bz_VecExprUnaryOp() { }

    T_expr iter_;    
};

template<class P_numtype>
class _bz_VecExprConstant {
public:
    typedef P_numtype T_numtype;

    _bz_VecExprConstant(P_numtype value)
        : value_( value  )
    { 
    }


    _bz_VecExprConstant(const _bz_VecExprConstant<P_numtype>& x)
        : value_(x.value_)
    { }


    T_numtype operator[](int) const
    { return value_; }

    T_numtype operator()(int) const
    { return value_; }

    int length(int recommendedLength) const
    { return recommendedLength; }

    enum { _bz_staticLengthCount = 0,
           _bz_dynamicLengthCount = 0,
           _bz_staticLength = 0
    };

    int _bz_suggestLength() const
    { return 0; }

    bool  _bz_hasFastAccess() const
    { return 1; }

    T_numtype _bz_fastAccess(int) const
    { return value_; }

private:

    _bz_VecExprConstant() { }

    T_numtype value_;
};

 

template<class P_expr>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr>, 
    _bz_negate< typename  P_expr::T_numtype> > >
operator-(_bz_VecExpr<P_expr> a)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr>,
        _bz_negate< typename  P_expr::T_numtype> > T_expr;
    return _bz_VecExpr<T_expr>(T_expr(a));
}

template<class P_numtype>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype>,
    _bz_negate<P_numtype> > >
operator-(const Vector<P_numtype>& a)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype>,
        _bz_negate<P_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(a.begin()));
}

inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range, _bz_negate<Range::T_numtype> > >
operator-(Range r)
{
    typedef _bz_VecExprUnaryOp<Range, _bz_negate<Range::T_numtype> > T_expr;
    
    return _bz_VecExpr<T_expr>(T_expr(r));
}


 

} 





# 1 "../blitz/vecbops.cc" 1
 




















 

 
 








namespace  blitz  { 

 



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_Add<P_numtype1, P_numtype2 > > >
operator+(const Vector<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Add<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Add<P_numtype1, typename  P_expr2::T_numtype > > >
operator+(const Vector<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Add<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Add<P_numtype1, P_numtype2 > > >
operator+(const Vector<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Add<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range,
      _bz_Add<P_numtype1, int > > >
operator+(const Vector<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range, 
      _bz_Add<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Add<P_numtype1, P_numtype2 > > >
operator+(const Vector<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Add<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_Add<P_numtype1, int > > >
operator+(const Vector<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_Add<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>,
      _bz_Add<P_numtype1, float > > >
operator+(const Vector<P_numtype1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>, 
      _bz_Add<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>,
      _bz_Add<P_numtype1, double > > >
operator+(const Vector<P_numtype1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>, 
      _bz_Add<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>,
      _bz_Add<P_numtype1, long double > > >
operator+(const Vector<P_numtype1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Add<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Add<P_numtype1, complex<T2>  > > >
operator+(const Vector<P_numtype1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Add<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>,
      _bz_Add< typename  P_expr1::T_numtype, P_numtype2 > > >
operator+(_bz_VecExpr<P_expr1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Add< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Add< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype > > >
operator+(_bz_VecExpr<P_expr1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Add< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Add< typename  P_expr1::T_numtype, P_numtype2 > > >
operator+(_bz_VecExpr<P_expr1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Add< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range,
      _bz_Add< typename  P_expr1::T_numtype, int > > >
operator+(_bz_VecExpr<P_expr1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range, 
      _bz_Add< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Add< typename  P_expr1::T_numtype, P_numtype2 > > >
operator+(_bz_VecExpr<P_expr1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Add< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>,
      _bz_Add< typename  P_expr1::T_numtype, int > > >
operator+(_bz_VecExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>, 
      _bz_Add< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<float>,
      _bz_Add< typename  P_expr1::T_numtype, float > > >
operator+(_bz_VecExpr<P_expr1> d1, 
      float d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<float>, 
      _bz_Add< typename  P_expr1::T_numtype, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<double>,
      _bz_Add< typename  P_expr1::T_numtype, double > > >
operator+(_bz_VecExpr<P_expr1> d1, 
      double d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<double>, 
      _bz_Add< typename  P_expr1::T_numtype, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<long double>,
      _bz_Add< typename  P_expr1::T_numtype, long double > > >
operator+(_bz_VecExpr<P_expr1> d1, 
      long double d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Add< typename  P_expr1::T_numtype, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_expr1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Add< typename  P_expr1::T_numtype, complex<T2>  > > >
operator+(_bz_VecExpr<P_expr1> d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Add< typename  P_expr1::T_numtype, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_Add<P_numtype1, P_numtype2 > > >
operator+(const VectorPick<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Add<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Add<P_numtype1, typename  P_expr2::T_numtype > > >
operator+(const VectorPick<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Add<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Add<P_numtype1, P_numtype2 > > >
operator+(const VectorPick<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Add<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range,
      _bz_Add<P_numtype1, int > > >
operator+(const VectorPick<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range, 
      _bz_Add<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Add<P_numtype1, P_numtype2 > > >
operator+(const VectorPick<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Add<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_Add<P_numtype1, int > > >
operator+(const VectorPick<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_Add<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>,
      _bz_Add<P_numtype1, float > > >
operator+(const VectorPick<P_numtype1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>, 
      _bz_Add<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>,
      _bz_Add<P_numtype1, double > > >
operator+(const VectorPick<P_numtype1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>, 
      _bz_Add<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>,
      _bz_Add<P_numtype1, long double > > >
operator+(const VectorPick<P_numtype1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Add<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Add<P_numtype1, complex<T2>  > > >
operator+(const VectorPick<P_numtype1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Add<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>,
      _bz_Add<int, P_numtype2 > > >
operator+(Range d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>, 
      _bz_Add<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>,
      _bz_Add<int, typename  P_expr2::T_numtype > > >
operator+(Range d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>, 
      _bz_Add<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>,
      _bz_Add<int, P_numtype2 > > >
operator+(Range d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Add<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      Range,
      _bz_Add<int, int > > >
operator+(Range d1, 
      Range d2)
{
    typedef _bz_VecExprOp<Range, 
      Range, 
      _bz_Add<int, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Add<int, P_numtype2 > > >
operator+(Range d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Add<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<float>,
      _bz_Add<int, float > > >
operator+(Range d1, 
      float d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<float>, 
      _bz_Add<int, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<float>(d2)));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<double>,
      _bz_Add<int, double > > >
operator+(Range d1, 
      double d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<double>, 
      _bz_Add<int, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<double>(d2)));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<long double>,
      _bz_Add<int, long double > > >
operator+(Range d1, 
      long double d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<long double>, 
      _bz_Add<int, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class T2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Add<int, complex<T2>  > > >
operator+(Range d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Add<int, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>,
      _bz_Add<P_numtype1, P_numtype2 > > >
operator+(const TinyVector<P_numtype1, N_length1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Add<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Add<P_numtype1, typename  P_expr2::T_numtype > > >
operator+(const TinyVector<P_numtype1, N_length1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Add<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Add<P_numtype1, P_numtype2 > > >
operator+(const TinyVector<P_numtype1, N_length1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Add<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range,
      _bz_Add<P_numtype1, int > > >
operator+(const TinyVector<P_numtype1, N_length1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range, 
      _bz_Add<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Add<P_numtype1, P_numtype2 > > >
operator+(const TinyVector<P_numtype1, N_length1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Add<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>,
      _bz_Add<P_numtype1, int > > >
operator+(const TinyVector<P_numtype1, N_length1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>, 
      _bz_Add<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<float>,
      _bz_Add<P_numtype1, float > > >
operator+(const TinyVector<P_numtype1, N_length1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<float>, 
      _bz_Add<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<double>,
      _bz_Add<P_numtype1, double > > >
operator+(const TinyVector<P_numtype1, N_length1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<double>, 
      _bz_Add<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<long double>,
      _bz_Add<P_numtype1, long double > > >
operator+(const TinyVector<P_numtype1, N_length1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Add<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, int N_length1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Add<P_numtype1, complex<T2>  > > >
operator+(const TinyVector<P_numtype1, N_length1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Add<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>,
      _bz_Add<int, P_numtype2 > > >
operator+(int d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>, 
      _bz_Add<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>,
      _bz_Add<int, typename  P_expr2::T_numtype > > >
operator+(int d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Add<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Add<int, P_numtype2 > > >
operator+(int d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Add<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Add<int, P_numtype2 > > >
operator+(int d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Add<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorIterConst<P_numtype2>,
      _bz_Add<float, P_numtype2 > > >
operator+(float d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorIterConst<P_numtype2>, 
      _bz_Add<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      _bz_VecExpr<P_expr2>,
      _bz_Add<float, typename  P_expr2::T_numtype > > >
operator+(float d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Add<float, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Add<float, P_numtype2 > > >
operator+(float d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Add<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      Range,
      _bz_Add<float, int > > >
operator+(float d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      Range, 
      _bz_Add<float, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Add<float, P_numtype2 > > >
operator+(float d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Add<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorIterConst<P_numtype2>,
      _bz_Add<double, P_numtype2 > > >
operator+(double d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorIterConst<P_numtype2>, 
      _bz_Add<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      _bz_VecExpr<P_expr2>,
      _bz_Add<double, typename  P_expr2::T_numtype > > >
operator+(double d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Add<double, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Add<double, P_numtype2 > > >
operator+(double d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Add<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      Range,
      _bz_Add<double, int > > >
operator+(double d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      Range, 
      _bz_Add<double, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Add<double, P_numtype2 > > >
operator+(double d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Add<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorIterConst<P_numtype2>,
      _bz_Add<long double, P_numtype2 > > >
operator+(long double d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorIterConst<P_numtype2>, 
      _bz_Add<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      _bz_VecExpr<P_expr2>,
      _bz_Add<long double, typename  P_expr2::T_numtype > > >
operator+(long double d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Add<long double, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Add<long double, P_numtype2 > > >
operator+(long double d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Add<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      Range,
      _bz_Add<long double, int > > >
operator+(long double d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      Range, 
      _bz_Add<long double, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Add<long double, P_numtype2 > > >
operator+(long double d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Add<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}


 
template<class T1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorIterConst<P_numtype2>,
      _bz_Add<complex<T1> , P_numtype2 > > >
operator+(complex<T1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorIterConst<P_numtype2>, 
      _bz_Add<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}




 
template<class T1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      _bz_VecExpr<P_expr2>,
      _bz_Add<complex<T1> , typename  P_expr2::T_numtype > > >
operator+(complex<T1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      _bz_VecExpr<P_expr2>, 
      _bz_Add<complex<T1> , typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2));
}




 
template<class T1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorPickIterConst<P_numtype2>,
      _bz_Add<complex<T1> , P_numtype2 > > >
operator+(complex<T1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorPickIterConst<P_numtype2>, 
      _bz_Add<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}




 
template<class T1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      Range,
      _bz_Add<complex<T1> , int > > >
operator+(complex<T1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      Range, 
      _bz_Add<complex<T1> , int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2));
}




 
template<class T1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Add<complex<T1> , P_numtype2 > > >
operator+(complex<T1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Add<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}


 



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_Subtract<P_numtype1, P_numtype2 > > >
operator-(const Vector<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Subtract<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Subtract<P_numtype1, typename  P_expr2::T_numtype > > >
operator-(const Vector<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Subtract<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Subtract<P_numtype1, P_numtype2 > > >
operator-(const Vector<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Subtract<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range,
      _bz_Subtract<P_numtype1, int > > >
operator-(const Vector<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range, 
      _bz_Subtract<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Subtract<P_numtype1, P_numtype2 > > >
operator-(const Vector<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Subtract<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_Subtract<P_numtype1, int > > >
operator-(const Vector<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_Subtract<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>,
      _bz_Subtract<P_numtype1, float > > >
operator-(const Vector<P_numtype1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>, 
      _bz_Subtract<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>,
      _bz_Subtract<P_numtype1, double > > >
operator-(const Vector<P_numtype1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>, 
      _bz_Subtract<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>,
      _bz_Subtract<P_numtype1, long double > > >
operator-(const Vector<P_numtype1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Subtract<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Subtract<P_numtype1, complex<T2>  > > >
operator-(const Vector<P_numtype1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Subtract<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>,
      _bz_Subtract< typename  P_expr1::T_numtype, P_numtype2 > > >
operator-(_bz_VecExpr<P_expr1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Subtract< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Subtract< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype > > >
operator-(_bz_VecExpr<P_expr1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Subtract< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Subtract< typename  P_expr1::T_numtype, P_numtype2 > > >
operator-(_bz_VecExpr<P_expr1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Subtract< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range,
      _bz_Subtract< typename  P_expr1::T_numtype, int > > >
operator-(_bz_VecExpr<P_expr1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range, 
      _bz_Subtract< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Subtract< typename  P_expr1::T_numtype, P_numtype2 > > >
operator-(_bz_VecExpr<P_expr1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Subtract< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>,
      _bz_Subtract< typename  P_expr1::T_numtype, int > > >
operator-(_bz_VecExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>, 
      _bz_Subtract< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<float>,
      _bz_Subtract< typename  P_expr1::T_numtype, float > > >
operator-(_bz_VecExpr<P_expr1> d1, 
      float d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<float>, 
      _bz_Subtract< typename  P_expr1::T_numtype, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<double>,
      _bz_Subtract< typename  P_expr1::T_numtype, double > > >
operator-(_bz_VecExpr<P_expr1> d1, 
      double d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<double>, 
      _bz_Subtract< typename  P_expr1::T_numtype, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<long double>,
      _bz_Subtract< typename  P_expr1::T_numtype, long double > > >
operator-(_bz_VecExpr<P_expr1> d1, 
      long double d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Subtract< typename  P_expr1::T_numtype, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_expr1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Subtract< typename  P_expr1::T_numtype, complex<T2>  > > >
operator-(_bz_VecExpr<P_expr1> d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Subtract< typename  P_expr1::T_numtype, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_Subtract<P_numtype1, P_numtype2 > > >
operator-(const VectorPick<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Subtract<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Subtract<P_numtype1, typename  P_expr2::T_numtype > > >
operator-(const VectorPick<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Subtract<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Subtract<P_numtype1, P_numtype2 > > >
operator-(const VectorPick<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Subtract<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range,
      _bz_Subtract<P_numtype1, int > > >
operator-(const VectorPick<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range, 
      _bz_Subtract<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Subtract<P_numtype1, P_numtype2 > > >
operator-(const VectorPick<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Subtract<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_Subtract<P_numtype1, int > > >
operator-(const VectorPick<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_Subtract<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>,
      _bz_Subtract<P_numtype1, float > > >
operator-(const VectorPick<P_numtype1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>, 
      _bz_Subtract<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>,
      _bz_Subtract<P_numtype1, double > > >
operator-(const VectorPick<P_numtype1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>, 
      _bz_Subtract<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>,
      _bz_Subtract<P_numtype1, long double > > >
operator-(const VectorPick<P_numtype1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Subtract<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Subtract<P_numtype1, complex<T2>  > > >
operator-(const VectorPick<P_numtype1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Subtract<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>,
      _bz_Subtract<int, P_numtype2 > > >
operator-(Range d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>, 
      _bz_Subtract<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>,
      _bz_Subtract<int, typename  P_expr2::T_numtype > > >
operator-(Range d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>, 
      _bz_Subtract<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>,
      _bz_Subtract<int, P_numtype2 > > >
operator-(Range d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Subtract<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      Range,
      _bz_Subtract<int, int > > >
operator-(Range d1, 
      Range d2)
{
    typedef _bz_VecExprOp<Range, 
      Range, 
      _bz_Subtract<int, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Subtract<int, P_numtype2 > > >
operator-(Range d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Subtract<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<float>,
      _bz_Subtract<int, float > > >
operator-(Range d1, 
      float d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<float>, 
      _bz_Subtract<int, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<float>(d2)));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<double>,
      _bz_Subtract<int, double > > >
operator-(Range d1, 
      double d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<double>, 
      _bz_Subtract<int, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<double>(d2)));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<long double>,
      _bz_Subtract<int, long double > > >
operator-(Range d1, 
      long double d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<long double>, 
      _bz_Subtract<int, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class T2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Subtract<int, complex<T2>  > > >
operator-(Range d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Subtract<int, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>,
      _bz_Subtract<P_numtype1, P_numtype2 > > >
operator-(const TinyVector<P_numtype1, N_length1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Subtract<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Subtract<P_numtype1, typename  P_expr2::T_numtype > > >
operator-(const TinyVector<P_numtype1, N_length1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Subtract<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Subtract<P_numtype1, P_numtype2 > > >
operator-(const TinyVector<P_numtype1, N_length1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Subtract<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range,
      _bz_Subtract<P_numtype1, int > > >
operator-(const TinyVector<P_numtype1, N_length1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range, 
      _bz_Subtract<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Subtract<P_numtype1, P_numtype2 > > >
operator-(const TinyVector<P_numtype1, N_length1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Subtract<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>,
      _bz_Subtract<P_numtype1, int > > >
operator-(const TinyVector<P_numtype1, N_length1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>, 
      _bz_Subtract<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<float>,
      _bz_Subtract<P_numtype1, float > > >
operator-(const TinyVector<P_numtype1, N_length1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<float>, 
      _bz_Subtract<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<double>,
      _bz_Subtract<P_numtype1, double > > >
operator-(const TinyVector<P_numtype1, N_length1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<double>, 
      _bz_Subtract<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<long double>,
      _bz_Subtract<P_numtype1, long double > > >
operator-(const TinyVector<P_numtype1, N_length1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Subtract<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, int N_length1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Subtract<P_numtype1, complex<T2>  > > >
operator-(const TinyVector<P_numtype1, N_length1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Subtract<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>,
      _bz_Subtract<int, P_numtype2 > > >
operator-(int d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>, 
      _bz_Subtract<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>,
      _bz_Subtract<int, typename  P_expr2::T_numtype > > >
operator-(int d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Subtract<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Subtract<int, P_numtype2 > > >
operator-(int d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Subtract<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Subtract<int, P_numtype2 > > >
operator-(int d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Subtract<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorIterConst<P_numtype2>,
      _bz_Subtract<float, P_numtype2 > > >
operator-(float d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorIterConst<P_numtype2>, 
      _bz_Subtract<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      _bz_VecExpr<P_expr2>,
      _bz_Subtract<float, typename  P_expr2::T_numtype > > >
operator-(float d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Subtract<float, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Subtract<float, P_numtype2 > > >
operator-(float d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Subtract<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      Range,
      _bz_Subtract<float, int > > >
operator-(float d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      Range, 
      _bz_Subtract<float, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Subtract<float, P_numtype2 > > >
operator-(float d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Subtract<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorIterConst<P_numtype2>,
      _bz_Subtract<double, P_numtype2 > > >
operator-(double d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorIterConst<P_numtype2>, 
      _bz_Subtract<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      _bz_VecExpr<P_expr2>,
      _bz_Subtract<double, typename  P_expr2::T_numtype > > >
operator-(double d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Subtract<double, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Subtract<double, P_numtype2 > > >
operator-(double d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Subtract<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      Range,
      _bz_Subtract<double, int > > >
operator-(double d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      Range, 
      _bz_Subtract<double, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Subtract<double, P_numtype2 > > >
operator-(double d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Subtract<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorIterConst<P_numtype2>,
      _bz_Subtract<long double, P_numtype2 > > >
operator-(long double d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorIterConst<P_numtype2>, 
      _bz_Subtract<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      _bz_VecExpr<P_expr2>,
      _bz_Subtract<long double, typename  P_expr2::T_numtype > > >
operator-(long double d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Subtract<long double, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Subtract<long double, P_numtype2 > > >
operator-(long double d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Subtract<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      Range,
      _bz_Subtract<long double, int > > >
operator-(long double d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      Range, 
      _bz_Subtract<long double, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Subtract<long double, P_numtype2 > > >
operator-(long double d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Subtract<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}


 
template<class T1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorIterConst<P_numtype2>,
      _bz_Subtract<complex<T1> , P_numtype2 > > >
operator-(complex<T1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorIterConst<P_numtype2>, 
      _bz_Subtract<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}




 
template<class T1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      _bz_VecExpr<P_expr2>,
      _bz_Subtract<complex<T1> , typename  P_expr2::T_numtype > > >
operator-(complex<T1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      _bz_VecExpr<P_expr2>, 
      _bz_Subtract<complex<T1> , typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2));
}




 
template<class T1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorPickIterConst<P_numtype2>,
      _bz_Subtract<complex<T1> , P_numtype2 > > >
operator-(complex<T1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorPickIterConst<P_numtype2>, 
      _bz_Subtract<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}




 
template<class T1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      Range,
      _bz_Subtract<complex<T1> , int > > >
operator-(complex<T1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      Range, 
      _bz_Subtract<complex<T1> , int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2));
}




 
template<class T1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Subtract<complex<T1> , P_numtype2 > > >
operator-(complex<T1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Subtract<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}


 



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_Multiply<P_numtype1, P_numtype2 > > >
operator*(const Vector<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Multiply<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Multiply<P_numtype1, typename  P_expr2::T_numtype > > >
operator*(const Vector<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Multiply<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Multiply<P_numtype1, P_numtype2 > > >
operator*(const Vector<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Multiply<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range,
      _bz_Multiply<P_numtype1, int > > >
operator*(const Vector<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range, 
      _bz_Multiply<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Multiply<P_numtype1, P_numtype2 > > >
operator*(const Vector<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Multiply<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_Multiply<P_numtype1, int > > >
operator*(const Vector<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_Multiply<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>,
      _bz_Multiply<P_numtype1, float > > >
operator*(const Vector<P_numtype1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>, 
      _bz_Multiply<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>,
      _bz_Multiply<P_numtype1, double > > >
operator*(const Vector<P_numtype1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>, 
      _bz_Multiply<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>,
      _bz_Multiply<P_numtype1, long double > > >
operator*(const Vector<P_numtype1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Multiply<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Multiply<P_numtype1, complex<T2>  > > >
operator*(const Vector<P_numtype1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Multiply<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>,
      _bz_Multiply< typename  P_expr1::T_numtype, P_numtype2 > > >
operator*(_bz_VecExpr<P_expr1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Multiply< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Multiply< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype > > >
operator*(_bz_VecExpr<P_expr1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Multiply< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Multiply< typename  P_expr1::T_numtype, P_numtype2 > > >
operator*(_bz_VecExpr<P_expr1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Multiply< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range,
      _bz_Multiply< typename  P_expr1::T_numtype, int > > >
operator*(_bz_VecExpr<P_expr1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range, 
      _bz_Multiply< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Multiply< typename  P_expr1::T_numtype, P_numtype2 > > >
operator*(_bz_VecExpr<P_expr1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Multiply< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>,
      _bz_Multiply< typename  P_expr1::T_numtype, int > > >
operator*(_bz_VecExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>, 
      _bz_Multiply< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<float>,
      _bz_Multiply< typename  P_expr1::T_numtype, float > > >
operator*(_bz_VecExpr<P_expr1> d1, 
      float d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<float>, 
      _bz_Multiply< typename  P_expr1::T_numtype, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<double>,
      _bz_Multiply< typename  P_expr1::T_numtype, double > > >
operator*(_bz_VecExpr<P_expr1> d1, 
      double d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<double>, 
      _bz_Multiply< typename  P_expr1::T_numtype, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<long double>,
      _bz_Multiply< typename  P_expr1::T_numtype, long double > > >
operator*(_bz_VecExpr<P_expr1> d1, 
      long double d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Multiply< typename  P_expr1::T_numtype, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_expr1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Multiply< typename  P_expr1::T_numtype, complex<T2>  > > >
operator*(_bz_VecExpr<P_expr1> d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Multiply< typename  P_expr1::T_numtype, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_Multiply<P_numtype1, P_numtype2 > > >
operator*(const VectorPick<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Multiply<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Multiply<P_numtype1, typename  P_expr2::T_numtype > > >
operator*(const VectorPick<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Multiply<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Multiply<P_numtype1, P_numtype2 > > >
operator*(const VectorPick<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Multiply<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range,
      _bz_Multiply<P_numtype1, int > > >
operator*(const VectorPick<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range, 
      _bz_Multiply<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Multiply<P_numtype1, P_numtype2 > > >
operator*(const VectorPick<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Multiply<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_Multiply<P_numtype1, int > > >
operator*(const VectorPick<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_Multiply<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>,
      _bz_Multiply<P_numtype1, float > > >
operator*(const VectorPick<P_numtype1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>, 
      _bz_Multiply<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>,
      _bz_Multiply<P_numtype1, double > > >
operator*(const VectorPick<P_numtype1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>, 
      _bz_Multiply<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>,
      _bz_Multiply<P_numtype1, long double > > >
operator*(const VectorPick<P_numtype1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Multiply<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Multiply<P_numtype1, complex<T2>  > > >
operator*(const VectorPick<P_numtype1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Multiply<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>,
      _bz_Multiply<int, P_numtype2 > > >
operator*(Range d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>, 
      _bz_Multiply<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>,
      _bz_Multiply<int, typename  P_expr2::T_numtype > > >
operator*(Range d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>, 
      _bz_Multiply<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>,
      _bz_Multiply<int, P_numtype2 > > >
operator*(Range d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Multiply<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      Range,
      _bz_Multiply<int, int > > >
operator*(Range d1, 
      Range d2)
{
    typedef _bz_VecExprOp<Range, 
      Range, 
      _bz_Multiply<int, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Multiply<int, P_numtype2 > > >
operator*(Range d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Multiply<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<float>,
      _bz_Multiply<int, float > > >
operator*(Range d1, 
      float d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<float>, 
      _bz_Multiply<int, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<float>(d2)));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<double>,
      _bz_Multiply<int, double > > >
operator*(Range d1, 
      double d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<double>, 
      _bz_Multiply<int, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<double>(d2)));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<long double>,
      _bz_Multiply<int, long double > > >
operator*(Range d1, 
      long double d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<long double>, 
      _bz_Multiply<int, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class T2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Multiply<int, complex<T2>  > > >
operator*(Range d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Multiply<int, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>,
      _bz_Multiply<P_numtype1, P_numtype2 > > >
operator*(const TinyVector<P_numtype1, N_length1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Multiply<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Multiply<P_numtype1, typename  P_expr2::T_numtype > > >
operator*(const TinyVector<P_numtype1, N_length1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Multiply<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Multiply<P_numtype1, P_numtype2 > > >
operator*(const TinyVector<P_numtype1, N_length1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Multiply<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range,
      _bz_Multiply<P_numtype1, int > > >
operator*(const TinyVector<P_numtype1, N_length1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range, 
      _bz_Multiply<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Multiply<P_numtype1, P_numtype2 > > >
operator*(const TinyVector<P_numtype1, N_length1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Multiply<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>,
      _bz_Multiply<P_numtype1, int > > >
operator*(const TinyVector<P_numtype1, N_length1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>, 
      _bz_Multiply<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<float>,
      _bz_Multiply<P_numtype1, float > > >
operator*(const TinyVector<P_numtype1, N_length1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<float>, 
      _bz_Multiply<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<double>,
      _bz_Multiply<P_numtype1, double > > >
operator*(const TinyVector<P_numtype1, N_length1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<double>, 
      _bz_Multiply<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<long double>,
      _bz_Multiply<P_numtype1, long double > > >
operator*(const TinyVector<P_numtype1, N_length1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Multiply<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, int N_length1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Multiply<P_numtype1, complex<T2>  > > >
operator*(const TinyVector<P_numtype1, N_length1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Multiply<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>,
      _bz_Multiply<int, P_numtype2 > > >
operator*(int d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>, 
      _bz_Multiply<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>,
      _bz_Multiply<int, typename  P_expr2::T_numtype > > >
operator*(int d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Multiply<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Multiply<int, P_numtype2 > > >
operator*(int d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Multiply<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Multiply<int, P_numtype2 > > >
operator*(int d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Multiply<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorIterConst<P_numtype2>,
      _bz_Multiply<float, P_numtype2 > > >
operator*(float d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorIterConst<P_numtype2>, 
      _bz_Multiply<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      _bz_VecExpr<P_expr2>,
      _bz_Multiply<float, typename  P_expr2::T_numtype > > >
operator*(float d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Multiply<float, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Multiply<float, P_numtype2 > > >
operator*(float d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Multiply<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      Range,
      _bz_Multiply<float, int > > >
operator*(float d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      Range, 
      _bz_Multiply<float, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Multiply<float, P_numtype2 > > >
operator*(float d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Multiply<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorIterConst<P_numtype2>,
      _bz_Multiply<double, P_numtype2 > > >
operator*(double d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorIterConst<P_numtype2>, 
      _bz_Multiply<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      _bz_VecExpr<P_expr2>,
      _bz_Multiply<double, typename  P_expr2::T_numtype > > >
operator*(double d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Multiply<double, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Multiply<double, P_numtype2 > > >
operator*(double d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Multiply<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      Range,
      _bz_Multiply<double, int > > >
operator*(double d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      Range, 
      _bz_Multiply<double, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Multiply<double, P_numtype2 > > >
operator*(double d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Multiply<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorIterConst<P_numtype2>,
      _bz_Multiply<long double, P_numtype2 > > >
operator*(long double d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorIterConst<P_numtype2>, 
      _bz_Multiply<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      _bz_VecExpr<P_expr2>,
      _bz_Multiply<long double, typename  P_expr2::T_numtype > > >
operator*(long double d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Multiply<long double, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Multiply<long double, P_numtype2 > > >
operator*(long double d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Multiply<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      Range,
      _bz_Multiply<long double, int > > >
operator*(long double d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      Range, 
      _bz_Multiply<long double, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Multiply<long double, P_numtype2 > > >
operator*(long double d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Multiply<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}


 
template<class T1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorIterConst<P_numtype2>,
      _bz_Multiply<complex<T1> , P_numtype2 > > >
operator*(complex<T1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorIterConst<P_numtype2>, 
      _bz_Multiply<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}




 
template<class T1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      _bz_VecExpr<P_expr2>,
      _bz_Multiply<complex<T1> , typename  P_expr2::T_numtype > > >
operator*(complex<T1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      _bz_VecExpr<P_expr2>, 
      _bz_Multiply<complex<T1> , typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2));
}




 
template<class T1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorPickIterConst<P_numtype2>,
      _bz_Multiply<complex<T1> , P_numtype2 > > >
operator*(complex<T1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorPickIterConst<P_numtype2>, 
      _bz_Multiply<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}




 
template<class T1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      Range,
      _bz_Multiply<complex<T1> , int > > >
operator*(complex<T1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      Range, 
      _bz_Multiply<complex<T1> , int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2));
}




 
template<class T1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Multiply<complex<T1> , P_numtype2 > > >
operator*(complex<T1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Multiply<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}


 



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_Divide<P_numtype1, P_numtype2 > > >
operator/(const Vector<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Divide<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Divide<P_numtype1, typename  P_expr2::T_numtype > > >
operator/(const Vector<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Divide<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Divide<P_numtype1, P_numtype2 > > >
operator/(const Vector<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Divide<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range,
      _bz_Divide<P_numtype1, int > > >
operator/(const Vector<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range, 
      _bz_Divide<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Divide<P_numtype1, P_numtype2 > > >
operator/(const Vector<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Divide<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_Divide<P_numtype1, int > > >
operator/(const Vector<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_Divide<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>,
      _bz_Divide<P_numtype1, float > > >
operator/(const Vector<P_numtype1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>, 
      _bz_Divide<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>,
      _bz_Divide<P_numtype1, double > > >
operator/(const Vector<P_numtype1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>, 
      _bz_Divide<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>,
      _bz_Divide<P_numtype1, long double > > >
operator/(const Vector<P_numtype1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Divide<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Divide<P_numtype1, complex<T2>  > > >
operator/(const Vector<P_numtype1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Divide<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>,
      _bz_Divide< typename  P_expr1::T_numtype, P_numtype2 > > >
operator/(_bz_VecExpr<P_expr1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Divide< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Divide< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype > > >
operator/(_bz_VecExpr<P_expr1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Divide< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Divide< typename  P_expr1::T_numtype, P_numtype2 > > >
operator/(_bz_VecExpr<P_expr1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Divide< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range,
      _bz_Divide< typename  P_expr1::T_numtype, int > > >
operator/(_bz_VecExpr<P_expr1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range, 
      _bz_Divide< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Divide< typename  P_expr1::T_numtype, P_numtype2 > > >
operator/(_bz_VecExpr<P_expr1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Divide< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>,
      _bz_Divide< typename  P_expr1::T_numtype, int > > >
operator/(_bz_VecExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>, 
      _bz_Divide< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<float>,
      _bz_Divide< typename  P_expr1::T_numtype, float > > >
operator/(_bz_VecExpr<P_expr1> d1, 
      float d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<float>, 
      _bz_Divide< typename  P_expr1::T_numtype, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<double>,
      _bz_Divide< typename  P_expr1::T_numtype, double > > >
operator/(_bz_VecExpr<P_expr1> d1, 
      double d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<double>, 
      _bz_Divide< typename  P_expr1::T_numtype, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<long double>,
      _bz_Divide< typename  P_expr1::T_numtype, long double > > >
operator/(_bz_VecExpr<P_expr1> d1, 
      long double d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Divide< typename  P_expr1::T_numtype, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_expr1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Divide< typename  P_expr1::T_numtype, complex<T2>  > > >
operator/(_bz_VecExpr<P_expr1> d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Divide< typename  P_expr1::T_numtype, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_Divide<P_numtype1, P_numtype2 > > >
operator/(const VectorPick<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Divide<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Divide<P_numtype1, typename  P_expr2::T_numtype > > >
operator/(const VectorPick<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Divide<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Divide<P_numtype1, P_numtype2 > > >
operator/(const VectorPick<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Divide<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range,
      _bz_Divide<P_numtype1, int > > >
operator/(const VectorPick<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range, 
      _bz_Divide<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Divide<P_numtype1, P_numtype2 > > >
operator/(const VectorPick<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Divide<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_Divide<P_numtype1, int > > >
operator/(const VectorPick<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_Divide<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>,
      _bz_Divide<P_numtype1, float > > >
operator/(const VectorPick<P_numtype1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>, 
      _bz_Divide<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>,
      _bz_Divide<P_numtype1, double > > >
operator/(const VectorPick<P_numtype1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>, 
      _bz_Divide<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>,
      _bz_Divide<P_numtype1, long double > > >
operator/(const VectorPick<P_numtype1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Divide<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Divide<P_numtype1, complex<T2>  > > >
operator/(const VectorPick<P_numtype1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Divide<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>,
      _bz_Divide<int, P_numtype2 > > >
operator/(Range d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>, 
      _bz_Divide<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>,
      _bz_Divide<int, typename  P_expr2::T_numtype > > >
operator/(Range d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>, 
      _bz_Divide<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>,
      _bz_Divide<int, P_numtype2 > > >
operator/(Range d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Divide<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      Range,
      _bz_Divide<int, int > > >
operator/(Range d1, 
      Range d2)
{
    typedef _bz_VecExprOp<Range, 
      Range, 
      _bz_Divide<int, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Divide<int, P_numtype2 > > >
operator/(Range d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Divide<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<float>,
      _bz_Divide<int, float > > >
operator/(Range d1, 
      float d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<float>, 
      _bz_Divide<int, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<float>(d2)));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<double>,
      _bz_Divide<int, double > > >
operator/(Range d1, 
      double d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<double>, 
      _bz_Divide<int, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<double>(d2)));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<long double>,
      _bz_Divide<int, long double > > >
operator/(Range d1, 
      long double d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<long double>, 
      _bz_Divide<int, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class T2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Divide<int, complex<T2>  > > >
operator/(Range d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Divide<int, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>,
      _bz_Divide<P_numtype1, P_numtype2 > > >
operator/(const TinyVector<P_numtype1, N_length1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Divide<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Divide<P_numtype1, typename  P_expr2::T_numtype > > >
operator/(const TinyVector<P_numtype1, N_length1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Divide<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Divide<P_numtype1, P_numtype2 > > >
operator/(const TinyVector<P_numtype1, N_length1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Divide<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range,
      _bz_Divide<P_numtype1, int > > >
operator/(const TinyVector<P_numtype1, N_length1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range, 
      _bz_Divide<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Divide<P_numtype1, P_numtype2 > > >
operator/(const TinyVector<P_numtype1, N_length1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Divide<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>,
      _bz_Divide<P_numtype1, int > > >
operator/(const TinyVector<P_numtype1, N_length1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>, 
      _bz_Divide<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<float>,
      _bz_Divide<P_numtype1, float > > >
operator/(const TinyVector<P_numtype1, N_length1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<float>, 
      _bz_Divide<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<double>,
      _bz_Divide<P_numtype1, double > > >
operator/(const TinyVector<P_numtype1, N_length1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<double>, 
      _bz_Divide<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<long double>,
      _bz_Divide<P_numtype1, long double > > >
operator/(const TinyVector<P_numtype1, N_length1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Divide<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, int N_length1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Divide<P_numtype1, complex<T2>  > > >
operator/(const TinyVector<P_numtype1, N_length1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Divide<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>,
      _bz_Divide<int, P_numtype2 > > >
operator/(int d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>, 
      _bz_Divide<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>,
      _bz_Divide<int, typename  P_expr2::T_numtype > > >
operator/(int d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Divide<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Divide<int, P_numtype2 > > >
operator/(int d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Divide<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Divide<int, P_numtype2 > > >
operator/(int d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Divide<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorIterConst<P_numtype2>,
      _bz_Divide<float, P_numtype2 > > >
operator/(float d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorIterConst<P_numtype2>, 
      _bz_Divide<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      _bz_VecExpr<P_expr2>,
      _bz_Divide<float, typename  P_expr2::T_numtype > > >
operator/(float d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Divide<float, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Divide<float, P_numtype2 > > >
operator/(float d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Divide<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      Range,
      _bz_Divide<float, int > > >
operator/(float d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      Range, 
      _bz_Divide<float, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Divide<float, P_numtype2 > > >
operator/(float d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Divide<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorIterConst<P_numtype2>,
      _bz_Divide<double, P_numtype2 > > >
operator/(double d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorIterConst<P_numtype2>, 
      _bz_Divide<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      _bz_VecExpr<P_expr2>,
      _bz_Divide<double, typename  P_expr2::T_numtype > > >
operator/(double d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Divide<double, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Divide<double, P_numtype2 > > >
operator/(double d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Divide<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      Range,
      _bz_Divide<double, int > > >
operator/(double d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      Range, 
      _bz_Divide<double, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Divide<double, P_numtype2 > > >
operator/(double d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Divide<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorIterConst<P_numtype2>,
      _bz_Divide<long double, P_numtype2 > > >
operator/(long double d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorIterConst<P_numtype2>, 
      _bz_Divide<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      _bz_VecExpr<P_expr2>,
      _bz_Divide<long double, typename  P_expr2::T_numtype > > >
operator/(long double d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Divide<long double, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Divide<long double, P_numtype2 > > >
operator/(long double d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Divide<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      Range,
      _bz_Divide<long double, int > > >
operator/(long double d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      Range, 
      _bz_Divide<long double, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Divide<long double, P_numtype2 > > >
operator/(long double d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Divide<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}


 
template<class T1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorIterConst<P_numtype2>,
      _bz_Divide<complex<T1> , P_numtype2 > > >
operator/(complex<T1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorIterConst<P_numtype2>, 
      _bz_Divide<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}




 
template<class T1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      _bz_VecExpr<P_expr2>,
      _bz_Divide<complex<T1> , typename  P_expr2::T_numtype > > >
operator/(complex<T1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      _bz_VecExpr<P_expr2>, 
      _bz_Divide<complex<T1> , typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2));
}




 
template<class T1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorPickIterConst<P_numtype2>,
      _bz_Divide<complex<T1> , P_numtype2 > > >
operator/(complex<T1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorPickIterConst<P_numtype2>, 
      _bz_Divide<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}




 
template<class T1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      Range,
      _bz_Divide<complex<T1> , int > > >
operator/(complex<T1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      Range, 
      _bz_Divide<complex<T1> , int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2));
}




 
template<class T1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Divide<complex<T1> , P_numtype2 > > >
operator/(complex<T1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Divide<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}


 



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_Mod<P_numtype1, P_numtype2 > > >
operator%(const Vector<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Mod<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Mod<P_numtype1, typename  P_expr2::T_numtype > > >
operator%(const Vector<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Mod<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Mod<P_numtype1, P_numtype2 > > >
operator%(const Vector<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Mod<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range,
      _bz_Mod<P_numtype1, int > > >
operator%(const Vector<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range, 
      _bz_Mod<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Mod<P_numtype1, P_numtype2 > > >
operator%(const Vector<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Mod<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_Mod<P_numtype1, int > > >
operator%(const Vector<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_Mod<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>,
      _bz_Mod< typename  P_expr1::T_numtype, P_numtype2 > > >
operator%(_bz_VecExpr<P_expr1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Mod< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Mod< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype > > >
operator%(_bz_VecExpr<P_expr1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Mod< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Mod< typename  P_expr1::T_numtype, P_numtype2 > > >
operator%(_bz_VecExpr<P_expr1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Mod< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range,
      _bz_Mod< typename  P_expr1::T_numtype, int > > >
operator%(_bz_VecExpr<P_expr1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range, 
      _bz_Mod< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Mod< typename  P_expr1::T_numtype, P_numtype2 > > >
operator%(_bz_VecExpr<P_expr1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Mod< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>,
      _bz_Mod< typename  P_expr1::T_numtype, int > > >
operator%(_bz_VecExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>, 
      _bz_Mod< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_Mod<P_numtype1, P_numtype2 > > >
operator%(const VectorPick<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Mod<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Mod<P_numtype1, typename  P_expr2::T_numtype > > >
operator%(const VectorPick<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Mod<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Mod<P_numtype1, P_numtype2 > > >
operator%(const VectorPick<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Mod<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range,
      _bz_Mod<P_numtype1, int > > >
operator%(const VectorPick<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range, 
      _bz_Mod<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Mod<P_numtype1, P_numtype2 > > >
operator%(const VectorPick<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Mod<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_Mod<P_numtype1, int > > >
operator%(const VectorPick<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_Mod<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>,
      _bz_Mod<int, P_numtype2 > > >
operator%(Range d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>, 
      _bz_Mod<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>,
      _bz_Mod<int, typename  P_expr2::T_numtype > > >
operator%(Range d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>, 
      _bz_Mod<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>,
      _bz_Mod<int, P_numtype2 > > >
operator%(Range d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Mod<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      Range,
      _bz_Mod<int, int > > >
operator%(Range d1, 
      Range d2)
{
    typedef _bz_VecExprOp<Range, 
      Range, 
      _bz_Mod<int, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Mod<int, P_numtype2 > > >
operator%(Range d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Mod<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>,
      _bz_Mod<P_numtype1, P_numtype2 > > >
operator%(const TinyVector<P_numtype1, N_length1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Mod<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Mod<P_numtype1, typename  P_expr2::T_numtype > > >
operator%(const TinyVector<P_numtype1, N_length1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Mod<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Mod<P_numtype1, P_numtype2 > > >
operator%(const TinyVector<P_numtype1, N_length1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Mod<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range,
      _bz_Mod<P_numtype1, int > > >
operator%(const TinyVector<P_numtype1, N_length1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range, 
      _bz_Mod<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Mod<P_numtype1, P_numtype2 > > >
operator%(const TinyVector<P_numtype1, N_length1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Mod<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>,
      _bz_Mod<P_numtype1, int > > >
operator%(const TinyVector<P_numtype1, N_length1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>, 
      _bz_Mod<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>,
      _bz_Mod<int, P_numtype2 > > >
operator%(int d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>, 
      _bz_Mod<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>,
      _bz_Mod<int, typename  P_expr2::T_numtype > > >
operator%(int d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Mod<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Mod<int, P_numtype2 > > >
operator%(int d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Mod<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Mod<int, P_numtype2 > > >
operator%(int d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Mod<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}
 



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_BitwiseXOR<P_numtype1, P_numtype2 > > >
operator^(const Vector<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_BitwiseXOR<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_BitwiseXOR<P_numtype1, typename  P_expr2::T_numtype > > >
operator^(const Vector<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_BitwiseXOR<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_BitwiseXOR<P_numtype1, P_numtype2 > > >
operator^(const Vector<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_BitwiseXOR<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range,
      _bz_BitwiseXOR<P_numtype1, int > > >
operator^(const Vector<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range, 
      _bz_BitwiseXOR<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_BitwiseXOR<P_numtype1, P_numtype2 > > >
operator^(const Vector<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_BitwiseXOR<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_BitwiseXOR<P_numtype1, int > > >
operator^(const Vector<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_BitwiseXOR<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>,
      _bz_BitwiseXOR< typename  P_expr1::T_numtype, P_numtype2 > > >
operator^(_bz_VecExpr<P_expr1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>, 
      _bz_BitwiseXOR< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>,
      _bz_BitwiseXOR< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype > > >
operator^(_bz_VecExpr<P_expr1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_BitwiseXOR< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_BitwiseXOR< typename  P_expr1::T_numtype, P_numtype2 > > >
operator^(_bz_VecExpr<P_expr1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_BitwiseXOR< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range,
      _bz_BitwiseXOR< typename  P_expr1::T_numtype, int > > >
operator^(_bz_VecExpr<P_expr1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range, 
      _bz_BitwiseXOR< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_BitwiseXOR< typename  P_expr1::T_numtype, P_numtype2 > > >
operator^(_bz_VecExpr<P_expr1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_BitwiseXOR< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>,
      _bz_BitwiseXOR< typename  P_expr1::T_numtype, int > > >
operator^(_bz_VecExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>, 
      _bz_BitwiseXOR< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_BitwiseXOR<P_numtype1, P_numtype2 > > >
operator^(const VectorPick<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_BitwiseXOR<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_BitwiseXOR<P_numtype1, typename  P_expr2::T_numtype > > >
operator^(const VectorPick<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_BitwiseXOR<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_BitwiseXOR<P_numtype1, P_numtype2 > > >
operator^(const VectorPick<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_BitwiseXOR<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range,
      _bz_BitwiseXOR<P_numtype1, int > > >
operator^(const VectorPick<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range, 
      _bz_BitwiseXOR<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_BitwiseXOR<P_numtype1, P_numtype2 > > >
operator^(const VectorPick<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_BitwiseXOR<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_BitwiseXOR<P_numtype1, int > > >
operator^(const VectorPick<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_BitwiseXOR<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>,
      _bz_BitwiseXOR<int, P_numtype2 > > >
operator^(Range d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>, 
      _bz_BitwiseXOR<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>,
      _bz_BitwiseXOR<int, typename  P_expr2::T_numtype > > >
operator^(Range d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>, 
      _bz_BitwiseXOR<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>,
      _bz_BitwiseXOR<int, P_numtype2 > > >
operator^(Range d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>, 
      _bz_BitwiseXOR<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      Range,
      _bz_BitwiseXOR<int, int > > >
operator^(Range d1, 
      Range d2)
{
    typedef _bz_VecExprOp<Range, 
      Range, 
      _bz_BitwiseXOR<int, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_BitwiseXOR<int, P_numtype2 > > >
operator^(Range d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_BitwiseXOR<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>,
      _bz_BitwiseXOR<P_numtype1, P_numtype2 > > >
operator^(const TinyVector<P_numtype1, N_length1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>, 
      _bz_BitwiseXOR<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>,
      _bz_BitwiseXOR<P_numtype1, typename  P_expr2::T_numtype > > >
operator^(const TinyVector<P_numtype1, N_length1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_BitwiseXOR<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_BitwiseXOR<P_numtype1, P_numtype2 > > >
operator^(const TinyVector<P_numtype1, N_length1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_BitwiseXOR<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range,
      _bz_BitwiseXOR<P_numtype1, int > > >
operator^(const TinyVector<P_numtype1, N_length1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range, 
      _bz_BitwiseXOR<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_BitwiseXOR<P_numtype1, P_numtype2 > > >
operator^(const TinyVector<P_numtype1, N_length1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_BitwiseXOR<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>,
      _bz_BitwiseXOR<P_numtype1, int > > >
operator^(const TinyVector<P_numtype1, N_length1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>, 
      _bz_BitwiseXOR<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>,
      _bz_BitwiseXOR<int, P_numtype2 > > >
operator^(int d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>, 
      _bz_BitwiseXOR<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>,
      _bz_BitwiseXOR<int, typename  P_expr2::T_numtype > > >
operator^(int d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>, 
      _bz_BitwiseXOR<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>,
      _bz_BitwiseXOR<int, P_numtype2 > > >
operator^(int d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_BitwiseXOR<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_BitwiseXOR<int, P_numtype2 > > >
operator^(int d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_BitwiseXOR<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}
 



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_BitwiseAnd<P_numtype1, P_numtype2 > > >
operator&(const Vector<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_BitwiseAnd<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_BitwiseAnd<P_numtype1, typename  P_expr2::T_numtype > > >
operator&(const Vector<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_BitwiseAnd<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_BitwiseAnd<P_numtype1, P_numtype2 > > >
operator&(const Vector<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_BitwiseAnd<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range,
      _bz_BitwiseAnd<P_numtype1, int > > >
operator&(const Vector<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range, 
      _bz_BitwiseAnd<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_BitwiseAnd<P_numtype1, P_numtype2 > > >
operator&(const Vector<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_BitwiseAnd<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_BitwiseAnd<P_numtype1, int > > >
operator&(const Vector<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_BitwiseAnd<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>,
      _bz_BitwiseAnd< typename  P_expr1::T_numtype, P_numtype2 > > >
operator&(_bz_VecExpr<P_expr1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>, 
      _bz_BitwiseAnd< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>,
      _bz_BitwiseAnd< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype > > >
operator&(_bz_VecExpr<P_expr1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_BitwiseAnd< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_BitwiseAnd< typename  P_expr1::T_numtype, P_numtype2 > > >
operator&(_bz_VecExpr<P_expr1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_BitwiseAnd< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range,
      _bz_BitwiseAnd< typename  P_expr1::T_numtype, int > > >
operator&(_bz_VecExpr<P_expr1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range, 
      _bz_BitwiseAnd< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_BitwiseAnd< typename  P_expr1::T_numtype, P_numtype2 > > >
operator&(_bz_VecExpr<P_expr1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_BitwiseAnd< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>,
      _bz_BitwiseAnd< typename  P_expr1::T_numtype, int > > >
operator&(_bz_VecExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>, 
      _bz_BitwiseAnd< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_BitwiseAnd<P_numtype1, P_numtype2 > > >
operator&(const VectorPick<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_BitwiseAnd<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_BitwiseAnd<P_numtype1, typename  P_expr2::T_numtype > > >
operator&(const VectorPick<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_BitwiseAnd<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_BitwiseAnd<P_numtype1, P_numtype2 > > >
operator&(const VectorPick<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_BitwiseAnd<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range,
      _bz_BitwiseAnd<P_numtype1, int > > >
operator&(const VectorPick<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range, 
      _bz_BitwiseAnd<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_BitwiseAnd<P_numtype1, P_numtype2 > > >
operator&(const VectorPick<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_BitwiseAnd<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_BitwiseAnd<P_numtype1, int > > >
operator&(const VectorPick<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_BitwiseAnd<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>,
      _bz_BitwiseAnd<int, P_numtype2 > > >
operator&(Range d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>, 
      _bz_BitwiseAnd<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>,
      _bz_BitwiseAnd<int, typename  P_expr2::T_numtype > > >
operator&(Range d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>, 
      _bz_BitwiseAnd<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>,
      _bz_BitwiseAnd<int, P_numtype2 > > >
operator&(Range d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>, 
      _bz_BitwiseAnd<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      Range,
      _bz_BitwiseAnd<int, int > > >
operator&(Range d1, 
      Range d2)
{
    typedef _bz_VecExprOp<Range, 
      Range, 
      _bz_BitwiseAnd<int, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_BitwiseAnd<int, P_numtype2 > > >
operator&(Range d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_BitwiseAnd<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>,
      _bz_BitwiseAnd<P_numtype1, P_numtype2 > > >
operator&(const TinyVector<P_numtype1, N_length1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>, 
      _bz_BitwiseAnd<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>,
      _bz_BitwiseAnd<P_numtype1, typename  P_expr2::T_numtype > > >
operator&(const TinyVector<P_numtype1, N_length1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_BitwiseAnd<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_BitwiseAnd<P_numtype1, P_numtype2 > > >
operator&(const TinyVector<P_numtype1, N_length1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_BitwiseAnd<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range,
      _bz_BitwiseAnd<P_numtype1, int > > >
operator&(const TinyVector<P_numtype1, N_length1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range, 
      _bz_BitwiseAnd<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_BitwiseAnd<P_numtype1, P_numtype2 > > >
operator&(const TinyVector<P_numtype1, N_length1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_BitwiseAnd<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>,
      _bz_BitwiseAnd<P_numtype1, int > > >
operator&(const TinyVector<P_numtype1, N_length1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>, 
      _bz_BitwiseAnd<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>,
      _bz_BitwiseAnd<int, P_numtype2 > > >
operator&(int d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>, 
      _bz_BitwiseAnd<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>,
      _bz_BitwiseAnd<int, typename  P_expr2::T_numtype > > >
operator&(int d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>, 
      _bz_BitwiseAnd<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>,
      _bz_BitwiseAnd<int, P_numtype2 > > >
operator&(int d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_BitwiseAnd<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_BitwiseAnd<int, P_numtype2 > > >
operator&(int d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_BitwiseAnd<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}
 



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_BitwiseOr<P_numtype1, P_numtype2 > > >
operator|(const Vector<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_BitwiseOr<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_BitwiseOr<P_numtype1, typename  P_expr2::T_numtype > > >
operator|(const Vector<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_BitwiseOr<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_BitwiseOr<P_numtype1, P_numtype2 > > >
operator|(const Vector<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_BitwiseOr<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range,
      _bz_BitwiseOr<P_numtype1, int > > >
operator|(const Vector<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range, 
      _bz_BitwiseOr<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_BitwiseOr<P_numtype1, P_numtype2 > > >
operator|(const Vector<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_BitwiseOr<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_BitwiseOr<P_numtype1, int > > >
operator|(const Vector<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_BitwiseOr<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>,
      _bz_BitwiseOr< typename  P_expr1::T_numtype, P_numtype2 > > >
operator|(_bz_VecExpr<P_expr1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>, 
      _bz_BitwiseOr< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>,
      _bz_BitwiseOr< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype > > >
operator|(_bz_VecExpr<P_expr1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_BitwiseOr< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_BitwiseOr< typename  P_expr1::T_numtype, P_numtype2 > > >
operator|(_bz_VecExpr<P_expr1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_BitwiseOr< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range,
      _bz_BitwiseOr< typename  P_expr1::T_numtype, int > > >
operator|(_bz_VecExpr<P_expr1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range, 
      _bz_BitwiseOr< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_BitwiseOr< typename  P_expr1::T_numtype, P_numtype2 > > >
operator|(_bz_VecExpr<P_expr1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_BitwiseOr< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>,
      _bz_BitwiseOr< typename  P_expr1::T_numtype, int > > >
operator|(_bz_VecExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>, 
      _bz_BitwiseOr< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_BitwiseOr<P_numtype1, P_numtype2 > > >
operator|(const VectorPick<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_BitwiseOr<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_BitwiseOr<P_numtype1, typename  P_expr2::T_numtype > > >
operator|(const VectorPick<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_BitwiseOr<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_BitwiseOr<P_numtype1, P_numtype2 > > >
operator|(const VectorPick<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_BitwiseOr<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range,
      _bz_BitwiseOr<P_numtype1, int > > >
operator|(const VectorPick<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range, 
      _bz_BitwiseOr<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_BitwiseOr<P_numtype1, P_numtype2 > > >
operator|(const VectorPick<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_BitwiseOr<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_BitwiseOr<P_numtype1, int > > >
operator|(const VectorPick<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_BitwiseOr<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>,
      _bz_BitwiseOr<int, P_numtype2 > > >
operator|(Range d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>, 
      _bz_BitwiseOr<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>,
      _bz_BitwiseOr<int, typename  P_expr2::T_numtype > > >
operator|(Range d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>, 
      _bz_BitwiseOr<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>,
      _bz_BitwiseOr<int, P_numtype2 > > >
operator|(Range d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>, 
      _bz_BitwiseOr<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      Range,
      _bz_BitwiseOr<int, int > > >
operator|(Range d1, 
      Range d2)
{
    typedef _bz_VecExprOp<Range, 
      Range, 
      _bz_BitwiseOr<int, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_BitwiseOr<int, P_numtype2 > > >
operator|(Range d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_BitwiseOr<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>,
      _bz_BitwiseOr<P_numtype1, P_numtype2 > > >
operator|(const TinyVector<P_numtype1, N_length1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>, 
      _bz_BitwiseOr<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>,
      _bz_BitwiseOr<P_numtype1, typename  P_expr2::T_numtype > > >
operator|(const TinyVector<P_numtype1, N_length1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_BitwiseOr<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_BitwiseOr<P_numtype1, P_numtype2 > > >
operator|(const TinyVector<P_numtype1, N_length1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_BitwiseOr<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range,
      _bz_BitwiseOr<P_numtype1, int > > >
operator|(const TinyVector<P_numtype1, N_length1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range, 
      _bz_BitwiseOr<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_BitwiseOr<P_numtype1, P_numtype2 > > >
operator|(const TinyVector<P_numtype1, N_length1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_BitwiseOr<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>,
      _bz_BitwiseOr<P_numtype1, int > > >
operator|(const TinyVector<P_numtype1, N_length1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>, 
      _bz_BitwiseOr<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>,
      _bz_BitwiseOr<int, P_numtype2 > > >
operator|(int d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>, 
      _bz_BitwiseOr<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>,
      _bz_BitwiseOr<int, typename  P_expr2::T_numtype > > >
operator|(int d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>, 
      _bz_BitwiseOr<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>,
      _bz_BitwiseOr<int, P_numtype2 > > >
operator|(int d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_BitwiseOr<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_BitwiseOr<int, P_numtype2 > > >
operator|(int d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_BitwiseOr<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}
 



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_ShiftRight<P_numtype1, P_numtype2 > > >
operator>>(const Vector<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_ShiftRight<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_ShiftRight<P_numtype1, typename  P_expr2::T_numtype > > >
operator>>(const Vector<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_ShiftRight<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_ShiftRight<P_numtype1, P_numtype2 > > >
operator>>(const Vector<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_ShiftRight<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range,
      _bz_ShiftRight<P_numtype1, int > > >
operator>>(const Vector<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range, 
      _bz_ShiftRight<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_ShiftRight<P_numtype1, P_numtype2 > > >
operator>>(const Vector<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_ShiftRight<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_ShiftRight<P_numtype1, int > > >
operator>>(const Vector<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_ShiftRight<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>,
      _bz_ShiftRight< typename  P_expr1::T_numtype, P_numtype2 > > >
operator>>(_bz_VecExpr<P_expr1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>, 
      _bz_ShiftRight< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>,
      _bz_ShiftRight< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype > > >
operator>>(_bz_VecExpr<P_expr1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_ShiftRight< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_ShiftRight< typename  P_expr1::T_numtype, P_numtype2 > > >
operator>>(_bz_VecExpr<P_expr1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_ShiftRight< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range,
      _bz_ShiftRight< typename  P_expr1::T_numtype, int > > >
operator>>(_bz_VecExpr<P_expr1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range, 
      _bz_ShiftRight< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_ShiftRight< typename  P_expr1::T_numtype, P_numtype2 > > >
operator>>(_bz_VecExpr<P_expr1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_ShiftRight< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>,
      _bz_ShiftRight< typename  P_expr1::T_numtype, int > > >
operator>>(_bz_VecExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>, 
      _bz_ShiftRight< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_ShiftRight<P_numtype1, P_numtype2 > > >
operator>>(const VectorPick<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_ShiftRight<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_ShiftRight<P_numtype1, typename  P_expr2::T_numtype > > >
operator>>(const VectorPick<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_ShiftRight<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_ShiftRight<P_numtype1, P_numtype2 > > >
operator>>(const VectorPick<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_ShiftRight<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range,
      _bz_ShiftRight<P_numtype1, int > > >
operator>>(const VectorPick<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range, 
      _bz_ShiftRight<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_ShiftRight<P_numtype1, P_numtype2 > > >
operator>>(const VectorPick<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_ShiftRight<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_ShiftRight<P_numtype1, int > > >
operator>>(const VectorPick<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_ShiftRight<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>,
      _bz_ShiftRight<int, P_numtype2 > > >
operator>>(Range d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>, 
      _bz_ShiftRight<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>,
      _bz_ShiftRight<int, typename  P_expr2::T_numtype > > >
operator>>(Range d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>, 
      _bz_ShiftRight<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>,
      _bz_ShiftRight<int, P_numtype2 > > >
operator>>(Range d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>, 
      _bz_ShiftRight<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      Range,
      _bz_ShiftRight<int, int > > >
operator>>(Range d1, 
      Range d2)
{
    typedef _bz_VecExprOp<Range, 
      Range, 
      _bz_ShiftRight<int, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_ShiftRight<int, P_numtype2 > > >
operator>>(Range d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_ShiftRight<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>,
      _bz_ShiftRight<P_numtype1, P_numtype2 > > >
operator>>(const TinyVector<P_numtype1, N_length1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>, 
      _bz_ShiftRight<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>,
      _bz_ShiftRight<P_numtype1, typename  P_expr2::T_numtype > > >
operator>>(const TinyVector<P_numtype1, N_length1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_ShiftRight<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_ShiftRight<P_numtype1, P_numtype2 > > >
operator>>(const TinyVector<P_numtype1, N_length1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_ShiftRight<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range,
      _bz_ShiftRight<P_numtype1, int > > >
operator>>(const TinyVector<P_numtype1, N_length1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range, 
      _bz_ShiftRight<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_ShiftRight<P_numtype1, P_numtype2 > > >
operator>>(const TinyVector<P_numtype1, N_length1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_ShiftRight<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>,
      _bz_ShiftRight<P_numtype1, int > > >
operator>>(const TinyVector<P_numtype1, N_length1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>, 
      _bz_ShiftRight<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>,
      _bz_ShiftRight<int, P_numtype2 > > >
operator>>(int d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>, 
      _bz_ShiftRight<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>,
      _bz_ShiftRight<int, typename  P_expr2::T_numtype > > >
operator>>(int d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>, 
      _bz_ShiftRight<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>,
      _bz_ShiftRight<int, P_numtype2 > > >
operator>>(int d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_ShiftRight<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_ShiftRight<int, P_numtype2 > > >
operator>>(int d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_ShiftRight<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}
 



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_ShiftLeft<P_numtype1, P_numtype2 > > >
operator<<(const Vector<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_ShiftLeft<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_ShiftLeft<P_numtype1, typename  P_expr2::T_numtype > > >
operator<<(const Vector<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_ShiftLeft<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_ShiftLeft<P_numtype1, P_numtype2 > > >
operator<<(const Vector<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_ShiftLeft<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range,
      _bz_ShiftLeft<P_numtype1, int > > >
operator<<(const Vector<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range, 
      _bz_ShiftLeft<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_ShiftLeft<P_numtype1, P_numtype2 > > >
operator<<(const Vector<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_ShiftLeft<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_ShiftLeft<P_numtype1, int > > >
operator<<(const Vector<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_ShiftLeft<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>,
      _bz_ShiftLeft< typename  P_expr1::T_numtype, P_numtype2 > > >
operator<<(_bz_VecExpr<P_expr1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>, 
      _bz_ShiftLeft< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>,
      _bz_ShiftLeft< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype > > >
operator<<(_bz_VecExpr<P_expr1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_ShiftLeft< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_ShiftLeft< typename  P_expr1::T_numtype, P_numtype2 > > >
operator<<(_bz_VecExpr<P_expr1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_ShiftLeft< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range,
      _bz_ShiftLeft< typename  P_expr1::T_numtype, int > > >
operator<<(_bz_VecExpr<P_expr1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range, 
      _bz_ShiftLeft< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_ShiftLeft< typename  P_expr1::T_numtype, P_numtype2 > > >
operator<<(_bz_VecExpr<P_expr1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_ShiftLeft< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>,
      _bz_ShiftLeft< typename  P_expr1::T_numtype, int > > >
operator<<(_bz_VecExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>, 
      _bz_ShiftLeft< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_ShiftLeft<P_numtype1, P_numtype2 > > >
operator<<(const VectorPick<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_ShiftLeft<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_ShiftLeft<P_numtype1, typename  P_expr2::T_numtype > > >
operator<<(const VectorPick<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_ShiftLeft<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_ShiftLeft<P_numtype1, P_numtype2 > > >
operator<<(const VectorPick<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_ShiftLeft<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range,
      _bz_ShiftLeft<P_numtype1, int > > >
operator<<(const VectorPick<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range, 
      _bz_ShiftLeft<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_ShiftLeft<P_numtype1, P_numtype2 > > >
operator<<(const VectorPick<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_ShiftLeft<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_ShiftLeft<P_numtype1, int > > >
operator<<(const VectorPick<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_ShiftLeft<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>,
      _bz_ShiftLeft<int, P_numtype2 > > >
operator<<(Range d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>, 
      _bz_ShiftLeft<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>,
      _bz_ShiftLeft<int, typename  P_expr2::T_numtype > > >
operator<<(Range d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>, 
      _bz_ShiftLeft<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>,
      _bz_ShiftLeft<int, P_numtype2 > > >
operator<<(Range d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>, 
      _bz_ShiftLeft<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      Range,
      _bz_ShiftLeft<int, int > > >
operator<<(Range d1, 
      Range d2)
{
    typedef _bz_VecExprOp<Range, 
      Range, 
      _bz_ShiftLeft<int, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_ShiftLeft<int, P_numtype2 > > >
operator<<(Range d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_ShiftLeft<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>,
      _bz_ShiftLeft<P_numtype1, P_numtype2 > > >
operator<<(const TinyVector<P_numtype1, N_length1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>, 
      _bz_ShiftLeft<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>,
      _bz_ShiftLeft<P_numtype1, typename  P_expr2::T_numtype > > >
operator<<(const TinyVector<P_numtype1, N_length1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_ShiftLeft<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_ShiftLeft<P_numtype1, P_numtype2 > > >
operator<<(const TinyVector<P_numtype1, N_length1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_ShiftLeft<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range,
      _bz_ShiftLeft<P_numtype1, int > > >
operator<<(const TinyVector<P_numtype1, N_length1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range, 
      _bz_ShiftLeft<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_ShiftLeft<P_numtype1, P_numtype2 > > >
operator<<(const TinyVector<P_numtype1, N_length1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_ShiftLeft<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>,
      _bz_ShiftLeft<P_numtype1, int > > >
operator<<(const TinyVector<P_numtype1, N_length1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>, 
      _bz_ShiftLeft<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>,
      _bz_ShiftLeft<int, P_numtype2 > > >
operator<<(int d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>, 
      _bz_ShiftLeft<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>,
      _bz_ShiftLeft<int, typename  P_expr2::T_numtype > > >
operator<<(int d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>, 
      _bz_ShiftLeft<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>,
      _bz_ShiftLeft<int, P_numtype2 > > >
operator<<(int d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_ShiftLeft<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_ShiftLeft<int, P_numtype2 > > >
operator<<(int d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_ShiftLeft<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}
 



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_Greater<P_numtype1, P_numtype2 > > >
operator>(const Vector<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Greater<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Greater<P_numtype1, typename  P_expr2::T_numtype > > >
operator>(const Vector<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Greater<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Greater<P_numtype1, P_numtype2 > > >
operator>(const Vector<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Greater<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range,
      _bz_Greater<P_numtype1, int > > >
operator>(const Vector<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range, 
      _bz_Greater<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Greater<P_numtype1, P_numtype2 > > >
operator>(const Vector<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Greater<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_Greater<P_numtype1, int > > >
operator>(const Vector<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_Greater<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>,
      _bz_Greater<P_numtype1, float > > >
operator>(const Vector<P_numtype1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>, 
      _bz_Greater<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>,
      _bz_Greater<P_numtype1, double > > >
operator>(const Vector<P_numtype1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>, 
      _bz_Greater<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>,
      _bz_Greater<P_numtype1, long double > > >
operator>(const Vector<P_numtype1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Greater<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Greater<P_numtype1, complex<T2>  > > >
operator>(const Vector<P_numtype1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Greater<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>,
      _bz_Greater< typename  P_expr1::T_numtype, P_numtype2 > > >
operator>(_bz_VecExpr<P_expr1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Greater< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Greater< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype > > >
operator>(_bz_VecExpr<P_expr1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Greater< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Greater< typename  P_expr1::T_numtype, P_numtype2 > > >
operator>(_bz_VecExpr<P_expr1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Greater< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range,
      _bz_Greater< typename  P_expr1::T_numtype, int > > >
operator>(_bz_VecExpr<P_expr1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range, 
      _bz_Greater< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Greater< typename  P_expr1::T_numtype, P_numtype2 > > >
operator>(_bz_VecExpr<P_expr1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Greater< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>,
      _bz_Greater< typename  P_expr1::T_numtype, int > > >
operator>(_bz_VecExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>, 
      _bz_Greater< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<float>,
      _bz_Greater< typename  P_expr1::T_numtype, float > > >
operator>(_bz_VecExpr<P_expr1> d1, 
      float d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<float>, 
      _bz_Greater< typename  P_expr1::T_numtype, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<double>,
      _bz_Greater< typename  P_expr1::T_numtype, double > > >
operator>(_bz_VecExpr<P_expr1> d1, 
      double d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<double>, 
      _bz_Greater< typename  P_expr1::T_numtype, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<long double>,
      _bz_Greater< typename  P_expr1::T_numtype, long double > > >
operator>(_bz_VecExpr<P_expr1> d1, 
      long double d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Greater< typename  P_expr1::T_numtype, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_expr1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Greater< typename  P_expr1::T_numtype, complex<T2>  > > >
operator>(_bz_VecExpr<P_expr1> d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Greater< typename  P_expr1::T_numtype, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_Greater<P_numtype1, P_numtype2 > > >
operator>(const VectorPick<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Greater<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Greater<P_numtype1, typename  P_expr2::T_numtype > > >
operator>(const VectorPick<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Greater<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Greater<P_numtype1, P_numtype2 > > >
operator>(const VectorPick<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Greater<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range,
      _bz_Greater<P_numtype1, int > > >
operator>(const VectorPick<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range, 
      _bz_Greater<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Greater<P_numtype1, P_numtype2 > > >
operator>(const VectorPick<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Greater<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_Greater<P_numtype1, int > > >
operator>(const VectorPick<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_Greater<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>,
      _bz_Greater<P_numtype1, float > > >
operator>(const VectorPick<P_numtype1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>, 
      _bz_Greater<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>,
      _bz_Greater<P_numtype1, double > > >
operator>(const VectorPick<P_numtype1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>, 
      _bz_Greater<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>,
      _bz_Greater<P_numtype1, long double > > >
operator>(const VectorPick<P_numtype1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Greater<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Greater<P_numtype1, complex<T2>  > > >
operator>(const VectorPick<P_numtype1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Greater<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>,
      _bz_Greater<int, P_numtype2 > > >
operator>(Range d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>, 
      _bz_Greater<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>,
      _bz_Greater<int, typename  P_expr2::T_numtype > > >
operator>(Range d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>, 
      _bz_Greater<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>,
      _bz_Greater<int, P_numtype2 > > >
operator>(Range d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Greater<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      Range,
      _bz_Greater<int, int > > >
operator>(Range d1, 
      Range d2)
{
    typedef _bz_VecExprOp<Range, 
      Range, 
      _bz_Greater<int, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Greater<int, P_numtype2 > > >
operator>(Range d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Greater<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<float>,
      _bz_Greater<int, float > > >
operator>(Range d1, 
      float d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<float>, 
      _bz_Greater<int, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<float>(d2)));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<double>,
      _bz_Greater<int, double > > >
operator>(Range d1, 
      double d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<double>, 
      _bz_Greater<int, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<double>(d2)));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<long double>,
      _bz_Greater<int, long double > > >
operator>(Range d1, 
      long double d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<long double>, 
      _bz_Greater<int, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class T2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Greater<int, complex<T2>  > > >
operator>(Range d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Greater<int, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>,
      _bz_Greater<P_numtype1, P_numtype2 > > >
operator>(const TinyVector<P_numtype1, N_length1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Greater<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Greater<P_numtype1, typename  P_expr2::T_numtype > > >
operator>(const TinyVector<P_numtype1, N_length1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Greater<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Greater<P_numtype1, P_numtype2 > > >
operator>(const TinyVector<P_numtype1, N_length1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Greater<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range,
      _bz_Greater<P_numtype1, int > > >
operator>(const TinyVector<P_numtype1, N_length1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range, 
      _bz_Greater<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Greater<P_numtype1, P_numtype2 > > >
operator>(const TinyVector<P_numtype1, N_length1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Greater<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>,
      _bz_Greater<P_numtype1, int > > >
operator>(const TinyVector<P_numtype1, N_length1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>, 
      _bz_Greater<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<float>,
      _bz_Greater<P_numtype1, float > > >
operator>(const TinyVector<P_numtype1, N_length1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<float>, 
      _bz_Greater<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<double>,
      _bz_Greater<P_numtype1, double > > >
operator>(const TinyVector<P_numtype1, N_length1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<double>, 
      _bz_Greater<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<long double>,
      _bz_Greater<P_numtype1, long double > > >
operator>(const TinyVector<P_numtype1, N_length1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Greater<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, int N_length1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Greater<P_numtype1, complex<T2>  > > >
operator>(const TinyVector<P_numtype1, N_length1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Greater<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>,
      _bz_Greater<int, P_numtype2 > > >
operator>(int d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>, 
      _bz_Greater<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>,
      _bz_Greater<int, typename  P_expr2::T_numtype > > >
operator>(int d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Greater<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Greater<int, P_numtype2 > > >
operator>(int d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Greater<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Greater<int, P_numtype2 > > >
operator>(int d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Greater<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorIterConst<P_numtype2>,
      _bz_Greater<float, P_numtype2 > > >
operator>(float d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorIterConst<P_numtype2>, 
      _bz_Greater<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      _bz_VecExpr<P_expr2>,
      _bz_Greater<float, typename  P_expr2::T_numtype > > >
operator>(float d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Greater<float, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Greater<float, P_numtype2 > > >
operator>(float d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Greater<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      Range,
      _bz_Greater<float, int > > >
operator>(float d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      Range, 
      _bz_Greater<float, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Greater<float, P_numtype2 > > >
operator>(float d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Greater<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorIterConst<P_numtype2>,
      _bz_Greater<double, P_numtype2 > > >
operator>(double d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorIterConst<P_numtype2>, 
      _bz_Greater<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      _bz_VecExpr<P_expr2>,
      _bz_Greater<double, typename  P_expr2::T_numtype > > >
operator>(double d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Greater<double, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Greater<double, P_numtype2 > > >
operator>(double d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Greater<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      Range,
      _bz_Greater<double, int > > >
operator>(double d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      Range, 
      _bz_Greater<double, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Greater<double, P_numtype2 > > >
operator>(double d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Greater<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorIterConst<P_numtype2>,
      _bz_Greater<long double, P_numtype2 > > >
operator>(long double d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorIterConst<P_numtype2>, 
      _bz_Greater<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      _bz_VecExpr<P_expr2>,
      _bz_Greater<long double, typename  P_expr2::T_numtype > > >
operator>(long double d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Greater<long double, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Greater<long double, P_numtype2 > > >
operator>(long double d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Greater<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      Range,
      _bz_Greater<long double, int > > >
operator>(long double d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      Range, 
      _bz_Greater<long double, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Greater<long double, P_numtype2 > > >
operator>(long double d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Greater<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}


 
template<class T1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorIterConst<P_numtype2>,
      _bz_Greater<complex<T1> , P_numtype2 > > >
operator>(complex<T1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorIterConst<P_numtype2>, 
      _bz_Greater<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}




 
template<class T1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      _bz_VecExpr<P_expr2>,
      _bz_Greater<complex<T1> , typename  P_expr2::T_numtype > > >
operator>(complex<T1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      _bz_VecExpr<P_expr2>, 
      _bz_Greater<complex<T1> , typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2));
}




 
template<class T1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorPickIterConst<P_numtype2>,
      _bz_Greater<complex<T1> , P_numtype2 > > >
operator>(complex<T1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorPickIterConst<P_numtype2>, 
      _bz_Greater<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}




 
template<class T1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      Range,
      _bz_Greater<complex<T1> , int > > >
operator>(complex<T1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      Range, 
      _bz_Greater<complex<T1> , int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2));
}




 
template<class T1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Greater<complex<T1> , P_numtype2 > > >
operator>(complex<T1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Greater<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}


 



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_Less<P_numtype1, P_numtype2 > > >
operator<(const Vector<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Less<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Less<P_numtype1, typename  P_expr2::T_numtype > > >
operator<(const Vector<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Less<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Less<P_numtype1, P_numtype2 > > >
operator<(const Vector<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Less<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range,
      _bz_Less<P_numtype1, int > > >
operator<(const Vector<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range, 
      _bz_Less<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Less<P_numtype1, P_numtype2 > > >
operator<(const Vector<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Less<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_Less<P_numtype1, int > > >
operator<(const Vector<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_Less<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>,
      _bz_Less<P_numtype1, float > > >
operator<(const Vector<P_numtype1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>, 
      _bz_Less<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>,
      _bz_Less<P_numtype1, double > > >
operator<(const Vector<P_numtype1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>, 
      _bz_Less<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>,
      _bz_Less<P_numtype1, long double > > >
operator<(const Vector<P_numtype1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Less<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Less<P_numtype1, complex<T2>  > > >
operator<(const Vector<P_numtype1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Less<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>,
      _bz_Less< typename  P_expr1::T_numtype, P_numtype2 > > >
operator<(_bz_VecExpr<P_expr1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Less< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Less< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype > > >
operator<(_bz_VecExpr<P_expr1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Less< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Less< typename  P_expr1::T_numtype, P_numtype2 > > >
operator<(_bz_VecExpr<P_expr1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Less< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range,
      _bz_Less< typename  P_expr1::T_numtype, int > > >
operator<(_bz_VecExpr<P_expr1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range, 
      _bz_Less< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Less< typename  P_expr1::T_numtype, P_numtype2 > > >
operator<(_bz_VecExpr<P_expr1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Less< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>,
      _bz_Less< typename  P_expr1::T_numtype, int > > >
operator<(_bz_VecExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>, 
      _bz_Less< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<float>,
      _bz_Less< typename  P_expr1::T_numtype, float > > >
operator<(_bz_VecExpr<P_expr1> d1, 
      float d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<float>, 
      _bz_Less< typename  P_expr1::T_numtype, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<double>,
      _bz_Less< typename  P_expr1::T_numtype, double > > >
operator<(_bz_VecExpr<P_expr1> d1, 
      double d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<double>, 
      _bz_Less< typename  P_expr1::T_numtype, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<long double>,
      _bz_Less< typename  P_expr1::T_numtype, long double > > >
operator<(_bz_VecExpr<P_expr1> d1, 
      long double d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Less< typename  P_expr1::T_numtype, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_expr1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Less< typename  P_expr1::T_numtype, complex<T2>  > > >
operator<(_bz_VecExpr<P_expr1> d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Less< typename  P_expr1::T_numtype, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_Less<P_numtype1, P_numtype2 > > >
operator<(const VectorPick<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Less<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Less<P_numtype1, typename  P_expr2::T_numtype > > >
operator<(const VectorPick<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Less<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Less<P_numtype1, P_numtype2 > > >
operator<(const VectorPick<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Less<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range,
      _bz_Less<P_numtype1, int > > >
operator<(const VectorPick<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range, 
      _bz_Less<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Less<P_numtype1, P_numtype2 > > >
operator<(const VectorPick<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Less<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_Less<P_numtype1, int > > >
operator<(const VectorPick<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_Less<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>,
      _bz_Less<P_numtype1, float > > >
operator<(const VectorPick<P_numtype1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>, 
      _bz_Less<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>,
      _bz_Less<P_numtype1, double > > >
operator<(const VectorPick<P_numtype1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>, 
      _bz_Less<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>,
      _bz_Less<P_numtype1, long double > > >
operator<(const VectorPick<P_numtype1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Less<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Less<P_numtype1, complex<T2>  > > >
operator<(const VectorPick<P_numtype1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Less<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>,
      _bz_Less<int, P_numtype2 > > >
operator<(Range d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>, 
      _bz_Less<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>,
      _bz_Less<int, typename  P_expr2::T_numtype > > >
operator<(Range d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>, 
      _bz_Less<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>,
      _bz_Less<int, P_numtype2 > > >
operator<(Range d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Less<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      Range,
      _bz_Less<int, int > > >
operator<(Range d1, 
      Range d2)
{
    typedef _bz_VecExprOp<Range, 
      Range, 
      _bz_Less<int, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Less<int, P_numtype2 > > >
operator<(Range d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Less<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<float>,
      _bz_Less<int, float > > >
operator<(Range d1, 
      float d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<float>, 
      _bz_Less<int, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<float>(d2)));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<double>,
      _bz_Less<int, double > > >
operator<(Range d1, 
      double d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<double>, 
      _bz_Less<int, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<double>(d2)));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<long double>,
      _bz_Less<int, long double > > >
operator<(Range d1, 
      long double d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<long double>, 
      _bz_Less<int, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class T2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Less<int, complex<T2>  > > >
operator<(Range d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Less<int, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>,
      _bz_Less<P_numtype1, P_numtype2 > > >
operator<(const TinyVector<P_numtype1, N_length1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Less<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Less<P_numtype1, typename  P_expr2::T_numtype > > >
operator<(const TinyVector<P_numtype1, N_length1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Less<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Less<P_numtype1, P_numtype2 > > >
operator<(const TinyVector<P_numtype1, N_length1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Less<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range,
      _bz_Less<P_numtype1, int > > >
operator<(const TinyVector<P_numtype1, N_length1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range, 
      _bz_Less<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Less<P_numtype1, P_numtype2 > > >
operator<(const TinyVector<P_numtype1, N_length1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Less<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>,
      _bz_Less<P_numtype1, int > > >
operator<(const TinyVector<P_numtype1, N_length1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>, 
      _bz_Less<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<float>,
      _bz_Less<P_numtype1, float > > >
operator<(const TinyVector<P_numtype1, N_length1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<float>, 
      _bz_Less<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<double>,
      _bz_Less<P_numtype1, double > > >
operator<(const TinyVector<P_numtype1, N_length1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<double>, 
      _bz_Less<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<long double>,
      _bz_Less<P_numtype1, long double > > >
operator<(const TinyVector<P_numtype1, N_length1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Less<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, int N_length1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Less<P_numtype1, complex<T2>  > > >
operator<(const TinyVector<P_numtype1, N_length1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Less<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>,
      _bz_Less<int, P_numtype2 > > >
operator<(int d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>, 
      _bz_Less<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>,
      _bz_Less<int, typename  P_expr2::T_numtype > > >
operator<(int d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Less<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Less<int, P_numtype2 > > >
operator<(int d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Less<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Less<int, P_numtype2 > > >
operator<(int d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Less<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorIterConst<P_numtype2>,
      _bz_Less<float, P_numtype2 > > >
operator<(float d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorIterConst<P_numtype2>, 
      _bz_Less<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      _bz_VecExpr<P_expr2>,
      _bz_Less<float, typename  P_expr2::T_numtype > > >
operator<(float d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Less<float, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Less<float, P_numtype2 > > >
operator<(float d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Less<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      Range,
      _bz_Less<float, int > > >
operator<(float d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      Range, 
      _bz_Less<float, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Less<float, P_numtype2 > > >
operator<(float d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Less<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorIterConst<P_numtype2>,
      _bz_Less<double, P_numtype2 > > >
operator<(double d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorIterConst<P_numtype2>, 
      _bz_Less<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      _bz_VecExpr<P_expr2>,
      _bz_Less<double, typename  P_expr2::T_numtype > > >
operator<(double d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Less<double, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Less<double, P_numtype2 > > >
operator<(double d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Less<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      Range,
      _bz_Less<double, int > > >
operator<(double d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      Range, 
      _bz_Less<double, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Less<double, P_numtype2 > > >
operator<(double d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Less<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorIterConst<P_numtype2>,
      _bz_Less<long double, P_numtype2 > > >
operator<(long double d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorIterConst<P_numtype2>, 
      _bz_Less<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      _bz_VecExpr<P_expr2>,
      _bz_Less<long double, typename  P_expr2::T_numtype > > >
operator<(long double d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Less<long double, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Less<long double, P_numtype2 > > >
operator<(long double d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Less<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      Range,
      _bz_Less<long double, int > > >
operator<(long double d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      Range, 
      _bz_Less<long double, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Less<long double, P_numtype2 > > >
operator<(long double d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Less<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}


 
template<class T1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorIterConst<P_numtype2>,
      _bz_Less<complex<T1> , P_numtype2 > > >
operator<(complex<T1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorIterConst<P_numtype2>, 
      _bz_Less<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}




 
template<class T1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      _bz_VecExpr<P_expr2>,
      _bz_Less<complex<T1> , typename  P_expr2::T_numtype > > >
operator<(complex<T1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      _bz_VecExpr<P_expr2>, 
      _bz_Less<complex<T1> , typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2));
}




 
template<class T1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorPickIterConst<P_numtype2>,
      _bz_Less<complex<T1> , P_numtype2 > > >
operator<(complex<T1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorPickIterConst<P_numtype2>, 
      _bz_Less<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}




 
template<class T1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      Range,
      _bz_Less<complex<T1> , int > > >
operator<(complex<T1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      Range, 
      _bz_Less<complex<T1> , int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2));
}




 
template<class T1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Less<complex<T1> , P_numtype2 > > >
operator<(complex<T1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Less<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}


 



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_GreaterOrEqual<P_numtype1, P_numtype2 > > >
operator>=(const Vector<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_GreaterOrEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_GreaterOrEqual<P_numtype1, typename  P_expr2::T_numtype > > >
operator>=(const Vector<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_GreaterOrEqual<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_GreaterOrEqual<P_numtype1, P_numtype2 > > >
operator>=(const Vector<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_GreaterOrEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range,
      _bz_GreaterOrEqual<P_numtype1, int > > >
operator>=(const Vector<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range, 
      _bz_GreaterOrEqual<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_GreaterOrEqual<P_numtype1, P_numtype2 > > >
operator>=(const Vector<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_GreaterOrEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_GreaterOrEqual<P_numtype1, int > > >
operator>=(const Vector<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_GreaterOrEqual<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>,
      _bz_GreaterOrEqual<P_numtype1, float > > >
operator>=(const Vector<P_numtype1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>, 
      _bz_GreaterOrEqual<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>,
      _bz_GreaterOrEqual<P_numtype1, double > > >
operator>=(const Vector<P_numtype1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>, 
      _bz_GreaterOrEqual<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>,
      _bz_GreaterOrEqual<P_numtype1, long double > > >
operator>=(const Vector<P_numtype1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>, 
      _bz_GreaterOrEqual<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_GreaterOrEqual<P_numtype1, complex<T2>  > > >
operator>=(const Vector<P_numtype1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_GreaterOrEqual<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>,
      _bz_GreaterOrEqual< typename  P_expr1::T_numtype, P_numtype2 > > >
operator>=(_bz_VecExpr<P_expr1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>, 
      _bz_GreaterOrEqual< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>,
      _bz_GreaterOrEqual< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype > > >
operator>=(_bz_VecExpr<P_expr1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_GreaterOrEqual< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_GreaterOrEqual< typename  P_expr1::T_numtype, P_numtype2 > > >
operator>=(_bz_VecExpr<P_expr1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_GreaterOrEqual< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range,
      _bz_GreaterOrEqual< typename  P_expr1::T_numtype, int > > >
operator>=(_bz_VecExpr<P_expr1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range, 
      _bz_GreaterOrEqual< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_GreaterOrEqual< typename  P_expr1::T_numtype, P_numtype2 > > >
operator>=(_bz_VecExpr<P_expr1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_GreaterOrEqual< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>,
      _bz_GreaterOrEqual< typename  P_expr1::T_numtype, int > > >
operator>=(_bz_VecExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>, 
      _bz_GreaterOrEqual< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<float>,
      _bz_GreaterOrEqual< typename  P_expr1::T_numtype, float > > >
operator>=(_bz_VecExpr<P_expr1> d1, 
      float d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<float>, 
      _bz_GreaterOrEqual< typename  P_expr1::T_numtype, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<double>,
      _bz_GreaterOrEqual< typename  P_expr1::T_numtype, double > > >
operator>=(_bz_VecExpr<P_expr1> d1, 
      double d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<double>, 
      _bz_GreaterOrEqual< typename  P_expr1::T_numtype, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<long double>,
      _bz_GreaterOrEqual< typename  P_expr1::T_numtype, long double > > >
operator>=(_bz_VecExpr<P_expr1> d1, 
      long double d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<long double>, 
      _bz_GreaterOrEqual< typename  P_expr1::T_numtype, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_expr1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_GreaterOrEqual< typename  P_expr1::T_numtype, complex<T2>  > > >
operator>=(_bz_VecExpr<P_expr1> d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_GreaterOrEqual< typename  P_expr1::T_numtype, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_GreaterOrEqual<P_numtype1, P_numtype2 > > >
operator>=(const VectorPick<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_GreaterOrEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_GreaterOrEqual<P_numtype1, typename  P_expr2::T_numtype > > >
operator>=(const VectorPick<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_GreaterOrEqual<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_GreaterOrEqual<P_numtype1, P_numtype2 > > >
operator>=(const VectorPick<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_GreaterOrEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range,
      _bz_GreaterOrEqual<P_numtype1, int > > >
operator>=(const VectorPick<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range, 
      _bz_GreaterOrEqual<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_GreaterOrEqual<P_numtype1, P_numtype2 > > >
operator>=(const VectorPick<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_GreaterOrEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_GreaterOrEqual<P_numtype1, int > > >
operator>=(const VectorPick<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_GreaterOrEqual<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>,
      _bz_GreaterOrEqual<P_numtype1, float > > >
operator>=(const VectorPick<P_numtype1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>, 
      _bz_GreaterOrEqual<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>,
      _bz_GreaterOrEqual<P_numtype1, double > > >
operator>=(const VectorPick<P_numtype1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>, 
      _bz_GreaterOrEqual<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>,
      _bz_GreaterOrEqual<P_numtype1, long double > > >
operator>=(const VectorPick<P_numtype1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>, 
      _bz_GreaterOrEqual<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_GreaterOrEqual<P_numtype1, complex<T2>  > > >
operator>=(const VectorPick<P_numtype1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_GreaterOrEqual<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>,
      _bz_GreaterOrEqual<int, P_numtype2 > > >
operator>=(Range d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>, 
      _bz_GreaterOrEqual<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>,
      _bz_GreaterOrEqual<int, typename  P_expr2::T_numtype > > >
operator>=(Range d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>, 
      _bz_GreaterOrEqual<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>,
      _bz_GreaterOrEqual<int, P_numtype2 > > >
operator>=(Range d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>, 
      _bz_GreaterOrEqual<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      Range,
      _bz_GreaterOrEqual<int, int > > >
operator>=(Range d1, 
      Range d2)
{
    typedef _bz_VecExprOp<Range, 
      Range, 
      _bz_GreaterOrEqual<int, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_GreaterOrEqual<int, P_numtype2 > > >
operator>=(Range d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_GreaterOrEqual<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<float>,
      _bz_GreaterOrEqual<int, float > > >
operator>=(Range d1, 
      float d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<float>, 
      _bz_GreaterOrEqual<int, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<float>(d2)));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<double>,
      _bz_GreaterOrEqual<int, double > > >
operator>=(Range d1, 
      double d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<double>, 
      _bz_GreaterOrEqual<int, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<double>(d2)));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<long double>,
      _bz_GreaterOrEqual<int, long double > > >
operator>=(Range d1, 
      long double d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<long double>, 
      _bz_GreaterOrEqual<int, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class T2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_GreaterOrEqual<int, complex<T2>  > > >
operator>=(Range d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_GreaterOrEqual<int, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>,
      _bz_GreaterOrEqual<P_numtype1, P_numtype2 > > >
operator>=(const TinyVector<P_numtype1, N_length1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>, 
      _bz_GreaterOrEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>,
      _bz_GreaterOrEqual<P_numtype1, typename  P_expr2::T_numtype > > >
operator>=(const TinyVector<P_numtype1, N_length1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_GreaterOrEqual<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_GreaterOrEqual<P_numtype1, P_numtype2 > > >
operator>=(const TinyVector<P_numtype1, N_length1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_GreaterOrEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range,
      _bz_GreaterOrEqual<P_numtype1, int > > >
operator>=(const TinyVector<P_numtype1, N_length1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range, 
      _bz_GreaterOrEqual<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_GreaterOrEqual<P_numtype1, P_numtype2 > > >
operator>=(const TinyVector<P_numtype1, N_length1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_GreaterOrEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>,
      _bz_GreaterOrEqual<P_numtype1, int > > >
operator>=(const TinyVector<P_numtype1, N_length1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>, 
      _bz_GreaterOrEqual<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<float>,
      _bz_GreaterOrEqual<P_numtype1, float > > >
operator>=(const TinyVector<P_numtype1, N_length1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<float>, 
      _bz_GreaterOrEqual<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<double>,
      _bz_GreaterOrEqual<P_numtype1, double > > >
operator>=(const TinyVector<P_numtype1, N_length1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<double>, 
      _bz_GreaterOrEqual<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<long double>,
      _bz_GreaterOrEqual<P_numtype1, long double > > >
operator>=(const TinyVector<P_numtype1, N_length1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<long double>, 
      _bz_GreaterOrEqual<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, int N_length1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_GreaterOrEqual<P_numtype1, complex<T2>  > > >
operator>=(const TinyVector<P_numtype1, N_length1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_GreaterOrEqual<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>,
      _bz_GreaterOrEqual<int, P_numtype2 > > >
operator>=(int d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>, 
      _bz_GreaterOrEqual<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>,
      _bz_GreaterOrEqual<int, typename  P_expr2::T_numtype > > >
operator>=(int d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>, 
      _bz_GreaterOrEqual<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>,
      _bz_GreaterOrEqual<int, P_numtype2 > > >
operator>=(int d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_GreaterOrEqual<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_GreaterOrEqual<int, P_numtype2 > > >
operator>=(int d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_GreaterOrEqual<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorIterConst<P_numtype2>,
      _bz_GreaterOrEqual<float, P_numtype2 > > >
operator>=(float d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorIterConst<P_numtype2>, 
      _bz_GreaterOrEqual<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      _bz_VecExpr<P_expr2>,
      _bz_GreaterOrEqual<float, typename  P_expr2::T_numtype > > >
operator>=(float d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      _bz_VecExpr<P_expr2>, 
      _bz_GreaterOrEqual<float, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorPickIterConst<P_numtype2>,
      _bz_GreaterOrEqual<float, P_numtype2 > > >
operator>=(float d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_GreaterOrEqual<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      Range,
      _bz_GreaterOrEqual<float, int > > >
operator>=(float d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      Range, 
      _bz_GreaterOrEqual<float, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_GreaterOrEqual<float, P_numtype2 > > >
operator>=(float d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_GreaterOrEqual<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorIterConst<P_numtype2>,
      _bz_GreaterOrEqual<double, P_numtype2 > > >
operator>=(double d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorIterConst<P_numtype2>, 
      _bz_GreaterOrEqual<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      _bz_VecExpr<P_expr2>,
      _bz_GreaterOrEqual<double, typename  P_expr2::T_numtype > > >
operator>=(double d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      _bz_VecExpr<P_expr2>, 
      _bz_GreaterOrEqual<double, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorPickIterConst<P_numtype2>,
      _bz_GreaterOrEqual<double, P_numtype2 > > >
operator>=(double d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_GreaterOrEqual<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      Range,
      _bz_GreaterOrEqual<double, int > > >
operator>=(double d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      Range, 
      _bz_GreaterOrEqual<double, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_GreaterOrEqual<double, P_numtype2 > > >
operator>=(double d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_GreaterOrEqual<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorIterConst<P_numtype2>,
      _bz_GreaterOrEqual<long double, P_numtype2 > > >
operator>=(long double d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorIterConst<P_numtype2>, 
      _bz_GreaterOrEqual<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      _bz_VecExpr<P_expr2>,
      _bz_GreaterOrEqual<long double, typename  P_expr2::T_numtype > > >
operator>=(long double d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      _bz_VecExpr<P_expr2>, 
      _bz_GreaterOrEqual<long double, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorPickIterConst<P_numtype2>,
      _bz_GreaterOrEqual<long double, P_numtype2 > > >
operator>=(long double d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_GreaterOrEqual<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      Range,
      _bz_GreaterOrEqual<long double, int > > >
operator>=(long double d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      Range, 
      _bz_GreaterOrEqual<long double, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_GreaterOrEqual<long double, P_numtype2 > > >
operator>=(long double d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_GreaterOrEqual<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}


 
template<class T1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorIterConst<P_numtype2>,
      _bz_GreaterOrEqual<complex<T1> , P_numtype2 > > >
operator>=(complex<T1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorIterConst<P_numtype2>, 
      _bz_GreaterOrEqual<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}




 
template<class T1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      _bz_VecExpr<P_expr2>,
      _bz_GreaterOrEqual<complex<T1> , typename  P_expr2::T_numtype > > >
operator>=(complex<T1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      _bz_VecExpr<P_expr2>, 
      _bz_GreaterOrEqual<complex<T1> , typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2));
}




 
template<class T1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorPickIterConst<P_numtype2>,
      _bz_GreaterOrEqual<complex<T1> , P_numtype2 > > >
operator>=(complex<T1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorPickIterConst<P_numtype2>, 
      _bz_GreaterOrEqual<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}




 
template<class T1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      Range,
      _bz_GreaterOrEqual<complex<T1> , int > > >
operator>=(complex<T1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      Range, 
      _bz_GreaterOrEqual<complex<T1> , int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2));
}




 
template<class T1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_GreaterOrEqual<complex<T1> , P_numtype2 > > >
operator>=(complex<T1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_GreaterOrEqual<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}


 



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_LessOrEqual<P_numtype1, P_numtype2 > > >
operator<=(const Vector<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_LessOrEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_LessOrEqual<P_numtype1, typename  P_expr2::T_numtype > > >
operator<=(const Vector<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_LessOrEqual<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_LessOrEqual<P_numtype1, P_numtype2 > > >
operator<=(const Vector<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_LessOrEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range,
      _bz_LessOrEqual<P_numtype1, int > > >
operator<=(const Vector<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range, 
      _bz_LessOrEqual<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_LessOrEqual<P_numtype1, P_numtype2 > > >
operator<=(const Vector<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_LessOrEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_LessOrEqual<P_numtype1, int > > >
operator<=(const Vector<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_LessOrEqual<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>,
      _bz_LessOrEqual<P_numtype1, float > > >
operator<=(const Vector<P_numtype1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>, 
      _bz_LessOrEqual<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>,
      _bz_LessOrEqual<P_numtype1, double > > >
operator<=(const Vector<P_numtype1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>, 
      _bz_LessOrEqual<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>,
      _bz_LessOrEqual<P_numtype1, long double > > >
operator<=(const Vector<P_numtype1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>, 
      _bz_LessOrEqual<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_LessOrEqual<P_numtype1, complex<T2>  > > >
operator<=(const Vector<P_numtype1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_LessOrEqual<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>,
      _bz_LessOrEqual< typename  P_expr1::T_numtype, P_numtype2 > > >
operator<=(_bz_VecExpr<P_expr1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>, 
      _bz_LessOrEqual< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>,
      _bz_LessOrEqual< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype > > >
operator<=(_bz_VecExpr<P_expr1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_LessOrEqual< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_LessOrEqual< typename  P_expr1::T_numtype, P_numtype2 > > >
operator<=(_bz_VecExpr<P_expr1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_LessOrEqual< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range,
      _bz_LessOrEqual< typename  P_expr1::T_numtype, int > > >
operator<=(_bz_VecExpr<P_expr1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range, 
      _bz_LessOrEqual< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_LessOrEqual< typename  P_expr1::T_numtype, P_numtype2 > > >
operator<=(_bz_VecExpr<P_expr1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_LessOrEqual< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>,
      _bz_LessOrEqual< typename  P_expr1::T_numtype, int > > >
operator<=(_bz_VecExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>, 
      _bz_LessOrEqual< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<float>,
      _bz_LessOrEqual< typename  P_expr1::T_numtype, float > > >
operator<=(_bz_VecExpr<P_expr1> d1, 
      float d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<float>, 
      _bz_LessOrEqual< typename  P_expr1::T_numtype, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<double>,
      _bz_LessOrEqual< typename  P_expr1::T_numtype, double > > >
operator<=(_bz_VecExpr<P_expr1> d1, 
      double d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<double>, 
      _bz_LessOrEqual< typename  P_expr1::T_numtype, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<long double>,
      _bz_LessOrEqual< typename  P_expr1::T_numtype, long double > > >
operator<=(_bz_VecExpr<P_expr1> d1, 
      long double d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<long double>, 
      _bz_LessOrEqual< typename  P_expr1::T_numtype, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_expr1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_LessOrEqual< typename  P_expr1::T_numtype, complex<T2>  > > >
operator<=(_bz_VecExpr<P_expr1> d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_LessOrEqual< typename  P_expr1::T_numtype, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_LessOrEqual<P_numtype1, P_numtype2 > > >
operator<=(const VectorPick<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_LessOrEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_LessOrEqual<P_numtype1, typename  P_expr2::T_numtype > > >
operator<=(const VectorPick<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_LessOrEqual<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_LessOrEqual<P_numtype1, P_numtype2 > > >
operator<=(const VectorPick<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_LessOrEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range,
      _bz_LessOrEqual<P_numtype1, int > > >
operator<=(const VectorPick<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range, 
      _bz_LessOrEqual<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_LessOrEqual<P_numtype1, P_numtype2 > > >
operator<=(const VectorPick<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_LessOrEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_LessOrEqual<P_numtype1, int > > >
operator<=(const VectorPick<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_LessOrEqual<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>,
      _bz_LessOrEqual<P_numtype1, float > > >
operator<=(const VectorPick<P_numtype1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>, 
      _bz_LessOrEqual<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>,
      _bz_LessOrEqual<P_numtype1, double > > >
operator<=(const VectorPick<P_numtype1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>, 
      _bz_LessOrEqual<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>,
      _bz_LessOrEqual<P_numtype1, long double > > >
operator<=(const VectorPick<P_numtype1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>, 
      _bz_LessOrEqual<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_LessOrEqual<P_numtype1, complex<T2>  > > >
operator<=(const VectorPick<P_numtype1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_LessOrEqual<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>,
      _bz_LessOrEqual<int, P_numtype2 > > >
operator<=(Range d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>, 
      _bz_LessOrEqual<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>,
      _bz_LessOrEqual<int, typename  P_expr2::T_numtype > > >
operator<=(Range d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>, 
      _bz_LessOrEqual<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>,
      _bz_LessOrEqual<int, P_numtype2 > > >
operator<=(Range d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>, 
      _bz_LessOrEqual<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      Range,
      _bz_LessOrEqual<int, int > > >
operator<=(Range d1, 
      Range d2)
{
    typedef _bz_VecExprOp<Range, 
      Range, 
      _bz_LessOrEqual<int, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_LessOrEqual<int, P_numtype2 > > >
operator<=(Range d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_LessOrEqual<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<float>,
      _bz_LessOrEqual<int, float > > >
operator<=(Range d1, 
      float d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<float>, 
      _bz_LessOrEqual<int, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<float>(d2)));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<double>,
      _bz_LessOrEqual<int, double > > >
operator<=(Range d1, 
      double d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<double>, 
      _bz_LessOrEqual<int, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<double>(d2)));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<long double>,
      _bz_LessOrEqual<int, long double > > >
operator<=(Range d1, 
      long double d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<long double>, 
      _bz_LessOrEqual<int, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class T2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_LessOrEqual<int, complex<T2>  > > >
operator<=(Range d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_LessOrEqual<int, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>,
      _bz_LessOrEqual<P_numtype1, P_numtype2 > > >
operator<=(const TinyVector<P_numtype1, N_length1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>, 
      _bz_LessOrEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>,
      _bz_LessOrEqual<P_numtype1, typename  P_expr2::T_numtype > > >
operator<=(const TinyVector<P_numtype1, N_length1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_LessOrEqual<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_LessOrEqual<P_numtype1, P_numtype2 > > >
operator<=(const TinyVector<P_numtype1, N_length1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_LessOrEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range,
      _bz_LessOrEqual<P_numtype1, int > > >
operator<=(const TinyVector<P_numtype1, N_length1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range, 
      _bz_LessOrEqual<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_LessOrEqual<P_numtype1, P_numtype2 > > >
operator<=(const TinyVector<P_numtype1, N_length1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_LessOrEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>,
      _bz_LessOrEqual<P_numtype1, int > > >
operator<=(const TinyVector<P_numtype1, N_length1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>, 
      _bz_LessOrEqual<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<float>,
      _bz_LessOrEqual<P_numtype1, float > > >
operator<=(const TinyVector<P_numtype1, N_length1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<float>, 
      _bz_LessOrEqual<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<double>,
      _bz_LessOrEqual<P_numtype1, double > > >
operator<=(const TinyVector<P_numtype1, N_length1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<double>, 
      _bz_LessOrEqual<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<long double>,
      _bz_LessOrEqual<P_numtype1, long double > > >
operator<=(const TinyVector<P_numtype1, N_length1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<long double>, 
      _bz_LessOrEqual<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, int N_length1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_LessOrEqual<P_numtype1, complex<T2>  > > >
operator<=(const TinyVector<P_numtype1, N_length1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_LessOrEqual<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>,
      _bz_LessOrEqual<int, P_numtype2 > > >
operator<=(int d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>, 
      _bz_LessOrEqual<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>,
      _bz_LessOrEqual<int, typename  P_expr2::T_numtype > > >
operator<=(int d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>, 
      _bz_LessOrEqual<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>,
      _bz_LessOrEqual<int, P_numtype2 > > >
operator<=(int d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_LessOrEqual<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_LessOrEqual<int, P_numtype2 > > >
operator<=(int d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_LessOrEqual<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorIterConst<P_numtype2>,
      _bz_LessOrEqual<float, P_numtype2 > > >
operator<=(float d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorIterConst<P_numtype2>, 
      _bz_LessOrEqual<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      _bz_VecExpr<P_expr2>,
      _bz_LessOrEqual<float, typename  P_expr2::T_numtype > > >
operator<=(float d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      _bz_VecExpr<P_expr2>, 
      _bz_LessOrEqual<float, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorPickIterConst<P_numtype2>,
      _bz_LessOrEqual<float, P_numtype2 > > >
operator<=(float d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_LessOrEqual<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      Range,
      _bz_LessOrEqual<float, int > > >
operator<=(float d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      Range, 
      _bz_LessOrEqual<float, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_LessOrEqual<float, P_numtype2 > > >
operator<=(float d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_LessOrEqual<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorIterConst<P_numtype2>,
      _bz_LessOrEqual<double, P_numtype2 > > >
operator<=(double d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorIterConst<P_numtype2>, 
      _bz_LessOrEqual<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      _bz_VecExpr<P_expr2>,
      _bz_LessOrEqual<double, typename  P_expr2::T_numtype > > >
operator<=(double d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      _bz_VecExpr<P_expr2>, 
      _bz_LessOrEqual<double, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorPickIterConst<P_numtype2>,
      _bz_LessOrEqual<double, P_numtype2 > > >
operator<=(double d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_LessOrEqual<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      Range,
      _bz_LessOrEqual<double, int > > >
operator<=(double d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      Range, 
      _bz_LessOrEqual<double, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_LessOrEqual<double, P_numtype2 > > >
operator<=(double d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_LessOrEqual<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorIterConst<P_numtype2>,
      _bz_LessOrEqual<long double, P_numtype2 > > >
operator<=(long double d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorIterConst<P_numtype2>, 
      _bz_LessOrEqual<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      _bz_VecExpr<P_expr2>,
      _bz_LessOrEqual<long double, typename  P_expr2::T_numtype > > >
operator<=(long double d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      _bz_VecExpr<P_expr2>, 
      _bz_LessOrEqual<long double, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorPickIterConst<P_numtype2>,
      _bz_LessOrEqual<long double, P_numtype2 > > >
operator<=(long double d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_LessOrEqual<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      Range,
      _bz_LessOrEqual<long double, int > > >
operator<=(long double d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      Range, 
      _bz_LessOrEqual<long double, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_LessOrEqual<long double, P_numtype2 > > >
operator<=(long double d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_LessOrEqual<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}


 
template<class T1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorIterConst<P_numtype2>,
      _bz_LessOrEqual<complex<T1> , P_numtype2 > > >
operator<=(complex<T1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorIterConst<P_numtype2>, 
      _bz_LessOrEqual<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}




 
template<class T1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      _bz_VecExpr<P_expr2>,
      _bz_LessOrEqual<complex<T1> , typename  P_expr2::T_numtype > > >
operator<=(complex<T1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      _bz_VecExpr<P_expr2>, 
      _bz_LessOrEqual<complex<T1> , typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2));
}




 
template<class T1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorPickIterConst<P_numtype2>,
      _bz_LessOrEqual<complex<T1> , P_numtype2 > > >
operator<=(complex<T1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorPickIterConst<P_numtype2>, 
      _bz_LessOrEqual<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}




 
template<class T1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      Range,
      _bz_LessOrEqual<complex<T1> , int > > >
operator<=(complex<T1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      Range, 
      _bz_LessOrEqual<complex<T1> , int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2));
}




 
template<class T1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_LessOrEqual<complex<T1> , P_numtype2 > > >
operator<=(complex<T1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_LessOrEqual<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}


 



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_Equal<P_numtype1, P_numtype2 > > >
operator==(const Vector<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Equal<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Equal<P_numtype1, typename  P_expr2::T_numtype > > >
operator==(const Vector<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Equal<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Equal<P_numtype1, P_numtype2 > > >
operator==(const Vector<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Equal<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range,
      _bz_Equal<P_numtype1, int > > >
operator==(const Vector<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range, 
      _bz_Equal<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Equal<P_numtype1, P_numtype2 > > >
operator==(const Vector<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Equal<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_Equal<P_numtype1, int > > >
operator==(const Vector<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_Equal<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>,
      _bz_Equal<P_numtype1, float > > >
operator==(const Vector<P_numtype1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>, 
      _bz_Equal<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>,
      _bz_Equal<P_numtype1, double > > >
operator==(const Vector<P_numtype1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>, 
      _bz_Equal<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>,
      _bz_Equal<P_numtype1, long double > > >
operator==(const Vector<P_numtype1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Equal<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Equal<P_numtype1, complex<T2>  > > >
operator==(const Vector<P_numtype1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Equal<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>,
      _bz_Equal< typename  P_expr1::T_numtype, P_numtype2 > > >
operator==(_bz_VecExpr<P_expr1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Equal< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Equal< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype > > >
operator==(_bz_VecExpr<P_expr1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Equal< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Equal< typename  P_expr1::T_numtype, P_numtype2 > > >
operator==(_bz_VecExpr<P_expr1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Equal< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range,
      _bz_Equal< typename  P_expr1::T_numtype, int > > >
operator==(_bz_VecExpr<P_expr1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range, 
      _bz_Equal< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Equal< typename  P_expr1::T_numtype, P_numtype2 > > >
operator==(_bz_VecExpr<P_expr1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Equal< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>,
      _bz_Equal< typename  P_expr1::T_numtype, int > > >
operator==(_bz_VecExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>, 
      _bz_Equal< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<float>,
      _bz_Equal< typename  P_expr1::T_numtype, float > > >
operator==(_bz_VecExpr<P_expr1> d1, 
      float d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<float>, 
      _bz_Equal< typename  P_expr1::T_numtype, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<double>,
      _bz_Equal< typename  P_expr1::T_numtype, double > > >
operator==(_bz_VecExpr<P_expr1> d1, 
      double d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<double>, 
      _bz_Equal< typename  P_expr1::T_numtype, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<long double>,
      _bz_Equal< typename  P_expr1::T_numtype, long double > > >
operator==(_bz_VecExpr<P_expr1> d1, 
      long double d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Equal< typename  P_expr1::T_numtype, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_expr1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Equal< typename  P_expr1::T_numtype, complex<T2>  > > >
operator==(_bz_VecExpr<P_expr1> d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Equal< typename  P_expr1::T_numtype, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_Equal<P_numtype1, P_numtype2 > > >
operator==(const VectorPick<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Equal<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Equal<P_numtype1, typename  P_expr2::T_numtype > > >
operator==(const VectorPick<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Equal<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Equal<P_numtype1, P_numtype2 > > >
operator==(const VectorPick<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Equal<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range,
      _bz_Equal<P_numtype1, int > > >
operator==(const VectorPick<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range, 
      _bz_Equal<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Equal<P_numtype1, P_numtype2 > > >
operator==(const VectorPick<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Equal<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_Equal<P_numtype1, int > > >
operator==(const VectorPick<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_Equal<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>,
      _bz_Equal<P_numtype1, float > > >
operator==(const VectorPick<P_numtype1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>, 
      _bz_Equal<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>,
      _bz_Equal<P_numtype1, double > > >
operator==(const VectorPick<P_numtype1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>, 
      _bz_Equal<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>,
      _bz_Equal<P_numtype1, long double > > >
operator==(const VectorPick<P_numtype1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Equal<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Equal<P_numtype1, complex<T2>  > > >
operator==(const VectorPick<P_numtype1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Equal<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>,
      _bz_Equal<int, P_numtype2 > > >
operator==(Range d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>, 
      _bz_Equal<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>,
      _bz_Equal<int, typename  P_expr2::T_numtype > > >
operator==(Range d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>, 
      _bz_Equal<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>,
      _bz_Equal<int, P_numtype2 > > >
operator==(Range d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Equal<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      Range,
      _bz_Equal<int, int > > >
operator==(Range d1, 
      Range d2)
{
    typedef _bz_VecExprOp<Range, 
      Range, 
      _bz_Equal<int, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Equal<int, P_numtype2 > > >
operator==(Range d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Equal<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<float>,
      _bz_Equal<int, float > > >
operator==(Range d1, 
      float d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<float>, 
      _bz_Equal<int, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<float>(d2)));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<double>,
      _bz_Equal<int, double > > >
operator==(Range d1, 
      double d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<double>, 
      _bz_Equal<int, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<double>(d2)));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<long double>,
      _bz_Equal<int, long double > > >
operator==(Range d1, 
      long double d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<long double>, 
      _bz_Equal<int, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class T2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Equal<int, complex<T2>  > > >
operator==(Range d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Equal<int, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>,
      _bz_Equal<P_numtype1, P_numtype2 > > >
operator==(const TinyVector<P_numtype1, N_length1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>, 
      _bz_Equal<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>,
      _bz_Equal<P_numtype1, typename  P_expr2::T_numtype > > >
operator==(const TinyVector<P_numtype1, N_length1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Equal<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Equal<P_numtype1, P_numtype2 > > >
operator==(const TinyVector<P_numtype1, N_length1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Equal<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range,
      _bz_Equal<P_numtype1, int > > >
operator==(const TinyVector<P_numtype1, N_length1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range, 
      _bz_Equal<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Equal<P_numtype1, P_numtype2 > > >
operator==(const TinyVector<P_numtype1, N_length1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Equal<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>,
      _bz_Equal<P_numtype1, int > > >
operator==(const TinyVector<P_numtype1, N_length1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>, 
      _bz_Equal<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<float>,
      _bz_Equal<P_numtype1, float > > >
operator==(const TinyVector<P_numtype1, N_length1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<float>, 
      _bz_Equal<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<double>,
      _bz_Equal<P_numtype1, double > > >
operator==(const TinyVector<P_numtype1, N_length1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<double>, 
      _bz_Equal<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<long double>,
      _bz_Equal<P_numtype1, long double > > >
operator==(const TinyVector<P_numtype1, N_length1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<long double>, 
      _bz_Equal<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, int N_length1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_Equal<P_numtype1, complex<T2>  > > >
operator==(const TinyVector<P_numtype1, N_length1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_Equal<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>,
      _bz_Equal<int, P_numtype2 > > >
operator==(int d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>, 
      _bz_Equal<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>,
      _bz_Equal<int, typename  P_expr2::T_numtype > > >
operator==(int d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Equal<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Equal<int, P_numtype2 > > >
operator==(int d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Equal<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Equal<int, P_numtype2 > > >
operator==(int d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Equal<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorIterConst<P_numtype2>,
      _bz_Equal<float, P_numtype2 > > >
operator==(float d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorIterConst<P_numtype2>, 
      _bz_Equal<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      _bz_VecExpr<P_expr2>,
      _bz_Equal<float, typename  P_expr2::T_numtype > > >
operator==(float d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Equal<float, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Equal<float, P_numtype2 > > >
operator==(float d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Equal<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      Range,
      _bz_Equal<float, int > > >
operator==(float d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      Range, 
      _bz_Equal<float, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Equal<float, P_numtype2 > > >
operator==(float d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Equal<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorIterConst<P_numtype2>,
      _bz_Equal<double, P_numtype2 > > >
operator==(double d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorIterConst<P_numtype2>, 
      _bz_Equal<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      _bz_VecExpr<P_expr2>,
      _bz_Equal<double, typename  P_expr2::T_numtype > > >
operator==(double d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Equal<double, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Equal<double, P_numtype2 > > >
operator==(double d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Equal<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      Range,
      _bz_Equal<double, int > > >
operator==(double d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      Range, 
      _bz_Equal<double, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Equal<double, P_numtype2 > > >
operator==(double d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Equal<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorIterConst<P_numtype2>,
      _bz_Equal<long double, P_numtype2 > > >
operator==(long double d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorIterConst<P_numtype2>, 
      _bz_Equal<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      _bz_VecExpr<P_expr2>,
      _bz_Equal<long double, typename  P_expr2::T_numtype > > >
operator==(long double d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      _bz_VecExpr<P_expr2>, 
      _bz_Equal<long double, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorPickIterConst<P_numtype2>,
      _bz_Equal<long double, P_numtype2 > > >
operator==(long double d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_Equal<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      Range,
      _bz_Equal<long double, int > > >
operator==(long double d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      Range, 
      _bz_Equal<long double, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Equal<long double, P_numtype2 > > >
operator==(long double d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Equal<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}


 
template<class T1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorIterConst<P_numtype2>,
      _bz_Equal<complex<T1> , P_numtype2 > > >
operator==(complex<T1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorIterConst<P_numtype2>, 
      _bz_Equal<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}




 
template<class T1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      _bz_VecExpr<P_expr2>,
      _bz_Equal<complex<T1> , typename  P_expr2::T_numtype > > >
operator==(complex<T1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      _bz_VecExpr<P_expr2>, 
      _bz_Equal<complex<T1> , typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2));
}




 
template<class T1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorPickIterConst<P_numtype2>,
      _bz_Equal<complex<T1> , P_numtype2 > > >
operator==(complex<T1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorPickIterConst<P_numtype2>, 
      _bz_Equal<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}




 
template<class T1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      Range,
      _bz_Equal<complex<T1> , int > > >
operator==(complex<T1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      Range, 
      _bz_Equal<complex<T1> , int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2));
}




 
template<class T1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_Equal<complex<T1> , P_numtype2 > > >
operator==(complex<T1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_Equal<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}


 



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_NotEqual<P_numtype1, P_numtype2 > > >
operator!=(const Vector<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_NotEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_NotEqual<P_numtype1, typename  P_expr2::T_numtype > > >
operator!=(const Vector<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_NotEqual<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_NotEqual<P_numtype1, P_numtype2 > > >
operator!=(const Vector<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_NotEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range,
      _bz_NotEqual<P_numtype1, int > > >
operator!=(const Vector<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range, 
      _bz_NotEqual<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_NotEqual<P_numtype1, P_numtype2 > > >
operator!=(const Vector<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_NotEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_NotEqual<P_numtype1, int > > >
operator!=(const Vector<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_NotEqual<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>,
      _bz_NotEqual<P_numtype1, float > > >
operator!=(const Vector<P_numtype1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>, 
      _bz_NotEqual<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>,
      _bz_NotEqual<P_numtype1, double > > >
operator!=(const Vector<P_numtype1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>, 
      _bz_NotEqual<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>,
      _bz_NotEqual<P_numtype1, long double > > >
operator!=(const Vector<P_numtype1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>, 
      _bz_NotEqual<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_NotEqual<P_numtype1, complex<T2>  > > >
operator!=(const Vector<P_numtype1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_NotEqual<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>,
      _bz_NotEqual< typename  P_expr1::T_numtype, P_numtype2 > > >
operator!=(_bz_VecExpr<P_expr1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>, 
      _bz_NotEqual< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>,
      _bz_NotEqual< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype > > >
operator!=(_bz_VecExpr<P_expr1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_NotEqual< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_NotEqual< typename  P_expr1::T_numtype, P_numtype2 > > >
operator!=(_bz_VecExpr<P_expr1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_NotEqual< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range,
      _bz_NotEqual< typename  P_expr1::T_numtype, int > > >
operator!=(_bz_VecExpr<P_expr1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range, 
      _bz_NotEqual< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_NotEqual< typename  P_expr1::T_numtype, P_numtype2 > > >
operator!=(_bz_VecExpr<P_expr1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_NotEqual< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>,
      _bz_NotEqual< typename  P_expr1::T_numtype, int > > >
operator!=(_bz_VecExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>, 
      _bz_NotEqual< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<float>,
      _bz_NotEqual< typename  P_expr1::T_numtype, float > > >
operator!=(_bz_VecExpr<P_expr1> d1, 
      float d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<float>, 
      _bz_NotEqual< typename  P_expr1::T_numtype, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<double>,
      _bz_NotEqual< typename  P_expr1::T_numtype, double > > >
operator!=(_bz_VecExpr<P_expr1> d1, 
      double d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<double>, 
      _bz_NotEqual< typename  P_expr1::T_numtype, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<long double>,
      _bz_NotEqual< typename  P_expr1::T_numtype, long double > > >
operator!=(_bz_VecExpr<P_expr1> d1, 
      long double d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<long double>, 
      _bz_NotEqual< typename  P_expr1::T_numtype, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_expr1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_NotEqual< typename  P_expr1::T_numtype, complex<T2>  > > >
operator!=(_bz_VecExpr<P_expr1> d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_NotEqual< typename  P_expr1::T_numtype, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_NotEqual<P_numtype1, P_numtype2 > > >
operator!=(const VectorPick<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_NotEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_NotEqual<P_numtype1, typename  P_expr2::T_numtype > > >
operator!=(const VectorPick<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_NotEqual<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_NotEqual<P_numtype1, P_numtype2 > > >
operator!=(const VectorPick<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_NotEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range,
      _bz_NotEqual<P_numtype1, int > > >
operator!=(const VectorPick<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range, 
      _bz_NotEqual<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_NotEqual<P_numtype1, P_numtype2 > > >
operator!=(const VectorPick<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_NotEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_NotEqual<P_numtype1, int > > >
operator!=(const VectorPick<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_NotEqual<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>,
      _bz_NotEqual<P_numtype1, float > > >
operator!=(const VectorPick<P_numtype1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<float>, 
      _bz_NotEqual<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>,
      _bz_NotEqual<P_numtype1, double > > >
operator!=(const VectorPick<P_numtype1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<double>, 
      _bz_NotEqual<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>,
      _bz_NotEqual<P_numtype1, long double > > >
operator!=(const VectorPick<P_numtype1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<long double>, 
      _bz_NotEqual<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_NotEqual<P_numtype1, complex<T2>  > > >
operator!=(const VectorPick<P_numtype1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_NotEqual<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>,
      _bz_NotEqual<int, P_numtype2 > > >
operator!=(Range d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>, 
      _bz_NotEqual<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>,
      _bz_NotEqual<int, typename  P_expr2::T_numtype > > >
operator!=(Range d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>, 
      _bz_NotEqual<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>,
      _bz_NotEqual<int, P_numtype2 > > >
operator!=(Range d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>, 
      _bz_NotEqual<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      Range,
      _bz_NotEqual<int, int > > >
operator!=(Range d1, 
      Range d2)
{
    typedef _bz_VecExprOp<Range, 
      Range, 
      _bz_NotEqual<int, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_NotEqual<int, P_numtype2 > > >
operator!=(Range d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_NotEqual<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<float>,
      _bz_NotEqual<int, float > > >
operator!=(Range d1, 
      float d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<float>, 
      _bz_NotEqual<int, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<float>(d2)));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<double>,
      _bz_NotEqual<int, double > > >
operator!=(Range d1, 
      double d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<double>, 
      _bz_NotEqual<int, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<double>(d2)));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<long double>,
      _bz_NotEqual<int, long double > > >
operator!=(Range d1, 
      long double d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<long double>, 
      _bz_NotEqual<int, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class T2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_NotEqual<int, complex<T2>  > > >
operator!=(Range d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_NotEqual<int, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>,
      _bz_NotEqual<P_numtype1, P_numtype2 > > >
operator!=(const TinyVector<P_numtype1, N_length1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>, 
      _bz_NotEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>,
      _bz_NotEqual<P_numtype1, typename  P_expr2::T_numtype > > >
operator!=(const TinyVector<P_numtype1, N_length1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_NotEqual<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_NotEqual<P_numtype1, P_numtype2 > > >
operator!=(const TinyVector<P_numtype1, N_length1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_NotEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range,
      _bz_NotEqual<P_numtype1, int > > >
operator!=(const TinyVector<P_numtype1, N_length1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range, 
      _bz_NotEqual<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_NotEqual<P_numtype1, P_numtype2 > > >
operator!=(const TinyVector<P_numtype1, N_length1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_NotEqual<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>,
      _bz_NotEqual<P_numtype1, int > > >
operator!=(const TinyVector<P_numtype1, N_length1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>, 
      _bz_NotEqual<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<float>,
      _bz_NotEqual<P_numtype1, float > > >
operator!=(const TinyVector<P_numtype1, N_length1>& d1, 
      float d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<float>, 
      _bz_NotEqual<P_numtype1, float> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<float>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<double>,
      _bz_NotEqual<P_numtype1, double > > >
operator!=(const TinyVector<P_numtype1, N_length1>& d1, 
      double d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<double>, 
      _bz_NotEqual<P_numtype1, double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<double>(d2)));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<long double>,
      _bz_NotEqual<P_numtype1, long double > > >
operator!=(const TinyVector<P_numtype1, N_length1>& d1, 
      long double d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<long double>, 
      _bz_NotEqual<P_numtype1, long double> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<long double>(d2)));
}


 
template<class P_numtype1, int N_length1, class T2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<complex<T2> > ,
      _bz_NotEqual<P_numtype1, complex<T2>  > > >
operator!=(const TinyVector<P_numtype1, N_length1>& d1, 
      complex<T2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<complex<T2> > , 
      _bz_NotEqual<P_numtype1, complex<T2> > > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<complex<T2> > (d2)));
}



 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>,
      _bz_NotEqual<int, P_numtype2 > > >
operator!=(int d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>, 
      _bz_NotEqual<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>,
      _bz_NotEqual<int, typename  P_expr2::T_numtype > > >
operator!=(int d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>, 
      _bz_NotEqual<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>,
      _bz_NotEqual<int, P_numtype2 > > >
operator!=(int d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_NotEqual<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_NotEqual<int, P_numtype2 > > >
operator!=(int d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_NotEqual<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorIterConst<P_numtype2>,
      _bz_NotEqual<float, P_numtype2 > > >
operator!=(float d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorIterConst<P_numtype2>, 
      _bz_NotEqual<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      _bz_VecExpr<P_expr2>,
      _bz_NotEqual<float, typename  P_expr2::T_numtype > > >
operator!=(float d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      _bz_VecExpr<P_expr2>, 
      _bz_NotEqual<float, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorPickIterConst<P_numtype2>,
      _bz_NotEqual<float, P_numtype2 > > >
operator!=(float d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_NotEqual<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      Range,
      _bz_NotEqual<float, int > > >
operator!=(float d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      Range, 
      _bz_NotEqual<float, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<float>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_NotEqual<float, P_numtype2 > > >
operator!=(float d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<float>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_NotEqual<float, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<float>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorIterConst<P_numtype2>,
      _bz_NotEqual<double, P_numtype2 > > >
operator!=(double d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorIterConst<P_numtype2>, 
      _bz_NotEqual<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      _bz_VecExpr<P_expr2>,
      _bz_NotEqual<double, typename  P_expr2::T_numtype > > >
operator!=(double d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      _bz_VecExpr<P_expr2>, 
      _bz_NotEqual<double, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorPickIterConst<P_numtype2>,
      _bz_NotEqual<double, P_numtype2 > > >
operator!=(double d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_NotEqual<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      Range,
      _bz_NotEqual<double, int > > >
operator!=(double d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      Range, 
      _bz_NotEqual<double, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<double>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_NotEqual<double, P_numtype2 > > >
operator!=(double d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<double>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_NotEqual<double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<double>(d1), 
      d2.begin()));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorIterConst<P_numtype2>,
      _bz_NotEqual<long double, P_numtype2 > > >
operator!=(long double d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorIterConst<P_numtype2>, 
      _bz_NotEqual<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      _bz_VecExpr<P_expr2>,
      _bz_NotEqual<long double, typename  P_expr2::T_numtype > > >
operator!=(long double d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      _bz_VecExpr<P_expr2>, 
      _bz_NotEqual<long double, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorPickIterConst<P_numtype2>,
      _bz_NotEqual<long double, P_numtype2 > > >
operator!=(long double d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_NotEqual<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      Range,
      _bz_NotEqual<long double, int > > >
operator!=(long double d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      Range, 
      _bz_NotEqual<long double, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<long double>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_NotEqual<long double, P_numtype2 > > >
operator!=(long double d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<long double>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_NotEqual<long double, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<long double>(d1), 
      d2.begin()));
}


 
template<class T1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorIterConst<P_numtype2>,
      _bz_NotEqual<complex<T1> , P_numtype2 > > >
operator!=(complex<T1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorIterConst<P_numtype2>, 
      _bz_NotEqual<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}




 
template<class T1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      _bz_VecExpr<P_expr2>,
      _bz_NotEqual<complex<T1> , typename  P_expr2::T_numtype > > >
operator!=(complex<T1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      _bz_VecExpr<P_expr2>, 
      _bz_NotEqual<complex<T1> , typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2));
}




 
template<class T1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorPickIterConst<P_numtype2>,
      _bz_NotEqual<complex<T1> , P_numtype2 > > >
operator!=(complex<T1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      VectorPickIterConst<P_numtype2>, 
      _bz_NotEqual<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}




 
template<class T1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      Range,
      _bz_NotEqual<complex<T1> , int > > >
operator!=(complex<T1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      Range, 
      _bz_NotEqual<complex<T1> , int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2));
}




 
template<class T1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_NotEqual<complex<T1> , P_numtype2 > > >
operator!=(complex<T1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<complex<T1> > , 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_NotEqual<complex<T1> , P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<complex<T1> > (d1), 
      d2.begin()));
}


 



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_LogicalAnd<P_numtype1, P_numtype2 > > >
operator&&(const Vector<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_LogicalAnd<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_LogicalAnd<P_numtype1, typename  P_expr2::T_numtype > > >
operator&&(const Vector<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_LogicalAnd<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_LogicalAnd<P_numtype1, P_numtype2 > > >
operator&&(const Vector<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_LogicalAnd<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range,
      _bz_LogicalAnd<P_numtype1, int > > >
operator&&(const Vector<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range, 
      _bz_LogicalAnd<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_LogicalAnd<P_numtype1, P_numtype2 > > >
operator&&(const Vector<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_LogicalAnd<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_LogicalAnd<P_numtype1, int > > >
operator&&(const Vector<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_LogicalAnd<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>,
      _bz_LogicalAnd< typename  P_expr1::T_numtype, P_numtype2 > > >
operator&&(_bz_VecExpr<P_expr1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>, 
      _bz_LogicalAnd< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>,
      _bz_LogicalAnd< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype > > >
operator&&(_bz_VecExpr<P_expr1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_LogicalAnd< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_LogicalAnd< typename  P_expr1::T_numtype, P_numtype2 > > >
operator&&(_bz_VecExpr<P_expr1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_LogicalAnd< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range,
      _bz_LogicalAnd< typename  P_expr1::T_numtype, int > > >
operator&&(_bz_VecExpr<P_expr1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range, 
      _bz_LogicalAnd< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_LogicalAnd< typename  P_expr1::T_numtype, P_numtype2 > > >
operator&&(_bz_VecExpr<P_expr1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_LogicalAnd< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>,
      _bz_LogicalAnd< typename  P_expr1::T_numtype, int > > >
operator&&(_bz_VecExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>, 
      _bz_LogicalAnd< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_LogicalAnd<P_numtype1, P_numtype2 > > >
operator&&(const VectorPick<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_LogicalAnd<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_LogicalAnd<P_numtype1, typename  P_expr2::T_numtype > > >
operator&&(const VectorPick<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_LogicalAnd<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_LogicalAnd<P_numtype1, P_numtype2 > > >
operator&&(const VectorPick<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_LogicalAnd<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range,
      _bz_LogicalAnd<P_numtype1, int > > >
operator&&(const VectorPick<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range, 
      _bz_LogicalAnd<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_LogicalAnd<P_numtype1, P_numtype2 > > >
operator&&(const VectorPick<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_LogicalAnd<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_LogicalAnd<P_numtype1, int > > >
operator&&(const VectorPick<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_LogicalAnd<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>,
      _bz_LogicalAnd<int, P_numtype2 > > >
operator&&(Range d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>, 
      _bz_LogicalAnd<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>,
      _bz_LogicalAnd<int, typename  P_expr2::T_numtype > > >
operator&&(Range d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>, 
      _bz_LogicalAnd<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>,
      _bz_LogicalAnd<int, P_numtype2 > > >
operator&&(Range d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>, 
      _bz_LogicalAnd<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      Range,
      _bz_LogicalAnd<int, int > > >
operator&&(Range d1, 
      Range d2)
{
    typedef _bz_VecExprOp<Range, 
      Range, 
      _bz_LogicalAnd<int, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_LogicalAnd<int, P_numtype2 > > >
operator&&(Range d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_LogicalAnd<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>,
      _bz_LogicalAnd<P_numtype1, P_numtype2 > > >
operator&&(const TinyVector<P_numtype1, N_length1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>, 
      _bz_LogicalAnd<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>,
      _bz_LogicalAnd<P_numtype1, typename  P_expr2::T_numtype > > >
operator&&(const TinyVector<P_numtype1, N_length1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_LogicalAnd<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_LogicalAnd<P_numtype1, P_numtype2 > > >
operator&&(const TinyVector<P_numtype1, N_length1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_LogicalAnd<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range,
      _bz_LogicalAnd<P_numtype1, int > > >
operator&&(const TinyVector<P_numtype1, N_length1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range, 
      _bz_LogicalAnd<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_LogicalAnd<P_numtype1, P_numtype2 > > >
operator&&(const TinyVector<P_numtype1, N_length1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_LogicalAnd<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>,
      _bz_LogicalAnd<P_numtype1, int > > >
operator&&(const TinyVector<P_numtype1, N_length1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>, 
      _bz_LogicalAnd<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>,
      _bz_LogicalAnd<int, P_numtype2 > > >
operator&&(int d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>, 
      _bz_LogicalAnd<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>,
      _bz_LogicalAnd<int, typename  P_expr2::T_numtype > > >
operator&&(int d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>, 
      _bz_LogicalAnd<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>,
      _bz_LogicalAnd<int, P_numtype2 > > >
operator&&(int d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_LogicalAnd<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_LogicalAnd<int, P_numtype2 > > >
operator&&(int d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_LogicalAnd<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}
 



 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_LogicalOr<P_numtype1, P_numtype2 > > >
operator||(const Vector<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_LogicalOr<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_LogicalOr<P_numtype1, typename  P_expr2::T_numtype > > >
operator||(const Vector<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_LogicalOr<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_LogicalOr<P_numtype1, P_numtype2 > > >
operator||(const Vector<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_LogicalOr<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range,
      _bz_LogicalOr<P_numtype1, int > > >
operator||(const Vector<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      Range, 
      _bz_LogicalOr<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_LogicalOr<P_numtype1, P_numtype2 > > >
operator||(const Vector<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_LogicalOr<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_LogicalOr<P_numtype1, int > > >
operator||(const Vector<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_LogicalOr<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>,
      _bz_LogicalOr< typename  P_expr1::T_numtype, P_numtype2 > > >
operator||(_bz_VecExpr<P_expr1> d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorIterConst<P_numtype2>, 
      _bz_LogicalOr< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>,
      _bz_LogicalOr< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype > > >
operator||(_bz_VecExpr<P_expr1> d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_LogicalOr< typename  P_expr1::T_numtype, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_LogicalOr< typename  P_expr1::T_numtype, P_numtype2 > > >
operator||(_bz_VecExpr<P_expr1> d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_LogicalOr< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range,
      _bz_LogicalOr< typename  P_expr1::T_numtype, int > > >
operator||(_bz_VecExpr<P_expr1> d1, 
      Range d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      Range, 
      _bz_LogicalOr< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_expr1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_LogicalOr< typename  P_expr1::T_numtype, P_numtype2 > > >
operator||(_bz_VecExpr<P_expr1> d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_LogicalOr< typename  P_expr1::T_numtype, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>,
      _bz_LogicalOr< typename  P_expr1::T_numtype, int > > >
operator||(_bz_VecExpr<P_expr1> d1, 
      int d2)
{
    typedef _bz_VecExprOp<_bz_VecExpr<P_expr1>, 
      _bz_VecExprConstant<int>, 
      _bz_LogicalOr< typename  P_expr1::T_numtype, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>,
      _bz_LogicalOr<P_numtype1, P_numtype2 > > >
operator||(const VectorPick<P_numtype1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorIterConst<P_numtype2>, 
      _bz_LogicalOr<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>,
      _bz_LogicalOr<P_numtype1, typename  P_expr2::T_numtype > > >
operator||(const VectorPick<P_numtype1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_LogicalOr<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_LogicalOr<P_numtype1, P_numtype2 > > >
operator||(const VectorPick<P_numtype1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_LogicalOr<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range,
      _bz_LogicalOr<P_numtype1, int > > >
operator||(const VectorPick<P_numtype1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      Range, 
      _bz_LogicalOr<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_LogicalOr<P_numtype1, P_numtype2 > > >
operator||(const VectorPick<P_numtype1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_LogicalOr<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>,
      _bz_LogicalOr<P_numtype1, int > > >
operator||(const VectorPick<P_numtype1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<VectorPickIterConst<P_numtype1>, 
      _bz_VecExprConstant<int>, 
      _bz_LogicalOr<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>,
      _bz_LogicalOr<int, P_numtype2 > > >
operator||(Range d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorIterConst<P_numtype2>, 
      _bz_LogicalOr<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>,
      _bz_LogicalOr<int, typename  P_expr2::T_numtype > > >
operator||(Range d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<Range, 
      _bz_VecExpr<P_expr2>, 
      _bz_LogicalOr<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>,
      _bz_LogicalOr<int, P_numtype2 > > >
operator||(Range d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      VectorPickIterConst<P_numtype2>, 
      _bz_LogicalOr<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 

inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      Range,
      _bz_LogicalOr<int, int > > >
operator||(Range d1, 
      Range d2)
{
    typedef _bz_VecExprOp<Range, 
      Range, 
      _bz_LogicalOr<int, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_LogicalOr<int, P_numtype2 > > >
operator||(Range d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<Range, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_LogicalOr<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1, 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>,
      _bz_LogicalOr<P_numtype1, P_numtype2 > > >
operator||(const TinyVector<P_numtype1, N_length1>& d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorIterConst<P_numtype2>, 
      _bz_LogicalOr<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1, class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>,
      _bz_LogicalOr<P_numtype1, typename  P_expr2::T_numtype > > >
operator||(const TinyVector<P_numtype1, N_length1>& d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExpr<P_expr2>, 
      _bz_LogicalOr<P_numtype1, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>,
      _bz_LogicalOr<P_numtype1, P_numtype2 > > >
operator||(const TinyVector<P_numtype1, N_length1>& d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_LogicalOr<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range,
      _bz_LogicalOr<P_numtype1, int > > >
operator||(const TinyVector<P_numtype1, N_length1>& d1, 
      Range d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      Range, 
      _bz_LogicalOr<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2));
}

 
template<class P_numtype1, int N_length1, class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_LogicalOr<P_numtype1, P_numtype2 > > >
operator||(const TinyVector<P_numtype1, N_length1>& d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_LogicalOr<P_numtype1, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      d2.begin()));
}

 
template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>,
      _bz_LogicalOr<P_numtype1, int > > >
operator||(const TinyVector<P_numtype1, N_length1>& d1, 
      int d2)
{
    typedef _bz_VecExprOp<TinyVectorIterConst<P_numtype1, N_length1>, 
      _bz_VecExprConstant<int>, 
      _bz_LogicalOr<P_numtype1, int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin(), 
      _bz_VecExprConstant<int>(d2)));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>,
      _bz_LogicalOr<int, P_numtype2 > > >
operator||(int d1, 
      const Vector<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorIterConst<P_numtype2>, 
      _bz_LogicalOr<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_expr2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>,
      _bz_LogicalOr<int, typename  P_expr2::T_numtype > > >
operator||(int d1, 
      _bz_VecExpr<P_expr2> d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      _bz_VecExpr<P_expr2>, 
      _bz_LogicalOr<int, typename  P_expr2::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2));
}

 
template<class P_numtype2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>,
      _bz_LogicalOr<int, P_numtype2 > > >
operator||(int d1, 
      const VectorPick<P_numtype2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      VectorPickIterConst<P_numtype2>, 
      _bz_LogicalOr<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}

 
template<class P_numtype2, int N_length2>
inline
_bz_VecExpr<_bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>,
      _bz_LogicalOr<int, P_numtype2 > > >
operator||(int d1, 
      const TinyVector<P_numtype2, N_length2>& d2)
{
    typedef _bz_VecExprOp<_bz_VecExprConstant<int>, 
      TinyVectorIterConst<P_numtype2, N_length2>, 
      _bz_LogicalOr<int, P_numtype2> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(_bz_VecExprConstant<int>(d1), 
      d2.begin()));
}
} 


# 285 "../blitz/vecexpr.h" 2

# 1 "../blitz/vecuops.cc" 1
 






















 

 
 








namespace  blitz  { 

 



template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_abs<P_numtype1> > >
abs(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_abs<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_abs< typename  P_expr1::T_numtype> > >
abs(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_abs< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_abs<P_numtype1> > >
abs(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_abs<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_abs<int> > >
abs(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_abs<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_abs<P_numtype1> > >
abs(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_abs<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


 



template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_acos<P_numtype1> > >
acos(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_acos<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_acos< typename  P_expr1::T_numtype> > >
acos(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_acos< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_acos<P_numtype1> > >
acos(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_acos<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_acos<int> > >
acos(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_acos<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_acos<P_numtype1> > >
acos(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_acos<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


 




template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_acosh<P_numtype1> > >
acosh(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_acosh<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_acosh< typename  P_expr1::T_numtype> > >
acosh(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_acosh< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_acosh<P_numtype1> > >
acosh(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_acosh<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_acosh<int> > >
acosh(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_acosh<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_acosh<P_numtype1> > >
acosh(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_acosh<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}



 



template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_asin<P_numtype1> > >
asin(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_asin<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_asin< typename  P_expr1::T_numtype> > >
asin(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_asin< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_asin<P_numtype1> > >
asin(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_asin<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_asin<int> > >
asin(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_asin<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_asin<P_numtype1> > >
asin(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_asin<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


 




template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_asinh<P_numtype1> > >
asinh(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_asinh<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_asinh< typename  P_expr1::T_numtype> > >
asinh(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_asinh< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_asinh<P_numtype1> > >
asinh(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_asinh<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_asinh<int> > >
asinh(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_asinh<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_asinh<P_numtype1> > >
asinh(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_asinh<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}



 



template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_atan<P_numtype1> > >
atan(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_atan<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_atan< typename  P_expr1::T_numtype> > >
atan(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_atan< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_atan<P_numtype1> > >
atan(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_atan<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_atan<int> > >
atan(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_atan<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_atan<P_numtype1> > >
atan(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_atan<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


 




template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_atanh<P_numtype1> > >
atanh(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_atanh<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_atanh< typename  P_expr1::T_numtype> > >
atanh(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_atanh< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_atanh<P_numtype1> > >
atanh(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_atanh<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_atanh<int> > >
atanh(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_atanh<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_atanh<P_numtype1> > >
atanh(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_atanh<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}



 



# 564 "../blitz/vecuops.cc"


 




template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_cbrt<P_numtype1> > >
cbrt(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_cbrt<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_cbrt< typename  P_expr1::T_numtype> > >
cbrt(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_cbrt< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_cbrt<P_numtype1> > >
cbrt(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_cbrt<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_cbrt<int> > >
cbrt(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_cbrt<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_cbrt<P_numtype1> > >
cbrt(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_cbrt<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}



 



template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_ceil<P_numtype1> > >
ceil(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_ceil<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_ceil< typename  P_expr1::T_numtype> > >
ceil(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_ceil< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_ceil<P_numtype1> > >
ceil(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_ceil<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_ceil<int> > >
ceil(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_ceil<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_ceil<P_numtype1> > >
ceil(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_ceil<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


 



template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_cos<P_numtype1> > >
cos(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_cos<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_cos< typename  P_expr1::T_numtype> > >
cos(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_cos< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_cos<P_numtype1> > >
cos(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_cos<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_cos<int> > >
cos(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_cos<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_cos<P_numtype1> > >
cos(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_cos<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


 



template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_cosh<P_numtype1> > >
cosh(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_cosh<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_cosh< typename  P_expr1::T_numtype> > >
cosh(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_cosh< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_cosh<P_numtype1> > >
cosh(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_cosh<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_cosh<int> > >
cosh(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_cosh<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_cosh<P_numtype1> > >
cosh(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_cosh<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


 



template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_exp<P_numtype1> > >
exp(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_exp<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_exp< typename  P_expr1::T_numtype> > >
exp(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_exp< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_exp<P_numtype1> > >
exp(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_exp<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_exp<int> > >
exp(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_exp<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_exp<P_numtype1> > >
exp(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_exp<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


 




template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_expm1<P_numtype1> > >
expm1(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_expm1<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_expm1< typename  P_expr1::T_numtype> > >
expm1(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_expm1< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_expm1<P_numtype1> > >
expm1(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_expm1<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_expm1<int> > >
expm1(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_expm1<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_expm1<P_numtype1> > >
expm1(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_expm1<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}



 




template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_erf<P_numtype1> > >
erf(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_erf<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_erf< typename  P_expr1::T_numtype> > >
erf(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_erf< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_erf<P_numtype1> > >
erf(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_erf<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_erf<int> > >
erf(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_erf<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_erf<P_numtype1> > >
erf(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_erf<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}



 




template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_erfc<P_numtype1> > >
erfc(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_erfc<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_erfc< typename  P_expr1::T_numtype> > >
erfc(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_erfc< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_erfc<P_numtype1> > >
erfc(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_erfc<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_erfc<int> > >
erfc(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_erfc<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_erfc<P_numtype1> > >
erfc(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_erfc<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}



 



template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_abs<P_numtype1> > >
fabs(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_abs<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_abs< typename  P_expr1::T_numtype> > >
fabs(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_abs< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_abs<P_numtype1> > >
fabs(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_abs<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_abs<int> > >
fabs(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_abs<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_abs<P_numtype1> > >
fabs(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_abs<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


 



template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_floor<P_numtype1> > >
floor(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_floor<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_floor< typename  P_expr1::T_numtype> > >
floor(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_floor< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_floor<P_numtype1> > >
floor(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_floor<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_floor<int> > >
floor(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_floor<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_floor<P_numtype1> > >
floor(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_floor<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


 



# 1289 "../blitz/vecuops.cc"


 




template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_isnan<P_numtype1> > >
isnan(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_isnan<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_isnan< typename  P_expr1::T_numtype> > >
isnan(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_isnan< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_isnan<P_numtype1> > >
isnan(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_isnan<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_isnan<int> > >
isnan(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_isnan<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_isnan<P_numtype1> > >
isnan(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_isnan<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}



 



# 1423 "../blitz/vecuops.cc"


 




template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_j0<P_numtype1> > >
j0(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_j0<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_j0< typename  P_expr1::T_numtype> > >
j0(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_j0< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_j0<P_numtype1> > >
j0(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_j0<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_j0<int> > >
j0(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_j0<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_j0<P_numtype1> > >
j0(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_j0<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}



 




template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_j1<P_numtype1> > >
j1(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_j1<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_j1< typename  P_expr1::T_numtype> > >
j1(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_j1< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_j1<P_numtype1> > >
j1(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_j1<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_j1<int> > >
j1(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_j1<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_j1<P_numtype1> > >
j1(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_j1<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}



 




template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_lgamma<P_numtype1> > >
lgamma(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_lgamma<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_lgamma< typename  P_expr1::T_numtype> > >
lgamma(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_lgamma< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_lgamma<P_numtype1> > >
lgamma(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_lgamma<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_lgamma<int> > >
lgamma(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_lgamma<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_lgamma<P_numtype1> > >
lgamma(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_lgamma<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}



 



template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_log<P_numtype1> > >
log(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_log<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_log< typename  P_expr1::T_numtype> > >
log(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_log< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_log<P_numtype1> > >
log(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_log<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_log<int> > >
log(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_log<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_log<P_numtype1> > >
log(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_log<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


 




template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_logb<P_numtype1> > >
logb(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_logb<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_logb< typename  P_expr1::T_numtype> > >
logb(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_logb< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_logb<P_numtype1> > >
logb(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_logb<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_logb<int> > >
logb(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_logb<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_logb<P_numtype1> > >
logb(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_logb<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}



 




template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_log1p<P_numtype1> > >
log1p(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_log1p<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_log1p< typename  P_expr1::T_numtype> > >
log1p(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_log1p< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_log1p<P_numtype1> > >
log1p(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_log1p<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_log1p<int> > >
log1p(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_log1p<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_log1p<P_numtype1> > >
log1p(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_log1p<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}



 



template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_log10<P_numtype1> > >
log10(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_log10<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_log10< typename  P_expr1::T_numtype> > >
log10(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_log10< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_log10<P_numtype1> > >
log10(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_log10<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_log10<int> > >
log10(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_log10<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_log10<P_numtype1> > >
log10(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_log10<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


 



# 1955 "../blitz/vecuops.cc"


 




template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_rint<P_numtype1> > >
rint(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_rint<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_rint< typename  P_expr1::T_numtype> > >
rint(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_rint< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_rint<P_numtype1> > >
rint(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_rint<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_rint<int> > >
rint(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_rint<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_rint<P_numtype1> > >
rint(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_rint<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}



 



# 2089 "../blitz/vecuops.cc"


 



template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_sin<P_numtype1> > >
sin(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_sin<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_sin< typename  P_expr1::T_numtype> > >
sin(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_sin< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_sin<P_numtype1> > >
sin(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_sin<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_sin<int> > >
sin(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_sin<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_sin<P_numtype1> > >
sin(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_sin<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


 



template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_sinh<P_numtype1> > >
sinh(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_sinh<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_sinh< typename  P_expr1::T_numtype> > >
sinh(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_sinh< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_sinh<P_numtype1> > >
sinh(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_sinh<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_sinh<int> > >
sinh(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_sinh<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_sinh<P_numtype1> > >
sinh(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_sinh<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


 



template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_sqr<P_numtype1> > >
sqr(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_sqr<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_sqr< typename  P_expr1::T_numtype> > >
sqr(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_sqr< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_sqr<P_numtype1> > >
sqr(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_sqr<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_sqr<int> > >
sqr(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_sqr<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_sqr<P_numtype1> > >
sqr(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_sqr<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


 



template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_sqrt<P_numtype1> > >
sqrt(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_sqrt<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_sqrt< typename  P_expr1::T_numtype> > >
sqrt(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_sqrt< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_sqrt<P_numtype1> > >
sqrt(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_sqrt<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_sqrt<int> > >
sqrt(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_sqrt<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_sqrt<P_numtype1> > >
sqrt(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_sqrt<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


 



template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_tan<P_numtype1> > >
tan(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_tan<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_tan< typename  P_expr1::T_numtype> > >
tan(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_tan< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_tan<P_numtype1> > >
tan(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_tan<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_tan<int> > >
tan(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_tan<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_tan<P_numtype1> > >
tan(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_tan<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


 



template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_tanh<P_numtype1> > >
tanh(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_tanh<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_tanh< typename  P_expr1::T_numtype> > >
tanh(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_tanh< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_tanh<P_numtype1> > >
tanh(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_tanh<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_tanh<int> > >
tanh(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_tanh<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_tanh<P_numtype1> > >
tanh(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_tanh<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


 



# 2546 "../blitz/vecuops.cc"


 




template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_y0<P_numtype1> > >
y0(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_y0<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_y0< typename  P_expr1::T_numtype> > >
y0(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_y0< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_y0<P_numtype1> > >
y0(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_y0<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_y0<int> > >
y0(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_y0<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_y0<P_numtype1> > >
y0(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_y0<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}



 




template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
    _bz_y1<P_numtype1> > >
y1(const Vector<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorIterConst<P_numtype1>,
        _bz_y1<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}

template<class P_expr1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
    _bz_y1< typename  P_expr1::T_numtype> > >
y1(_bz_VecExpr<P_expr1> d1)
{
    typedef _bz_VecExprUnaryOp<_bz_VecExpr<P_expr1>,
        _bz_y1< typename  P_expr1::T_numtype> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
    _bz_y1<P_numtype1> > >
y1(const VectorPick<P_numtype1>& d1)
{
    typedef _bz_VecExprUnaryOp<VectorPickIterConst<P_numtype1>,
        _bz_y1<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}


inline
_bz_VecExpr<_bz_VecExprUnaryOp<Range,
    _bz_y1<int> > >
y1(Range d1)
{
    typedef _bz_VecExprUnaryOp<Range,
        _bz_y1<int> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1));
}

template<class P_numtype1, int N_length1>
inline
_bz_VecExpr<_bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
    _bz_y1<P_numtype1> > >
y1(const TinyVector<P_numtype1, N_length1>& d1)
{
    typedef _bz_VecExprUnaryOp<TinyVectorIterConst<P_numtype1, N_length1>,
        _bz_y1<P_numtype1> > T_expr;

    return _bz_VecExpr<T_expr>(T_expr(d1.begin()));
}



} 


# 286 "../blitz/vecexpr.h" 2

# 1 "../blitz/vecbfn.cc" 1







namespace  blitz  { 

 

} 



# 287 "../blitz/vecexpr.h" 2



# 36 "../blitz/vecpick.cc" 2






namespace  blitz  { 

 



template<class P_numtype> template<class P_expr, class P_updater>
inline
void VectorPick<P_numtype>::_bz_assign(P_expr expr, P_updater)
{
     ;

     
     
     
    if (_bz_hasFastAccess() && expr._bz_hasFastAccess())
    {

        for (int i=0; i < length(); ++i)
            P_updater::update(vector_(index_(i)), expr._bz_fastAccess(i));
# 78 "../blitz/vecpick.cc"

    }
    else {
         
         
        for (int i=0; i < length(); ++i)
            P_updater::update(vector_[index_[i]], expr[i]);
    }
}

template<class P_numtype> template<class P_expr>
inline VectorPick<P_numtype>& 
VectorPick<P_numtype>::operator=(_bz_VecExpr<P_expr> expr)
{
     ;

     
     
     
    if (_bz_hasFastAccess() && expr._bz_hasFastAccess())
    {

        for (int i=0; i < length(); ++i)
            (*this)(i) = expr._bz_fastAccess(i);
# 118 "../blitz/vecpick.cc"

    }
    else {
         
         
        for (int i=0; i < length(); ++i)
            (*this)[i] = expr[i];
    }
    return *this;
}


template<class P_numtype> template<class P_expr>
inline VectorPick<P_numtype>& 
VectorPick<P_numtype>::operator+=(_bz_VecExpr<P_expr> expr)
{
    _bz_assign(expr, _bz_plus_update<P_numtype,
        typename  P_expr::T_numtype>());
    return *this;
}

template<class P_numtype> template<class P_expr>
inline VectorPick<P_numtype>& 
VectorPick<P_numtype>::operator-=(_bz_VecExpr<P_expr> expr)
{
    _bz_assign(expr, _bz_minus_update<P_numtype,
        typename  P_expr::T_numtype>());
    return *this;
}

template<class P_numtype> template<class P_expr>
inline VectorPick<P_numtype>& 
VectorPick<P_numtype>::operator*=(_bz_VecExpr<P_expr> expr)
{
    _bz_assign(expr, _bz_multiply_update<P_numtype,
        typename  P_expr::T_numtype>());
    return *this;
}

template<class P_numtype> template<class P_expr>
inline VectorPick<P_numtype>& 
VectorPick<P_numtype>::operator/=(_bz_VecExpr<P_expr> expr)
{
    _bz_assign(expr, _bz_divide_update<P_numtype,
        typename  P_expr::T_numtype>());
    return *this;
}

template<class P_numtype> template<class P_expr>
inline VectorPick<P_numtype>& 
VectorPick<P_numtype>::operator%=(_bz_VecExpr<P_expr> expr)
{
    _bz_assign(expr, _bz_mod_update<P_numtype,
        typename  P_expr::T_numtype>());
    return *this;
}

template<class P_numtype> template<class P_expr>
inline VectorPick<P_numtype>& 
VectorPick<P_numtype>::operator^=(_bz_VecExpr<P_expr> expr)
{
    _bz_assign(expr, _bz_xor_update<P_numtype,
        typename  P_expr::T_numtype>());
    return *this;
}

template<class P_numtype> template<class P_expr>
inline VectorPick<P_numtype>& 
VectorPick<P_numtype>::operator&=(_bz_VecExpr<P_expr> expr)
{
    _bz_assign(expr, _bz_bitand_update<P_numtype,
        typename  P_expr::T_numtype>());
    return *this;
}

template<class P_numtype> template<class P_expr>
inline VectorPick<P_numtype>& 
VectorPick<P_numtype>::operator|=(_bz_VecExpr<P_expr> expr)
{
    _bz_assign(expr, _bz_bitor_update<P_numtype,
        typename  P_expr::T_numtype>());
    return *this;
}

template<class P_numtype> template<class P_expr>
inline VectorPick<P_numtype>& 
VectorPick<P_numtype>::operator>>=(_bz_VecExpr<P_expr> expr)
{
    _bz_assign(expr, _bz_shiftr_update<P_numtype,
        typename  P_expr::T_numtype>());
    return *this;
}

template<class P_numtype> template<class P_expr>
inline VectorPick<P_numtype>& 
VectorPick<P_numtype>::operator<<=(_bz_VecExpr<P_expr> expr)
{
    _bz_assign(expr, _bz_shiftl_update<P_numtype,
        typename  P_expr::T_numtype>());
    return *this;
}

 



template<class P_numtype>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) = _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator+=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) += _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator-=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) -= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator*=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) *= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator/=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) /= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator%=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) %= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator^=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) ^= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator&=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) &= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator|=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) |= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator>>=(int x)
{
    typedef _bz_VecExprConstant<int> T_expr;
    (*this) >>= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator<<=(int x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) <<= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

 



template<class P_numtype> template<class P_numtype2>
inline VectorPick<P_numtype>& 
VectorPick<P_numtype>::operator=(const Vector<P_numtype2>& x)
{
    (*this) = _bz_VecExpr<VectorIterConst<P_numtype2> >(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline VectorPick<P_numtype>&
VectorPick<P_numtype>::operator+=(const Vector<P_numtype2>& x)
{
    (*this) += _bz_VecExpr<VectorIterConst<P_numtype2> >(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline VectorPick<P_numtype>&
VectorPick<P_numtype>::operator-=(const Vector<P_numtype2>& x)
{
    (*this) -= _bz_VecExpr<VectorIterConst<P_numtype2> >(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline VectorPick<P_numtype>&
VectorPick<P_numtype>::operator*=(const Vector<P_numtype2>& x)
{
    (*this) *= _bz_VecExpr<VectorIterConst<P_numtype2> >(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline VectorPick<P_numtype>&
VectorPick<P_numtype>::operator/=(const Vector<P_numtype2>& x)
{
    (*this) /= _bz_VecExpr<VectorIterConst<P_numtype2> >(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline VectorPick<P_numtype>&
VectorPick<P_numtype>::operator%=(const Vector<P_numtype2>& x)
{
    (*this) %= _bz_VecExpr<VectorIterConst<P_numtype2> >(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline VectorPick<P_numtype>&
VectorPick<P_numtype>::operator^=(const Vector<P_numtype2>& x)
{
    (*this) ^= _bz_VecExpr<VectorIterConst<P_numtype2> >(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline VectorPick<P_numtype>&
VectorPick<P_numtype>::operator&=(const Vector<P_numtype2>& x)
{
    (*this) &= _bz_VecExpr<VectorIterConst<P_numtype2> >(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline VectorPick<P_numtype>&
VectorPick<P_numtype>::operator|=(const Vector<P_numtype2>& x)
{
    (*this) |= _bz_VecExpr<VectorIterConst<P_numtype2> >(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline VectorPick<P_numtype>&
VectorPick<P_numtype>::operator<<=(const Vector<P_numtype2>& x)
{
    (*this) <<= _bz_VecExpr<VectorIterConst<P_numtype2> >(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline VectorPick<P_numtype>&
VectorPick<P_numtype>::operator>>=(const Vector<P_numtype2>& x)
{
    (*this) >>= _bz_VecExpr<VectorIterConst<P_numtype2> >(x.begin());
    return *this;
}

 



template<class P_numtype>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator=(Range r)
{
    (*this) = _bz_VecExpr<Range>(r);
    return *this;
}

template<class P_numtype>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator+=(Range r)
{
    (*this) += _bz_VecExpr<Range>(r);
    return *this;
}

template<class P_numtype>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator-=(Range r)
{
    (*this) -= _bz_VecExpr<Range>(r);
    return *this;
}

template<class P_numtype>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator*=(Range r)
{
    (*this) *= _bz_VecExpr<Range>(r);
    return *this;
}

template<class P_numtype>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator/=(Range r)
{
    (*this) /= _bz_VecExpr<Range>(r);
    return *this;
}

template<class P_numtype>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator%=(Range r)
{
    (*this) %= _bz_VecExpr<Range>(r);
    return *this;
}

template<class P_numtype>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator^=(Range r)
{
    (*this) ^= _bz_VecExpr<Range>(r);
    return *this;
}

template<class P_numtype>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator&=(Range r)
{
    (*this) &= _bz_VecExpr<Range>(r);
    return *this;
}

template<class P_numtype>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator|=(Range r)
{
    (*this) |= _bz_VecExpr<Range>(r);
    return *this;
}

template<class P_numtype>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator>>=(Range r)
{
    (*this) >>= _bz_VecExpr<Range>(r);
    return *this;
}

template<class P_numtype>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator<<=(Range r)
{
    (*this) <<= _bz_VecExpr<Range>(r);
    return *this;
}

 



template<class P_numtype> template<class P_numtype2>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator=(const 
    VectorPick<P_numtype2>& x)
{
    typedef VectorPickIterConst<P_numtype2> T_expr;
    (*this) = _bz_VecExpr<T_expr>(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator+=(const
    VectorPick<P_numtype2>& x)
{
    typedef VectorPickIterConst<P_numtype2> T_expr;
    (*this) += _bz_VecExpr<T_expr>(x.begin());
    return *this;
}


template<class P_numtype> template<class P_numtype2>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator-=(const
    VectorPick<P_numtype2>& x)
{
    typedef VectorPickIterConst<P_numtype2> T_expr;
    (*this) -= _bz_VecExpr<T_expr>(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator*=(const
    VectorPick<P_numtype2>& x)
{
    typedef VectorPickIterConst<P_numtype2> T_expr;
    (*this) *= _bz_VecExpr<T_expr>(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator/=(const
    VectorPick<P_numtype2>& x)
{
    typedef VectorPickIterConst<P_numtype2> T_expr;
    (*this) /= _bz_VecExpr<T_expr>(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator%=(const
    VectorPick<P_numtype2>& x)
{
    typedef VectorPickIterConst<P_numtype2> T_expr;
    (*this) %= _bz_VecExpr<T_expr>(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator^=(const
    VectorPick<P_numtype2>& x)
{
    typedef VectorPickIterConst<P_numtype2> T_expr;
    (*this) ^= _bz_VecExpr<T_expr>(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator&=(const
    VectorPick<P_numtype2>& x)
{
    typedef VectorPickIterConst<P_numtype2> T_expr;
    (*this) &= _bz_VecExpr<T_expr>(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline VectorPick<P_numtype>& VectorPick<P_numtype>::operator|=(const
    VectorPick<P_numtype2>& x)
{
    typedef VectorPickIterConst<P_numtype2> T_expr;
    (*this) |= _bz_VecExpr<T_expr>(x.begin());
    return *this;
}

 



template<class P_numtype> template<class P_distribution>
VectorPick<P_numtype>& 
VectorPick<P_numtype>::operator=(Random<P_distribution>& rand)
{
    (*this) = _bz_VecExpr<_bz_VecExprRandom<P_distribution> > 
        (_bz_VecExprRandom<P_distribution>(rand));
    return *this;
}

template<class P_numtype> template<class P_distribution>
VectorPick<P_numtype>& 
VectorPick<P_numtype>::operator+=(Random<P_distribution>& rand)
{
    (*this) += _bz_VecExpr<_bz_VecExprRandom<P_distribution> >
        (_bz_VecExprRandom<P_distribution>(rand));
    return *this;
}

template<class P_numtype> template<class P_distribution>
VectorPick<P_numtype>& 
VectorPick<P_numtype>::operator-=(Random<P_distribution>& rand)
{
    (*this) -= _bz_VecExpr<_bz_VecExprRandom<P_distribution> >
        (_bz_VecExprRandom<P_distribution>(rand));
    return *this;
}

template<class P_numtype> template<class P_distribution>
VectorPick<P_numtype>& 
VectorPick<P_numtype>::operator*=(Random<P_distribution>& rand)
{
    (*this) *= _bz_VecExpr<_bz_VecExprRandom<P_distribution> >
        (_bz_VecExprRandom<P_distribution>(rand));
    return *this;
}

template<class P_numtype> template<class P_distribution>
VectorPick<P_numtype>& 
VectorPick<P_numtype>::operator/=(Random<P_distribution>& rand)
{
    (*this) /= _bz_VecExpr<_bz_VecExprRandom<P_distribution> >
        (_bz_VecExprRandom<P_distribution>(rand));
    return *this;
}

template<class P_numtype> template<class P_distribution>
VectorPick<P_numtype>& 
VectorPick<P_numtype>::operator%=(Random<P_distribution>& rand)
{
    (*this) %= _bz_VecExpr<_bz_VecExprRandom<P_distribution> >
        (_bz_VecExprRandom<P_distribution>(rand));
    return *this;
}

template<class P_numtype> template<class P_distribution>
VectorPick<P_numtype>& 
VectorPick<P_numtype>::operator^=(Random<P_distribution>& rand)
{
    (*this) ^= _bz_VecExpr<_bz_VecExprRandom<P_distribution> >
        (_bz_VecExprRandom<P_distribution>(rand));
    return *this;
}

template<class P_numtype> template<class P_distribution>
VectorPick<P_numtype>& 
VectorPick<P_numtype>::operator&=(Random<P_distribution>& rand)
{
    (*this) &= _bz_VecExpr<_bz_VecExprRandom<P_distribution> >
        (_bz_VecExprRandom<P_distribution>(rand));
    return *this;
}

template<class P_numtype> template<class P_distribution>
VectorPick<P_numtype>& 
VectorPick<P_numtype>::operator|=(Random<P_distribution>& rand)
{
    (*this) |= _bz_VecExpr<_bz_VecExprRandom<P_distribution> >
        (_bz_VecExprRandom<P_distribution>(rand));
    return *this;
}

} 


# 313 "../blitz/vecpick.h" 2

# 1 "../blitz/vecpickio.cc" 1
 



















namespace  blitz  { 

template<class P_numtype>
ostream& operator<<(ostream& os, const VectorPick<P_numtype>& x)
{
    Vector<P_numtype> y(x.length());
    y = x;
    os << y;
    return os;
}

} 


# 314 "../blitz/vecpick.h" 2

# 1 "../blitz/vecpickiter.h" 1
 


















































namespace  blitz  { 

template<class P_numtype>
class VectorPickIter {

public:
    typedef P_numtype  T_numtype;

    explicit  VectorPickIter(VectorPick<T_numtype>& x)
        : data_(x.vector().data()), index_(x.indexSet().data())
    {
        dataStride_  = x.vector().stride();
        indexStride_ = x.indexSet().stride();
        length_ = x.indexSet().length();
    }


    VectorPickIter(const VectorPickIter<T_numtype>& x)
    {
        data_ = x.data_;
        index_ = x.index_;
        dataStride_ = x.dataStride_;
        indexStride_ = x.indexStride_;
        length_ = x.length_;
    }


    T_numtype operator[](int i) const
    {
         ;
        return data_[dataStride_ * index_[i * indexStride_]];
    }

    T_numtype& operator[](int i)
    {
         ;
        return data_[dataStride_ * index_[i * indexStride_]];
    }

    int length(int) const
    { return length_; }

    int _bz_suggestLength() const
    { return length_; }

    bool  isUnitStride() const
    { return (dataStride_  == 1) && (indexStride_ == 1); }

    bool  _bz_hasFastAccess() const
    { return isUnitStride(); }

    T_numtype _bz_fastAccess(int i) const
    {    
         return data_[index_[i]];
    }

    T_numtype&  _bz_fastAccess(int i)
    {
         return data_[index_[i]];
    }

    enum { _bz_staticLengthCount = 0,
           _bz_dynamicLengthCount = 1,
           _bz_staticLength = 0 };

private:
    T_numtype *   data_;
    int dataStride_;
    const int *   index_;
    int indexStride_;
    int length_;
};

template<class P_numtype>
class VectorPickIterConst {

public:
    typedef P_numtype  T_numtype;

    explicit  VectorPickIterConst(const VectorPick<T_numtype>& x)
        : data_(x.vector().data()), index_(x.indexSet().data())
    {
        dataStride_  = x.vector().stride();
        indexStride_ = x.indexSet().stride();
        length_ = x.indexSet().length();
    }


    VectorPickIterConst(const VectorPickIterConst<T_numtype>& x)
    {
        data_ = x.data_;
        index_ = x.index_;
        dataStride_ = x.dataStride_;
        indexStride_ = x.indexStride_;
        length_ = x.length_;
    }


    T_numtype operator[](int i) const
    {
         ;
        return data_[dataStride_ * index_[i * indexStride_]];
    }

    int length(int) const
    { return length_; }

    int _bz_suggestLength() const
    { return length_; }

    bool  isUnitStride() const
    { return (dataStride_  == 1) && (indexStride_ == 1); }

    bool  _bz_hasFastAccess() const
    { return isUnitStride(); }

    T_numtype _bz_fastAccess(int i) const
    {
         return data_[index_[i]];
    }

    enum { _bz_staticLengthCount = 0,
           _bz_dynamicLengthCount = 1,
           _bz_staticLength = 0 };

private:
    const T_numtype *   data_;
    int dataStride_;
    const int *   index_;
    int indexStride_;
    int length_;
};

} 



# 315 "../blitz/vecpick.h" 2



# 489 "../blitz/vector.h" 2


# 1 "../blitz/vecglobs.h" 1
 























































 
# 1 "../blitz/extremum.h" 1
 














































namespace  blitz  { 

 
 
 
 
 
template<class P_numtype, class P_index>
class Extremum {
public:
    typedef P_numtype T_numtype;
    typedef P_index   T_index;

    Extremum(T_numtype value, T_index index)
        : value_(value), index_(index)
    { }

    T_numtype value() const
    { return value_; }

    T_index index() const
    { return index_; }

    void setValue(T_numtype value)
    { value_ = value; }

    void setIndex(T_index index)
    { index_ = index; }

    operator T_numtype() const
    { return value_; }

protected:
    T_numtype value_;
    T_index index_;
};

} 



# 57 "../blitz/vecglobs.h" 2




namespace  blitz  { 

} 

# 1 "../blitz/vecglobs.cc" 1
 






















# 1 "../blitz/vecaccum.cc" 1
 

























namespace  blitz  { 

template<class P>
inline
Vector< typename  NumericTypeTraits< typename  P::T_numtype >::T_sumtype > _bz_vec_accumulate(P expr)
{
    typedef typename  NumericTypeTraits< typename  P::T_numtype >::T_sumtype  T_sumtype;
    int length = expr._bz_suggestLength();
    Vector<T_sumtype> z(length);
    T_sumtype sum = 0;

    if (expr._bz_hasFastAccess())
    {
        for (int i=0; i < length; ++i)
        {
            sum += expr._bz_fastAccess(i);
            z[i] = sum;
        }
    }
    else {
        for (int i=0; i < length; ++i)
        {
            sum += expr(i);
            z[i] = sum;
        }
    }

    return z;
}
template<class P_numtype>
Vector< typename  NumericTypeTraits< P_numtype >::T_sumtype > accumulate(const Vector<P_numtype>& x)
{
    return _bz_vec_accumulate(x);
}

template<class P_expr>
Vector< typename  NumericTypeTraits< typename  P_expr::T_numtype >::T_sumtype >
accumulate(_bz_VecExpr<P_expr> x)
{
    return _bz_vec_accumulate(x);
}

template<class P_numtype>
Vector< typename  NumericTypeTraits< P_numtype >::T_sumtype > accumulate(const VectorPick<P_numtype>& x)
{
    return _bz_vec_accumulate(x);
}

} 



# 24 "../blitz/vecglobs.cc" 2

# 1 "../blitz/vecdelta.cc" 1
 

























namespace  blitz  { 

template<class P>
inline
Vector< typename  NumericTypeTraits< typename  P::T_numtype >::T_difftype > _bz_vec_delta(P expr)
{
    typedef typename  P::T_numtype   T_numtype;
    typedef typename  NumericTypeTraits< T_numtype >::T_difftype       T_difftype;

    int length = expr._bz_suggestLength();
    Vector<T_difftype> z(length);
    T_numtype currentElement = 0;
    T_numtype previousElement = 0;

    if (expr._bz_hasFastAccess())
    {
        for (int i=0; i < length; ++i)
        {
            currentElement = expr._bz_fastAccess(i);
            z[i] = currentElement - previousElement;
            previousElement = currentElement;
        }
    }
    else {
        for (int i=1; i < length; ++i)
        {
            currentElement = expr(i);
            z[i] = currentElement - previousElement;
            previousElement = currentElement;
        }
    }

    return z;
}

template<class P_numtype>
Vector< typename  NumericTypeTraits< P_numtype >::T_difftype > delta(const Vector<P_numtype>& x)
{
    return _bz_vec_delta(x);
}

 
template<class P_expr>
Vector< typename  NumericTypeTraits< typename  P_expr::T_numtype >::T_difftype > delta(_bz_VecExpr<P_expr> x)
{
    return _bz_vec_delta(x);
}

 
template<class P_numtype>
Vector< typename  NumericTypeTraits< P_numtype >::T_difftype > delta(const VectorPick<P_numtype>& x)
{
    return _bz_vec_delta(x);
}

} 



# 25 "../blitz/vecglobs.cc" 2

# 1 "../blitz/vecmin.cc" 1
 

























namespace  blitz  { 

template<class P_expr>
inline
Extremum< typename  P_expr::T_numtype, int> _bz_vec_min(P_expr vector)
{
    typedef typename  P_expr::T_numtype T_numtype;

    T_numtype minValue = vector(0);
    int minIndex = 0;
    int length = vector._bz_suggestLength();

    if (vector._bz_hasFastAccess())
    {
        for (int i=1; i < length; ++i)
        {
            T_numtype value = vector._bz_fastAccess(i);
            if (value < minValue)
            {
                minValue = value;
                minIndex = i;
            }
        }
    }
    else {
        for (int i=1; i < length; ++i)
        {
            T_numtype value = vector(i);
            if (value < minValue)
            {
                minValue = value;
                minIndex = i;
            }
        }
    }

    return Extremum<T_numtype, int>(minValue, minIndex);
}

 
template<class P_numtype>
inline
Extremum<P_numtype,int> min(const Vector<P_numtype>& x)
{
    return _bz_vec_min(x._bz_asVecExpr());
}

 
template<class P_expr>
inline
Extremum< typename  P_expr::T_numtype,int> min(_bz_VecExpr<P_expr> x)
{
    return _bz_vec_min(x);
}

 
template<class P_numtype>
inline
Extremum<P_numtype, int> min(const VectorPick<P_numtype>& x)
{
    return _bz_vec_min(x._bz_asVecExpr());
}

 
template<class P_numtype, int N_length>
inline
Extremum<P_numtype, int> min(const TinyVector<P_numtype, N_length>& x)
{
    return _bz_vec_min(x._bz_asVecExpr());
}

 
template<class P_numtype>
inline
int  minIndex(const Vector<P_numtype>& x)
{
    return _bz_vec_min(x._bz_asVecExpr()).index();
}

 
template<class P_expr>
inline
int  minIndex(_bz_VecExpr<P_expr> x)
{
    return _bz_vec_min(x).index();
}

 
template<class P_numtype>
int  minIndex(const VectorPick<P_numtype>& x)
{
    return _bz_vec_min(x._bz_asVecExpr()).index();
}

 
template<class P_numtype, int N_length>
int minIndex(const TinyVector<P_numtype, N_length>& x)
{
    return _bz_vec_min(x._bz_asVecExpr()).index();
}

 
template<class P_numtype>
inline
int  minValue(const Vector<P_numtype>& x)
{
    return _bz_vec_min(x._bz_asVecExpr()).value();
}

 
template<class P_expr>
inline
int  minValue(_bz_VecExpr<P_expr> x)
{
    return _bz_vec_min(x).value();
}

 
template<class P_numtype>
int  minValue(const VectorPick<P_numtype>& x)
{
    return _bz_vec_min(x._bz_asVecExpr()).value();
}

 
template<class P_numtype, int N_length>
int  minValue(const TinyVector<P_numtype, N_length>& x)
{
    return _bz_vec_min(x._bz_asVecExpr()).value();
}

} 



# 26 "../blitz/vecglobs.cc" 2

# 1 "../blitz/vecmax.cc" 1
 

























namespace  blitz  { 

template<class P_expr>
inline
Extremum< typename  P_expr::T_numtype, int> _bz_vec_max(P_expr vector)
{
    typedef typename  P_expr::T_numtype T_numtype;

    T_numtype maxValue = vector(0);
    int maxIndex = 0;
    int length = vector._bz_suggestLength();

    if (vector._bz_hasFastAccess())
    {
        for (int i=1; i < length; ++i)
        {
            T_numtype value = vector._bz_fastAccess(i);
            if (value > maxValue)
            {
                maxValue = value;
                maxIndex = i;
            }
        }
    }
    else {
        for (int i=1; i < length; ++i)
        {
            T_numtype value = vector(i);
            if (value > maxValue)
            {
                maxValue = value;
                maxIndex = i;
            }
        }
    }

    return Extremum<T_numtype, int>(maxValue, maxIndex);
}

 
template<class P_numtype>
inline
Extremum<P_numtype, int> max(const Vector<P_numtype>& x)
{
    return _bz_vec_max(x._bz_asVecExpr());
}

 
template<class P_expr>
inline
Extremum< typename  P_expr::T_numtype,int> max(_bz_VecExpr<P_expr> x)
{
    return _bz_vec_max(x);
}

 
template<class P_numtype>
inline
Extremum<P_numtype, int> max(const VectorPick<P_numtype>& x)
{
    return _bz_vec_max(x._bz_asVecExpr());
}

 
template<class P_numtype, int N_length>
inline
Extremum<P_numtype, int>
max(const TinyVector<P_numtype, N_length>& x)
{
    return _bz_vec_max(x._bz_asVecExpr());
}


 
template<class P_numtype>
inline
int  maxIndex(const Vector<P_numtype>& x)
{
    return _bz_vec_max(x).index();
}

 
template<class P_expr>
inline
int maxIndex(_bz_VecExpr<P_expr> x)
{
    return _bz_vec_max(x._bz_asVecExpr()).index();
}

 
template<class P_numtype>
int  maxIndex(const VectorPick<P_numtype>& x)
{
    return _bz_vec_max(x._bz_asVecExpr()).index();
}

 
template<class P_numtype, int N_length>
int  maxIndex(const TinyVector<P_numtype, N_length>& x)
{
    return _bz_vec_max(x._bz_asVecExpr()).index();
}

 
template<class P_numtype>
inline
int  maxValue(const Vector<P_numtype>& x)
{
    return _bz_vec_max(x._bz_asVecExpr()).value();
}

 
template<class P_expr>
inline
int  maxValue(_bz_VecExpr<P_expr> x)
{
    return _bz_vec_max(x).value();
}

 
template<class P_numtype>
int  maxValue(const VectorPick<P_numtype>& x)
{
    return _bz_vec_max(x._bz_asVecExpr()).value();
}

 
template<class P_numtype, int N_length>
int  maxValue(const TinyVector<P_numtype, N_length>& x)
{
    return _bz_vec_max(x._bz_asVecExpr()).value();
}

} 



# 27 "../blitz/vecglobs.cc" 2

# 1 "../blitz/vecsum.cc" 1
 

























namespace  blitz  { 

template<class P_expr>
inline
typename  NumericTypeTraits< typename  P_expr::T_numtype >::T_sumtype 
_bz_vec_sum(P_expr vector)
{
    typedef typename  P_expr::T_numtype T_numtype;
    typedef typename  NumericTypeTraits< T_numtype >::T_sumtype           T_sumtype;

    T_sumtype sum = 0;
    int length = vector._bz_suggestLength();

    if (vector._bz_hasFastAccess())
    {
        for (int i=0; i < length; ++i)
            sum += vector._bz_fastAccess(i);
    }
    else {
        for (int i=0; i < length; ++i)
            sum += vector(i);
    }

    return sum;
}

template<class P_numtype>
inline
typename  NumericTypeTraits< P_numtype >::T_sumtype  sum(const Vector<P_numtype>& x)
{
    return _bz_vec_sum(x._bz_asVecExpr());
}

 
template<class P_expr>
inline
typename  NumericTypeTraits< typename  P_expr::T_numtype >::T_sumtype 
sum(_bz_VecExpr<P_expr> expr)
{
    return _bz_vec_sum(expr);
}

 
template<class P_numtype>
inline
typename  NumericTypeTraits< P_numtype >::T_sumtype 
sum(const VectorPick<P_numtype>& x)
{
    return _bz_vec_sum(x._bz_asVecExpr());
}

 
template<class P_numtype>
inline
typename  NumericTypeTraits< typename  NumericTypeTraits< P_numtype >::T_sumtype  >::T_floattype  mean(const Vector<P_numtype>& x)
{
     ;

    typedef typename  NumericTypeTraits< typename  NumericTypeTraits< P_numtype >::T_sumtype  >::T_floattype  T_floattype;
    return _bz_vec_sum(x._bz_asVecExpr()) / (T_floattype) x.length();
}

 
template<class P_expr>
inline
typename  NumericTypeTraits< typename  NumericTypeTraits< typename  P_expr::T_numtype >::T_sumtype  >::T_floattype 
mean(_bz_VecExpr<P_expr> expr)
{
     ;

    typedef typename  NumericTypeTraits< typename  NumericTypeTraits< typename  P_expr::T_numtype >::T_sumtype  >::T_floattype  
        T_floattype;
    return _bz_vec_sum(expr) / (T_floattype) expr._bz_suggestLength();
}

 
template<class P_numtype>
inline
typename  NumericTypeTraits< typename  NumericTypeTraits< P_numtype >::T_sumtype  >::T_floattype 
mean(const VectorPick<P_numtype>& x)
{
     ;

    typedef typename  NumericTypeTraits< typename  NumericTypeTraits< P_numtype >::T_sumtype  >::T_floattype  T_floattype;
    return _bz_vec_sum(x._bz_asVecExpr()) / (T_floattype) x.length();
}

} 



# 28 "../blitz/vecglobs.cc" 2

# 1 "../blitz/vecdot.cc" 1
 

























namespace  blitz  { 

template<class P1, class P2>
inline
typename  NumericTypeTraits< typename  promote_trait< typename  P1::T_numtype ,  typename  P2::T_numtype >::T_promote  >::T_sumtype 
_bz_dot(P1 vector1, P2 vector2)
{
     ;

    typedef typename  NumericTypeTraits< typename  promote_trait< typename  P1::T_numtype , 
        typename  P2::T_numtype >::T_promote  >::T_sumtype   T_sumtype;

    T_sumtype sum = 0;
    int length = vector1._bz_suggestLength();

    if (vector1._bz_hasFastAccess() && vector2._bz_hasFastAccess())
    {
        for (int i=0; i < length; ++i)
            sum += vector1._bz_fastAccess(i) 
                * vector2._bz_fastAccess(i);
    }
    else {
        for (int i=0; i < length; ++i)
            sum += vector1[i] * vector2[i];
    }

    return sum;
}


 
template<class P_numtype1, class P_numtype2>
inline
typename  NumericTypeTraits< typename  promote_trait< P_numtype1 , P_numtype2 >::T_promote  >::T_sumtype 
dot(const Vector<P_numtype1>& a, const Vector<P_numtype2>& b)
{
    return _bz_dot(a, b);
}

 
template<class P_expr1, class P_expr2>
inline
typename  NumericTypeTraits< typename  promote_trait< typename  P_expr1::T_numtype , 
    typename  P_expr2::T_numtype >::T_promote  >::T_sumtype 
dot(_bz_VecExpr<P_expr1> expr1, _bz_VecExpr<P_expr2> expr2)
{
    return _bz_dot(expr1, expr2);
}

 
template<class P_expr1, class P_numtype2>
inline
typename  NumericTypeTraits< typename  promote_trait< typename  P_expr1::T_numtype ,  P_numtype2 >::T_promote  >::T_sumtype 
dot(_bz_VecExpr<P_expr1> expr1, const Vector<P_numtype2>& vector2)
{
    return _bz_dot(vector2, expr1);
}

 
template<class P_numtype1, class P_expr2>
inline
typename  NumericTypeTraits< typename  promote_trait< P_numtype1 ,  typename  P_expr2::T_numtype >::T_promote  >::T_sumtype 
dot(const Vector<P_numtype1>& vector1, _bz_VecExpr<P_expr2> expr2)
{
    return _bz_dot(vector1, expr2);
}

 
template<class P_numtype1, class P_numtype2>
inline
typename  NumericTypeTraits< typename  promote_trait< P_numtype1 ,  P_numtype2 >::T_promote  >::T_sumtype 
dot(const Vector<P_numtype1>& vector1, const VectorPick<P_numtype2>& vector2)
{
    return _bz_dot(vector1, vector2);
}

 
template<class P_numtype1, class P_numtype2>
inline
typename  NumericTypeTraits< typename  promote_trait< P_numtype1 ,  P_numtype2 >::T_promote  >::T_sumtype 
dot(const VectorPick<P_numtype1>& vector1, const Vector<P_numtype2>& vector2)
{
    return _bz_dot(vector1, vector2);
}

 
template<class P_numtype1, class P_numtype2>
inline
typename  NumericTypeTraits< typename  promote_trait< P_numtype1 ,  P_numtype2 >::T_promote  >::T_sumtype 
dot(const VectorPick<P_numtype1>& vector1, const VectorPick<P_numtype2>& vector2)
{
    return _bz_dot(vector1, vector2);
}

 
template<class P_expr1, class P_numtype2>
inline
typename  NumericTypeTraits< typename  promote_trait< typename  P_expr1::T_numtype ,  P_numtype2 >::T_promote  >::T_sumtype 
dot(_bz_VecExpr<P_expr1> expr1, const VectorPick<P_numtype2>& vector2)
{
    return _bz_dot(expr1, vector2);
}

 
template<class P_numtype1, class P_expr2>
inline
typename  NumericTypeTraits< typename  promote_trait< P_numtype1 ,  typename  P_expr2::T_numtype >::T_promote  >::T_sumtype 
dot(const VectorPick<P_numtype1>& vector1, _bz_VecExpr<P_expr2> expr2)
{
    return _bz_dot(vector1, expr2);
}

} 



# 29 "../blitz/vecglobs.cc" 2

# 1 "../blitz/vecnorm.cc" 1
 

























namespace  blitz  { 

template<class P_expr>
inline
typename  NumericTypeTraits< typename  NumericTypeTraits< typename  P_expr::T_numtype >::T_sumtype  >::T_floattype 
_bz_vec_norm(P_expr vector)
{
     
     
     
     
     
    typedef typename  P_expr::T_numtype T_numtype;
    typedef typename  NumericTypeTraits< T_numtype >::T_sumtype           T_sumtype;
    typedef typename  NumericTypeTraits< T_sumtype >::T_floattype         T_floattype;

    T_sumtype sum = 0;
    int length = vector._bz_suggestLength();

    if (vector._bz_hasFastAccess())
    {
        for (int i=0; i < length; ++i)
        {
            T_numtype value = vector._bz_fastAccess(i);
            sum += value * T_sumtype(value);
        }
    }
    else {
        for (int i=0; i < length; ++i)
        {
            T_numtype value = vector(i);
            sum += value * T_sumtype(value);
        }
    }

    return _bz_sqrt<T_floattype>::apply(sum);
}

template<class P_numtype>
inline
typename  NumericTypeTraits< typename  NumericTypeTraits< P_numtype >::T_sumtype  >::T_floattype  norm(const Vector<P_numtype>& x)
{
    return _bz_vec_norm(x._bz_asVecExpr());
}

 
template<class P_expr>
inline
typename  NumericTypeTraits< typename  NumericTypeTraits< typename  P_expr::T_numtype >::T_sumtype  >::T_floattype 
norm(_bz_VecExpr<P_expr> expr)
{
    return _bz_vec_norm(expr);
}

 
template<class P_numtype>
inline
typename  NumericTypeTraits< typename  NumericTypeTraits< P_numtype >::T_sumtype  >::T_floattype 
norm(const VectorPick<P_numtype>& x)
{
    return _bz_vec_norm(x._bz_asVecExpr());
}

 
template<class P_numtype, int N_dimensions>
inline
typename  NumericTypeTraits< typename  NumericTypeTraits< P_numtype >::T_sumtype  >::T_floattype 
norm(const TinyVector<P_numtype, N_dimensions>& x)
{
    return _bz_vec_norm(x._bz_asVecExpr());
}

} 



# 30 "../blitz/vecglobs.cc" 2

# 1 "../blitz/vecnorm1.cc" 1
 



























namespace  blitz  { 

template<class P_expr>
inline
typename  NumericTypeTraits< typename  P_expr::T_numtype >::T_sumtype 
_bz_vec_norm1(P_expr vector)
{
    typedef typename  P_expr::T_numtype T_numtype;
    typedef typename  NumericTypeTraits< T_numtype >::T_sumtype           T_sumtype;

    T_sumtype sum = 0;
    int length = vector._bz_suggestLength();

    if (vector._bz_hasFastAccess())
    {
        for (int i=0; i < length; ++i)
            sum += _bz_abs<T_numtype>::apply(vector._bz_fastAccess(i));
    }
    else {
        for (int i=0; i < length; ++i)
            sum += _bz_abs<T_numtype>::apply(vector(i));
    }

    return sum;
}

 
template<class P_numtype>
typename  NumericTypeTraits< P_numtype >::T_sumtype  norm1(const Vector<P_numtype>& x)
{
    return _bz_vec_norm1(x._bz_asVecExpr());
}

 
template<class P_expr>
typename  NumericTypeTraits< typename  P_expr::T_numtype >::T_sumtype  norm1(_bz_VecExpr<P_expr> expr)
{
    return _bz_vec_norm1(expr);
}

 
template<class P_numtype>
typename  NumericTypeTraits< P_numtype >::T_sumtype  norm1(const VectorPick<P_numtype>& x)
{
    return _bz_vec_norm1(x._bz_asVecExpr());
}

 
template<class P_numtype, int N_dimensions>
typename  NumericTypeTraits< P_numtype >::T_sumtype  norm1(const TinyVector<P_numtype, N_dimensions>& x)
{
    return _bz_vec_norm1(x._bz_asVecExpr());
}


} 



# 31 "../blitz/vecglobs.cc" 2

# 1 "../blitz/vecany.cc" 1
 

























namespace  blitz  { 

template<class P_expr>
inline bool  _bz_vec_any(P_expr vector)
{
    int length = vector._bz_suggestLength();

    if (vector._bz_hasFastAccess())
    {
        for (int i=0; i < length; ++i)
            if (vector._bz_fastAccess(i))
                return true ;
    }
    else {
        for (int i=0; i < length; ++i)
            if (vector[i])
                return true ;
    }

    return false ;
}

template<class P_numtype>
inline bool  any(const Vector<P_numtype>& x)
{
    return _bz_vec_any(x._bz_asVecExpr());
}

template<class P_expr>
inline bool  any(_bz_VecExpr<P_expr> expr)
{
    return _bz_vec_any(expr);
}

template<class P_numtype>
inline bool  any(const VectorPick<P_numtype>& x)
{
    return _bz_vec_any(x._bz_asVecExpr());
}

template<class P_numtype, int N_dimensions>
inline bool  any(const TinyVector<P_numtype, N_dimensions>& x)
{
    return _bz_vec_any(x._bz_asVecExpr());
}

} 



# 32 "../blitz/vecglobs.cc" 2

# 1 "../blitz/vecall.cc" 1
 

























namespace  blitz  { 

template<class P_expr>
inline bool  _bz_vec_all(P_expr vector)
{
    int length = vector._bz_suggestLength();

    if (vector._bz_hasFastAccess())
    {
        for (int i=0; i < length; ++i)
            if (!vector._bz_fastAccess(i))
                return false ;
    }
    else {
        for (int i=0; i < length; ++i)
            if (!vector[i])
                return false ;
    }

    return true ;
}

template<class P_numtype>
inline bool  all(const Vector<P_numtype>& x)
{
    return _bz_vec_all(x._bz_asVecExpr());
}

template<class P_expr>
inline bool  all(_bz_VecExpr<P_expr> expr)
{
    return _bz_vec_all(expr);
}

template<class P_numtype>
inline bool  all(const VectorPick<P_numtype>& x)
{
    return _bz_vec_all(x._bz_asVecExpr());
}

template<class P_numtype, int N_dimensions>
inline bool  all(const TinyVector<P_numtype, N_dimensions>& x)
{
    return _bz_vec_all(x._bz_asVecExpr());
}

} 



# 33 "../blitz/vecglobs.cc" 2

# 1 "../blitz/veccount.cc" 1
 






















namespace  blitz  { 

template<class P_expr>
inline int _bz_vec_count(P_expr vector)
{
    int length = vector._bz_suggestLength();
    int count = 0;

    if (vector._bz_hasFastAccess())
    {
        for (int i=0; i < length; ++i)
            if (vector._bz_fastAccess(i))
                ++count;
    }
    else {
        for (int i=0; i < length; ++i)
            if (vector[i])
                ++count;
    }

    return count;
}

template<class P_numtype>
inline int count(const Vector<P_numtype>& x)
{
    return _bz_vec_count(x._bz_asVecExpr());
}

template<class P_expr>
inline int count(_bz_VecExpr<P_expr> expr)
{
    return _bz_vec_count(expr);
}

template<class P_numtype>
inline int count(const VectorPick<P_numtype>& x)
{
    return _bz_vec_count(x._bz_asVecExpr());
}

template<class P_numtype, int N_dimensions>
inline int count(const TinyVector<P_numtype, N_dimensions>& x)
{
    return _bz_vec_count(x._bz_asVecExpr());
}

} 



# 34 "../blitz/vecglobs.cc" 2



# 65 "../blitz/vecglobs.h" 2



# 491 "../blitz/vector.h" 2

# 1 "../blitz/vector.cc" 1
 





























namespace  blitz  { 

template<class P_numtype>
Vector<P_numtype> Vector<P_numtype>::copy() const
{
    Vector<P_numtype> newCopy(length_);

    if (stride_ == 1)
    {
        memcpy(newCopy.data(), data(), length_ * sizeof(P_numtype));
    }
    else {
        for (int i=0; i < length_; ++i)
        {
             
             
             
            newCopy(i) = (*this)[i];
        }
    }

    return newCopy;
}

template<class P_numtype>
void Vector<P_numtype>::makeUnique()
{
    if ((stride_ != 1) || (numReferences() > 1))
    {
        Vector<P_numtype> tmp = copy();
        reference(tmp);
    }
}

template<class P_numtype>
void Vector<P_numtype>::reference(Vector<P_numtype>& x)
{
    MemoryBlockReference<P_numtype>::changeBlock(x, 0);
    length_ = x.length_;
    stride_ = x.stride_;
}

template<class P_numtype>
void Vector<P_numtype>::resize(int length)
{
    if (length != length_)
    {
        MemoryBlockReference<P_numtype>::newBlock(length);
        length_ = length;
        stride_ = 1;
    }
}

template<class P_numtype>
void Vector<P_numtype>::resizeAndPreserve(int newLength)
{
    Vector<P_numtype> newVector(newLength);

    if (newLength > length_)
        newVector(Range(0,length_-1)) = (*this);
    else 
        newVector(Range(0,newLength-1)) = (*this);

    reference(newVector);
}

 



template<class P_numtype> template<class P_expr, class P_updater>
inline
void Vector<P_numtype>::_bz_assign(P_expr expr, P_updater)
{
     ;

     
     
     
    if ((stride_ == 1) && (expr._bz_hasFastAccess()))
    {

        for (int i=0; i < length_; ++i)
            P_updater::update(data_[i], expr._bz_fastAccess(i));
# 146 "../blitz/vector.cc"

    }
    else {
         
         
        for (int i=0; i < length_; ++i)
            P_updater::update((*this)[i], expr[i]);
    }
}

template<class P_numtype> template<class P_expr>
inline Vector<P_numtype>& Vector<P_numtype>::operator=(_bz_VecExpr<P_expr> expr)
{
     ;

     
     
     
    if ((stride_ == 1) && (expr._bz_hasFastAccess()))
    {

        for (int i=0; i < length_; ++i)
            data_[i] = (P_numtype)expr._bz_fastAccess(i);
# 200 "../blitz/vector.cc"

    }
    else {
         
         
        for (int i=0; i < length_; ++i)
            (*this)[i] = (P_numtype)expr[i];
    }
    return *this;
}

# 253 "../blitz/vector.cc"


# 287 "../blitz/vector.cc"



# 306 "../blitz/vector.cc"



template<class P_numtype> template<class P_expr> inline Vector<P_numtype>& Vector<P_numtype>:: operator  +=  (_bz_VecExpr<P_expr> expr) {  ; if ((stride_ == 1) && (expr._bz_hasFastAccess())) { for (int i=0; i < length_; ++i) data_[i]  +=  expr._bz_fastAccess(i); } else { for (int i=0; i < length_; ++i) (*this)[i]  +=  expr[i]; } return *this; } 
template<class P_numtype> template<class P_expr> inline Vector<P_numtype>& Vector<P_numtype>:: operator  -=  (_bz_VecExpr<P_expr> expr) {  ; if ((stride_ == 1) && (expr._bz_hasFastAccess())) { for (int i=0; i < length_; ++i) data_[i]  -=  expr._bz_fastAccess(i); } else { for (int i=0; i < length_; ++i) (*this)[i]  -=  expr[i]; } return *this; } 
template<class P_numtype> template<class P_expr> inline Vector<P_numtype>& Vector<P_numtype>:: operator  *=  (_bz_VecExpr<P_expr> expr) {  ; if ((stride_ == 1) && (expr._bz_hasFastAccess())) { for (int i=0; i < length_; ++i) data_[i]  *=  expr._bz_fastAccess(i); } else { for (int i=0; i < length_; ++i) (*this)[i]  *=  expr[i]; } return *this; } 
template<class P_numtype> template<class P_expr> inline Vector<P_numtype>& Vector<P_numtype>:: operator  /=  (_bz_VecExpr<P_expr> expr) {  ; if ((stride_ == 1) && (expr._bz_hasFastAccess())) { for (int i=0; i < length_; ++i) data_[i]  /=  expr._bz_fastAccess(i); } else { for (int i=0; i < length_; ++i) (*this)[i]  /=  expr[i]; } return *this; } 
template<class P_numtype> template<class P_expr> inline Vector<P_numtype>& Vector<P_numtype>:: operator  %=  (_bz_VecExpr<P_expr> expr) {  ; if ((stride_ == 1) && (expr._bz_hasFastAccess())) { for (int i=0; i < length_; ++i) data_[i]  %=  expr._bz_fastAccess(i); } else { for (int i=0; i < length_; ++i) (*this)[i]  %=  expr[i]; } return *this; } 
template<class P_numtype> template<class P_expr> inline Vector<P_numtype>& Vector<P_numtype>:: operator  ^=  (_bz_VecExpr<P_expr> expr) {  ; if ((stride_ == 1) && (expr._bz_hasFastAccess())) { for (int i=0; i < length_; ++i) data_[i]  ^=  expr._bz_fastAccess(i); } else { for (int i=0; i < length_; ++i) (*this)[i]  ^=  expr[i]; } return *this; } 
template<class P_numtype> template<class P_expr> inline Vector<P_numtype>& Vector<P_numtype>:: operator  &=  (_bz_VecExpr<P_expr> expr) {  ; if ((stride_ == 1) && (expr._bz_hasFastAccess())) { for (int i=0; i < length_; ++i) data_[i]  &=  expr._bz_fastAccess(i); } else { for (int i=0; i < length_; ++i) (*this)[i]  &=  expr[i]; } return *this; } 
template<class P_numtype> template<class P_expr> inline Vector<P_numtype>& Vector<P_numtype>:: operator  |=  (_bz_VecExpr<P_expr> expr) {  ; if ((stride_ == 1) && (expr._bz_hasFastAccess())) { for (int i=0; i < length_; ++i) data_[i]  |=  expr._bz_fastAccess(i); } else { for (int i=0; i < length_; ++i) (*this)[i]  |=  expr[i]; } return *this; } 
template<class P_numtype> template<class P_expr> inline Vector<P_numtype>& Vector<P_numtype>:: operator  >>=  (_bz_VecExpr<P_expr> expr) {  ; if ((stride_ == 1) && (expr._bz_hasFastAccess())) { for (int i=0; i < length_; ++i) data_[i]  >>=  expr._bz_fastAccess(i); } else { for (int i=0; i < length_; ++i) (*this)[i]  >>=  expr[i]; } return *this; } 
template<class P_numtype> template<class P_expr> inline Vector<P_numtype>& Vector<P_numtype>:: operator  <<=  (_bz_VecExpr<P_expr> expr) {  ; if ((stride_ == 1) && (expr._bz_hasFastAccess())) { for (int i=0; i < length_; ++i) data_[i]  <<=  expr._bz_fastAccess(i); } else { for (int i=0; i < length_; ++i) (*this)[i]  <<=  expr[i]; } return *this; } 

# 401 "../blitz/vector.cc"


 



template<class P_numtype>
inline Vector<P_numtype>& Vector<P_numtype>::initialize(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) = _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype>
inline Vector<P_numtype>& Vector<P_numtype>::operator+=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) += _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype>
inline Vector<P_numtype>& Vector<P_numtype>::operator-=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) -= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype>
inline Vector<P_numtype>& Vector<P_numtype>::operator*=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) *= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype>
inline Vector<P_numtype>& Vector<P_numtype>::operator/=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) /= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype>
inline Vector<P_numtype>& Vector<P_numtype>::operator%=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) %= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype>
inline Vector<P_numtype>& Vector<P_numtype>::operator^=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) ^= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype>
inline Vector<P_numtype>& Vector<P_numtype>::operator&=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) &= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype>
inline Vector<P_numtype>& Vector<P_numtype>::operator|=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) |= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype>
inline Vector<P_numtype>& Vector<P_numtype>::operator>>=(int x)
{
    typedef _bz_VecExprConstant<int> T_expr;
    (*this) >>= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype>
inline Vector<P_numtype>& Vector<P_numtype>::operator<<=(int x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) <<= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

 



 
 
 
# 513 "../blitz/vector.cc"


 
 
template<class P_numtype> template<class P_numtype2>
inline Vector<P_numtype>& 
Vector<P_numtype>::operator=(const Vector<P_numtype2>& x)
{
    (*this) = _bz_VecExpr<VectorIterConst<P_numtype2> >(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline Vector<P_numtype>&
Vector<P_numtype>::operator+=(const Vector<P_numtype2>& x)
{
    (*this) += _bz_VecExpr<VectorIterConst<P_numtype2> >(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline Vector<P_numtype>&
Vector<P_numtype>::operator-=(const Vector<P_numtype2>& x)
{
    (*this) -= _bz_VecExpr<VectorIterConst<P_numtype2> >(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline Vector<P_numtype>&
Vector<P_numtype>::operator*=(const Vector<P_numtype2>& x)
{
    (*this) *= _bz_VecExpr<VectorIterConst<P_numtype2> >(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline Vector<P_numtype>&
Vector<P_numtype>::operator/=(const Vector<P_numtype2>& x)
{
    (*this) /= _bz_VecExpr<VectorIterConst<P_numtype2> >(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline Vector<P_numtype>&
Vector<P_numtype>::operator%=(const Vector<P_numtype2>& x)
{
    (*this) %= _bz_VecExpr<VectorIterConst<P_numtype2> >(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline Vector<P_numtype>&
Vector<P_numtype>::operator^=(const Vector<P_numtype2>& x)
{
    (*this) ^= _bz_VecExpr<VectorIterConst<P_numtype2> >(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline Vector<P_numtype>&
Vector<P_numtype>::operator&=(const Vector<P_numtype2>& x)
{
    (*this) &= _bz_VecExpr<VectorIterConst<P_numtype2> >(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline Vector<P_numtype>&
Vector<P_numtype>::operator|=(const Vector<P_numtype2>& x)
{
    (*this) |= _bz_VecExpr<VectorIterConst<P_numtype2> >(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline Vector<P_numtype>&
Vector<P_numtype>::operator<<=(const Vector<P_numtype2>& x)
{
    (*this) <<= _bz_VecExpr<VectorIterConst<P_numtype2> >(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline Vector<P_numtype>&
Vector<P_numtype>::operator>>=(const Vector<P_numtype2>& x)
{
    (*this) >>= _bz_VecExpr<VectorIterConst<P_numtype2> >(x.begin());
    return *this;
}

 



template<class P_numtype>
inline Vector<P_numtype>& Vector<P_numtype>::operator=(Range r)
{
    (*this) = _bz_VecExpr<Range>(r);
    return *this;
}

template<class P_numtype>
inline Vector<P_numtype>& Vector<P_numtype>::operator+=(Range r)
{
    (*this) += _bz_VecExpr<Range>(r);
    return *this;
}

template<class P_numtype>
inline Vector<P_numtype>& Vector<P_numtype>::operator-=(Range r)
{
    (*this) -= _bz_VecExpr<Range>(r);
    return *this;
}

template<class P_numtype>
inline Vector<P_numtype>& Vector<P_numtype>::operator*=(Range r)
{
    (*this) *= _bz_VecExpr<Range>(r);
    return *this;
}

template<class P_numtype>
inline Vector<P_numtype>& Vector<P_numtype>::operator/=(Range r)
{
    (*this) /= _bz_VecExpr<Range>(r);
    return *this;
}

template<class P_numtype>
inline Vector<P_numtype>& Vector<P_numtype>::operator%=(Range r)
{
    (*this) %= _bz_VecExpr<Range>(r);
    return *this;
}

template<class P_numtype>
inline Vector<P_numtype>& Vector<P_numtype>::operator^=(Range r)
{
    (*this) ^= _bz_VecExpr<Range>(r);
    return *this;
}

template<class P_numtype>
inline Vector<P_numtype>& Vector<P_numtype>::operator&=(Range r)
{
    (*this) &= _bz_VecExpr<Range>(r);
    return *this;
}

template<class P_numtype>
inline Vector<P_numtype>& Vector<P_numtype>::operator|=(Range r)
{
    (*this) |= _bz_VecExpr<Range>(r);
    return *this;
}

template<class P_numtype>
inline Vector<P_numtype>& Vector<P_numtype>::operator>>=(Range r)
{
    (*this) >>= _bz_VecExpr<Range>(r);
    return *this;
}

template<class P_numtype>
inline Vector<P_numtype>& Vector<P_numtype>::operator<<=(Range r)
{
    (*this) <<= _bz_VecExpr<Range>(r);
    return *this;
}

 



template<class P_numtype> template<class P_numtype2>
inline Vector<P_numtype>& Vector<P_numtype>::operator=(const 
    VectorPick<P_numtype2>& x)
{
    typedef VectorPickIterConst<P_numtype2> T_expr;
    (*this) = _bz_VecExpr<T_expr>(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline Vector<P_numtype>& Vector<P_numtype>::operator+=(const
    VectorPick<P_numtype2>& x)
{
    typedef VectorPickIterConst<P_numtype2> T_expr;
    (*this) += _bz_VecExpr<T_expr>(x.begin());
    return *this;
}


template<class P_numtype> template<class P_numtype2>
inline Vector<P_numtype>& Vector<P_numtype>::operator-=(const
    VectorPick<P_numtype2>& x)
{
    typedef VectorPickIterConst<P_numtype2> T_expr;
    (*this) -= _bz_VecExpr<T_expr>(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline Vector<P_numtype>& Vector<P_numtype>::operator*=(const
    VectorPick<P_numtype2>& x)
{
    typedef VectorPickIterConst<P_numtype2> T_expr;
    (*this) *= _bz_VecExpr<T_expr>(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline Vector<P_numtype>& Vector<P_numtype>::operator/=(const
    VectorPick<P_numtype2>& x)
{
    typedef VectorPickIterConst<P_numtype2> T_expr;
    (*this) /= _bz_VecExpr<T_expr>(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline Vector<P_numtype>& Vector<P_numtype>::operator%=(const
    VectorPick<P_numtype2>& x)
{
    typedef VectorPickIterConst<P_numtype2> T_expr;
    (*this) %= _bz_VecExpr<T_expr>(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline Vector<P_numtype>& Vector<P_numtype>::operator^=(const
    VectorPick<P_numtype2>& x)
{
    typedef VectorPickIterConst<P_numtype2> T_expr;
    (*this) ^= _bz_VecExpr<T_expr>(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline Vector<P_numtype>& Vector<P_numtype>::operator&=(const
    VectorPick<P_numtype2>& x)
{
    typedef VectorPickIterConst<P_numtype2> T_expr;
    (*this) &= _bz_VecExpr<T_expr>(x.begin());
    return *this;
}

template<class P_numtype> template<class P_numtype2>
inline Vector<P_numtype>& Vector<P_numtype>::operator|=(const
    VectorPick<P_numtype2>& x)
{
    typedef VectorPickIterConst<P_numtype2> T_expr;
    (*this) |= _bz_VecExpr<T_expr>(x.begin());
    return *this;
}

 



template<class P_numtype> template<class P_distribution>
Vector<P_numtype>& Vector<P_numtype>::operator=(Random<P_distribution>& rand)
{
    for (int i=0; i < length_; ++i) 
        (*this)[i] = rand.random();
    return *this;
}

# 858 "../blitz/vector.cc"


} 


# 492 "../blitz/vector.h" 2

# 1 "../blitz/vecio.cc" 1
 

























namespace  blitz  { 

 
 
 

template<class P_numtype>
ostream& operator<<(ostream& os, const Vector<P_numtype>& x)
{
    os << "[ ";
    for (int i=0; i < x.length(); ++i)
    {
        os << setw(10) << x[i];
        if (!((i+1)%7))
            os << endl << "  ";
    }
    os << " ]";
    return os;
}

template<class P_expr>
ostream& operator<<(ostream& os, _bz_VecExpr<P_expr> expr)
{
    Vector< typename  P_expr::T_numtype> result(expr);
    os << result;
    return os;
}

} 


# 493 "../blitz/vector.h" 2



# 442 "../blitz/tinyvec.h" 2

# 1 "../blitz/tinyvec.cc" 1



















# 1 "../blitz/meta/vecassign.h" 1
 



































namespace  blitz  { 

template<int N, int I> 
class _bz_meta_vecAssign {
public:
    enum { loopFlag = (I < N-1) ? 1 : 0 };

    template<class T_vector, class T_expr, class T_updater>
    static inline void fastAssign(T_vector& vec, T_expr expr, T_updater u)
    {
        u.update(vec[I], expr._bz_fastAccess(I));
        _bz_meta_vecAssign<N * loopFlag, (I+1) * loopFlag>
           ::fastAssign(vec,expr,u);
    }

    template<class T_vector, class T_expr, class T_updater>
    static inline void assign(T_vector& vec, T_expr expr, T_updater u)
    {
        u.update(vec[I], expr[I]);
        _bz_meta_vecAssign<N * loopFlag, (I+1) * loopFlag>
           ::assign(vec,expr,u);
    }

    template<class T_vector, class T_numtype, class T_updater>
    static inline void assignWithArgs(T_vector& vec, T_updater u,
        T_numtype x0, T_numtype x1=0, T_numtype x2=0, T_numtype x3=0,
        T_numtype x4=0, T_numtype x5=0, T_numtype x6=0, T_numtype x7=0,
        T_numtype x8=0, T_numtype x9=0)
    {
        u.update(vec[I], x0);
        _bz_meta_vecAssign<N * loopFlag, (I+1) * loopFlag>
            ::assignWithArgs(vec, u, x1, x2, x3, x4, x5, x6, x7, x8, x9);
    }
        
};

template<>
class _bz_meta_vecAssign<0,0> {
public:
    template<class T_vector, class T_expr, class T_updater>
    static inline void fastAssign(T_vector& vec, T_expr expr, T_updater u)
    { }

    template<class T_vector, class T_expr, class T_updater>
    static inline void assign(T_vector& vec, T_expr expr, T_updater u)
    { }

    template<class T_vector, class T_numtype, class T_updater>
    static inline void assignWithArgs(T_vector& vec, T_updater u,
        T_numtype x0, T_numtype x1=0, T_numtype x2=0, T_numtype x3=0,
        T_numtype x4=0, T_numtype x5=0, T_numtype x6=0, T_numtype x7=0,
        T_numtype x8=0, T_numtype x9=0)
    {
    }
};

} 


# 20 "../blitz/tinyvec.cc" 2


namespace  blitz  { 

template<class T_numtype, int N_length>
inline TinyVector<T_numtype, N_length>::TinyVector(T_numtype initValue)
{
    for (int i=0; i < N_length; ++i)
        data_[i] = initValue;
}

template<class T_numtype, int N_length>
inline TinyVector<T_numtype, N_length>::TinyVector(const 
    TinyVector<T_numtype, N_length>& x)
{
    for (int i=0; i < N_length; ++i)
        data_[i] = x.data_[i];
}

template<class T_numtype, int N_length> template<class P_expr, class P_updater>
inline
void TinyVector<T_numtype, N_length>::_bz_assign(P_expr expr, P_updater up)
{
     ;





    if (expr._bz_hasFastAccess())
    {
        _bz_meta_vecAssign<N_length, 0>::fastAssign(*this, expr, up);
    }
    else {
        _bz_meta_vecAssign<N_length, 0>::assign(*this, expr, up);
    }
}

 
template<class P_numtype, int N_length> template<class P_expr>
inline TinyVector<P_numtype, N_length>::TinyVector(_bz_VecExpr<P_expr> expr) 
{
  _bz_assign(expr, _bz_update<P_numtype, typename  P_expr::T_numtype>());
}

 



template<class P_numtype, int N_length> template<class P_expr>
inline TinyVector<P_numtype, N_length>& 
TinyVector<P_numtype, N_length>::operator=(_bz_VecExpr<P_expr> expr)
{
    _bz_assign(expr, _bz_update<P_numtype, typename  P_expr::T_numtype>());
    return *this;
}

template<class P_numtype, int N_length> template<class P_expr>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator+=(_bz_VecExpr<P_expr> expr)
{
    _bz_assign(expr, _bz_plus_update<P_numtype, 
        typename  P_expr::T_numtype>());
    return *this;
}

template<class P_numtype, int N_length> template<class P_expr>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator-=(_bz_VecExpr<P_expr> expr)
{
    _bz_assign(expr, _bz_minus_update<P_numtype,
        typename  P_expr::T_numtype>());
    return *this;
}

template<class P_numtype, int N_length> template<class P_expr>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator*=(_bz_VecExpr<P_expr> expr)
{
    _bz_assign(expr, _bz_multiply_update<P_numtype,
        typename  P_expr::T_numtype>());
    return *this;
}

template<class P_numtype, int N_length> template<class P_expr>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator/=(_bz_VecExpr<P_expr> expr)
{
    _bz_assign(expr, _bz_divide_update<P_numtype,
        typename  P_expr::T_numtype>());
    return *this;
}

template<class P_numtype, int N_length> template<class P_expr>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator%=(_bz_VecExpr<P_expr> expr)
{
    _bz_assign(expr, _bz_mod_update<P_numtype,
        typename  P_expr::T_numtype>());
    return *this;
}

template<class P_numtype, int N_length> template<class P_expr>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator^=(_bz_VecExpr<P_expr> expr)
{
    _bz_assign(expr, _bz_xor_update<P_numtype,
        typename  P_expr::T_numtype>());
    return *this;
}

template<class P_numtype, int N_length> template<class P_expr>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator&=(_bz_VecExpr<P_expr> expr)
{
    _bz_assign(expr, _bz_bitand_update<P_numtype,
        typename  P_expr::T_numtype>());
    return *this;
}

template<class P_numtype, int N_length> template<class P_expr>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator|=(_bz_VecExpr<P_expr> expr)
{
    _bz_assign(expr, _bz_bitor_update<P_numtype,
        typename  P_expr::T_numtype>());
    return *this;
}

template<class P_numtype, int N_length> template<class P_expr>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator<<=(_bz_VecExpr<P_expr> expr)
{
    _bz_assign(expr, _bz_shiftl_update<P_numtype,
        typename  P_expr::T_numtype>());
    return *this;
}

template<class P_numtype, int N_length> template<class P_expr>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator>>=(_bz_VecExpr<P_expr> expr)
{
    _bz_assign(expr, _bz_shiftr_update<P_numtype,
        typename  P_expr::T_numtype>());
    return *this;
}

 



template<class P_numtype, int N_length> 
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::initialize(P_numtype x)
{

    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) = _bz_VecExpr<T_expr>(T_expr(x));






    return *this;
}

template<class P_numtype, int N_length>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator+=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) += _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype, int N_length>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator-=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) -= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype, int N_length>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator*=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) *= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype, int N_length>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator/=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) /= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype, int N_length>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator%=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) %= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype, int N_length>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator^=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) ^= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype, int N_length>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator&=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) &= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype, int N_length>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator|=(P_numtype x)
{
    typedef _bz_VecExprConstant<P_numtype> T_expr;
    (*this) |= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype, int N_length>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator<<=(int x)
{
    typedef _bz_VecExprConstant<int> T_expr;
    (*this) <<= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

template<class P_numtype, int N_length>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator>>=(int x)
{
    typedef _bz_VecExprConstant<int> T_expr;
    (*this) >>= _bz_VecExpr<T_expr>(T_expr(x));
    return *this;
}

 



template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator=(const 
    TinyVector<P_numtype2, N_length>& x)
{
    (*this) = _bz_VecExpr< typename  
        TinyVector<P_numtype2, N_length>::T_constIterator>(x.begin());
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator+=(const
    TinyVector<P_numtype2, N_length>& x)
{
    (*this) += _bz_VecExpr< typename 
        TinyVector<P_numtype2, N_length>::T_constIterator>(x.begin());
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator-=(const
    TinyVector<P_numtype2, N_length>& x)
{
    (*this) -= _bz_VecExpr< typename 
        TinyVector<P_numtype2, N_length>::T_constIterator>(x.begin());
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator*=(const
    TinyVector<P_numtype2, N_length>& x)
{
    (*this) *= _bz_VecExpr< typename 
        TinyVector<P_numtype2, N_length>::T_constIterator>(x.begin());
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator/=(const
    TinyVector<P_numtype2, N_length>& x)
{
    (*this) /= _bz_VecExpr< typename 
        TinyVector<P_numtype2, N_length>::T_constIterator>(x.begin());
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator%=(const
    TinyVector<P_numtype2, N_length>& x)
{
    (*this) %= _bz_VecExpr< typename 
        TinyVector<P_numtype2, N_length>::T_constIterator>(x.begin());
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator^=(const
    TinyVector<P_numtype2, N_length>& x)
{
    (*this) ^= _bz_VecExpr< typename 
        TinyVector<P_numtype2, N_length>::T_constIterator>(x.begin());
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator&=(const
    TinyVector<P_numtype2, N_length>& x)
{
    (*this) &= _bz_VecExpr< typename 
        TinyVector<P_numtype2, N_length>::T_constIterator>(x.begin());
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator|=(const
    TinyVector<P_numtype2, N_length>& x)
{
    (*this) |= _bz_VecExpr< typename 
        TinyVector<P_numtype2, N_length>::T_constIterator>(x.begin());
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator<<=(const
    TinyVector<P_numtype2, N_length>& x)
{
    (*this) <<= _bz_VecExpr< typename 
        TinyVector<P_numtype2, N_length>::T_constIterator>(x.begin());
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator>>=(const
    TinyVector<P_numtype2, N_length>& x)
{
    (*this) >>= _bz_VecExpr< typename 
        TinyVector<P_numtype2, N_length>::T_constIterator>(x.begin());
    return *this;
}

 



template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator=(const Vector<P_numtype2>& x)
{
    (*this) = x._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator+=(const Vector<P_numtype2>& x)
{
    (*this) += x._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator-=(const Vector<P_numtype2>& x)
{
    (*this) -= x._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator*=(const Vector<P_numtype2>& x)
{
    (*this) *= x._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator/=(const Vector<P_numtype2>& x)
{
    (*this) /= x._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator%=(const Vector<P_numtype2>& x)
{
    (*this) %= x._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator^=(const Vector<P_numtype2>& x)
{
    (*this) ^= x._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator&=(const Vector<P_numtype2>& x)
{
    (*this) &= x._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator|=(const Vector<P_numtype2>& x)
{
    (*this) |= x._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator<<=(const Vector<P_numtype2>& x)
{
    (*this) <<= x._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator>>=(const Vector<P_numtype2>& x)
{
    (*this) >>= x._bz_asVecExpr();
    return *this;
}

 



template<class P_numtype, int N_length> 
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator=(Range r)
{
    (*this) = r._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator+=(Range r)
{
    (*this) += r._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator-=(Range r)
{
    (*this) -= r._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator*=(Range r)
{
    (*this) *= r._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator/=(Range r)
{
    (*this) /= r._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator%=(Range r)
{
    (*this) %= r._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator^=(Range r)
{
    (*this) ^= r._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator&=(Range r)
{
    (*this) &= r._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator|=(Range r)
{
    (*this) |= r._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator<<=(Range r)
{
    (*this) <<= r._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator>>=(Range r)
{
    (*this) >>= r._bz_asVecExpr();
    return *this;
}

 



template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator=(const VectorPick<P_numtype2>& x)
{
    (*this) = x._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator+=(const VectorPick<P_numtype2>& x)
{
    (*this) += x._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator-=(const VectorPick<P_numtype2>& x)
{
    (*this) -= x._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator*=(const VectorPick<P_numtype2>& x)
{
    (*this) *= x._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator/=(const VectorPick<P_numtype2>& x)
{
    (*this) /= x._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator%=(const VectorPick<P_numtype2>& x)
{
    (*this) %= x._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator^=(const VectorPick<P_numtype2>& x)
{
    (*this) ^= x._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator&=(const VectorPick<P_numtype2>& x)
{
    (*this) &= x._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator|=(const VectorPick<P_numtype2>& x)
{
    (*this) |= x._bz_asVecExpr();
    return *this;
}

template<class P_numtype, int N_length> template<class P_numtype2>
inline TinyVector<P_numtype, N_length>&
TinyVector<P_numtype, N_length>::operator>>=(const VectorPick<P_numtype2>& x)
{
    (*this) <<= x._bz_asVecExpr();
    return *this;
}

} 


# 443 "../blitz/tinyvec.h" 2

# 1 "../blitz/tinyvecio.cc" 1
 






















namespace  blitz  { 

 

template<class P_numtype, int N_length>
ostream& operator<<(ostream& os, const TinyVector<P_numtype, N_length>& x)
{
    os << "[ ";
    for (int i=0; i < N_length; ++i)
    {
        os << setw(10) << x[i];
        if (!((i+1)%7))
            os << endl << "  ";
    }
    os << " ]";
    return os;
}

} 


# 444 "../blitz/tinyvec.h" 2




# 61 "../blitz/array.h" 2




 
# 1 "../blitz/traversal.h" 1
 
































 
 













# 1 "/u/tveldhui/software/egcs-irix/include/g++/set" 1 3
 





























# 1 "/u/tveldhui/software/egcs-irix/include/g++/stl_tree.h" 1 3
 



























 






 



















# 1 "/u/tveldhui/software/egcs-irix/include/g++/stl_algobase.h" 1 3
 

























 














# 1 "/u/tveldhui/software/egcs-irix/include/g++/stl_pair.h" 1 3
 

























 






 

template <class T1, class T2>
struct pair {
  typedef T1 first_type;
  typedef T2 second_type;

  T1 first;
  T2 second;
  pair() : first(T1()), second(T2()) {}
  pair(const T1& a, const T2& b) : first(a), second(b) {}


  template <class U1, class U2>
  pair(const pair<U1, U2>& p) : first(p.first), second(p.second) {}

};

template <class T1, class T2>
inline bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y) { 
  return x.first == y.first && x.second == y.second; 
}

template <class T1, class T2>
inline bool operator<(const pair<T1, T2>& x, const pair<T1, T2>& y) { 
  return x.first < y.first || (!(y.first < x.first) && x.second < y.second); 
}

template <class T1, class T2>
inline pair<T1, T2> make_pair(const T1& x, const T2& y) {
  return pair<T1, T2>(x, y);
}

 



 
 
 
# 42 "/u/tveldhui/software/egcs-irix/include/g++/stl_algobase.h" 2 3



# 1 "/u/tveldhui/software/egcs-irix/include/g++/type_traits.h" 1 3
 




















 































struct __true_type {
};

struct __false_type {
};

template <class type>
struct __type_traits { 
   typedef __true_type     this_dummy_member_must_be_first;
                    





    








 

   typedef __false_type    has_trivial_default_constructor;
   typedef __false_type    has_trivial_copy_constructor;
   typedef __false_type    has_trivial_assignment_operator;
   typedef __false_type    has_trivial_destructor;
   typedef __false_type    is_POD_type;
};



 
 
 

template<>  struct __type_traits<char> {
   typedef __true_type    has_trivial_default_constructor;
   typedef __true_type    has_trivial_copy_constructor;
   typedef __true_type    has_trivial_assignment_operator;
   typedef __true_type    has_trivial_destructor;
   typedef __true_type    is_POD_type;
};

template<>  struct __type_traits<signed char> {
   typedef __true_type    has_trivial_default_constructor;
   typedef __true_type    has_trivial_copy_constructor;
   typedef __true_type    has_trivial_assignment_operator;
   typedef __true_type    has_trivial_destructor;
   typedef __true_type    is_POD_type;
};

template<>  struct __type_traits<unsigned char> {
   typedef __true_type    has_trivial_default_constructor;
   typedef __true_type    has_trivial_copy_constructor;
   typedef __true_type    has_trivial_assignment_operator;
   typedef __true_type    has_trivial_destructor;
   typedef __true_type    is_POD_type;
};

template<>  struct __type_traits<short> {
   typedef __true_type    has_trivial_default_constructor;
   typedef __true_type    has_trivial_copy_constructor;
   typedef __true_type    has_trivial_assignment_operator;
   typedef __true_type    has_trivial_destructor;
   typedef __true_type    is_POD_type;
};

template<>  struct __type_traits<unsigned short> {
   typedef __true_type    has_trivial_default_constructor;
   typedef __true_type    has_trivial_copy_constructor;
   typedef __true_type    has_trivial_assignment_operator;
   typedef __true_type    has_trivial_destructor;
   typedef __true_type    is_POD_type;
};

template<>  struct __type_traits<int> {
   typedef __true_type    has_trivial_default_constructor;
   typedef __true_type    has_trivial_copy_constructor;
   typedef __true_type    has_trivial_assignment_operator;
   typedef __true_type    has_trivial_destructor;
   typedef __true_type    is_POD_type;
};

template<>  struct __type_traits<unsigned int> {
   typedef __true_type    has_trivial_default_constructor;
   typedef __true_type    has_trivial_copy_constructor;
   typedef __true_type    has_trivial_assignment_operator;
   typedef __true_type    has_trivial_destructor;
   typedef __true_type    is_POD_type;
};

template<>  struct __type_traits<long> {
   typedef __true_type    has_trivial_default_constructor;
   typedef __true_type    has_trivial_copy_constructor;
   typedef __true_type    has_trivial_assignment_operator;
   typedef __true_type    has_trivial_destructor;
   typedef __true_type    is_POD_type;
};

template<>  struct __type_traits<unsigned long> {
   typedef __true_type    has_trivial_default_constructor;
   typedef __true_type    has_trivial_copy_constructor;
   typedef __true_type    has_trivial_assignment_operator;
   typedef __true_type    has_trivial_destructor;
   typedef __true_type    is_POD_type;
};

template<>  struct __type_traits<float> {
   typedef __true_type    has_trivial_default_constructor;
   typedef __true_type    has_trivial_copy_constructor;
   typedef __true_type    has_trivial_assignment_operator;
   typedef __true_type    has_trivial_destructor;
   typedef __true_type    is_POD_type;
};

template<>  struct __type_traits<double> {
   typedef __true_type    has_trivial_default_constructor;
   typedef __true_type    has_trivial_copy_constructor;
   typedef __true_type    has_trivial_assignment_operator;
   typedef __true_type    has_trivial_destructor;
   typedef __true_type    is_POD_type;
};

template<>  struct __type_traits<long double> {
   typedef __true_type    has_trivial_default_constructor;
   typedef __true_type    has_trivial_copy_constructor;
   typedef __true_type    has_trivial_assignment_operator;
   typedef __true_type    has_trivial_destructor;
   typedef __true_type    is_POD_type;
};



template <class T>
struct __type_traits<T*> {
   typedef __true_type    has_trivial_default_constructor;
   typedef __true_type    has_trivial_copy_constructor;
   typedef __true_type    has_trivial_assignment_operator;
   typedef __true_type    has_trivial_destructor;
   typedef __true_type    is_POD_type;
};

# 226 "/u/tveldhui/software/egcs-irix/include/g++/type_traits.h" 3





 
 
 
# 45 "/u/tveldhui/software/egcs-irix/include/g++/stl_algobase.h" 2 3




# 1 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/limits.h" 1 3
 


 

# 114 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/limits.h" 3







# 49 "/u/tveldhui/software/egcs-irix/include/g++/stl_algobase.h" 2 3


# 1 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/stddef.h" 1 3
# 342 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/stddef.h" 3

# 51 "/u/tveldhui/software/egcs-irix/include/g++/stl_algobase.h" 2 3

# 1 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/new.h" 1 3
 




# 1 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/new" 1 3
 
 




#pragma interface "new"
# 1 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/stddef.h" 1 3
# 342 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/stddef.h" 3

# 8 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/new" 2 3



extern "C++" {





  class bad_alloc : public exception {
  public:
    virtual const char* what() const throw() { return "bad_alloc"; }
  };

  struct nothrow_t {};
  extern const nothrow_t nothrow;
  typedef void (*new_handler)();
  new_handler set_new_handler (new_handler);





 
void *operator new (size_t) throw (std::bad_alloc);
void *operator new[] (size_t) throw (std::bad_alloc);
void operator delete (void *) throw();
void operator delete[] (void *) throw();
void *operator new (size_t, const std::nothrow_t&) throw();
void *operator new[] (size_t, const std::nothrow_t&) throw();
void operator delete (void *, const std::nothrow_t&) throw();
void operator delete[] (void *, const std::nothrow_t&) throw();

 
inline void *operator new(size_t, void *place) throw() { return place; }
inline void *operator new[](size_t, void *place) throw() { return place; }
}  


# 6 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/new.h" 2 3








# 52 "/u/tveldhui/software/egcs-irix/include/g++/stl_algobase.h" 2 3







 

template <class ForwardIterator1, class ForwardIterator2, class T>
inline void __iter_swap(ForwardIterator1 a, ForwardIterator2 b, T*) {
  T tmp = *a;
  *a = *b;
  *b = tmp;
}

template <class ForwardIterator1, class ForwardIterator2>
inline void iter_swap(ForwardIterator1 a, ForwardIterator2 b) {
  __iter_swap(a, b, value_type(a));
}

template <class T>
inline void swap(T& a, T& b) {
  T tmp = a;
  a = b;
  b = tmp;
}






template <class T>
inline const T& min(const T& a, const T& b) {
  return b < a ? b : a;
}

template <class T>
inline const T& max(const T& a, const T& b) {
  return  a < b ? b : a;
}



template <class T, class Compare>
inline const T& min(const T& a, const T& b, Compare comp) {
  return comp(b, a) ? b : a;
}

template <class T, class Compare>
inline const T& max(const T& a, const T& b, Compare comp) {
  return comp(a, b) ? b : a;
}

template <class InputIterator, class OutputIterator>
inline OutputIterator __copy(InputIterator first, InputIterator last,
                             OutputIterator result, input_iterator_tag)
{
  for ( ; first != last; ++result, ++first)
    *result = *first;
  return result;
}

template <class RandomAccessIterator, class OutputIterator, class Distance>
inline OutputIterator
__copy_d(RandomAccessIterator first, RandomAccessIterator last,
         OutputIterator result, Distance*)
{
  for (Distance n = last - first; n > 0; --n, ++result, ++first) 
    *result = *first;
  return result;
}

template <class RandomAccessIterator, class OutputIterator>
inline OutputIterator 
__copy(RandomAccessIterator first, RandomAccessIterator last,
       OutputIterator result, random_access_iterator_tag)
{
  return __copy_d(first, last, result, distance_type(first));
}

template <class InputIterator, class OutputIterator>
struct __copy_dispatch
{
  OutputIterator operator()(InputIterator first, InputIterator last,
                            OutputIterator result) {
    return __copy(first, last, result, iterator_category(first));
  }
};



template <class T>
inline T* __copy_t(const T* first, const T* last, T* result, __true_type) {
  memmove(result, first, sizeof(T) * (last - first));
  return result + (last - first);
}

template <class T>
inline T* __copy_t(const T* first, const T* last, T* result, __false_type) {
  return __copy_d(first, last, result, (ptrdiff_t*) 0);
}

template <class T>
struct __copy_dispatch<T*, T*>
{
  T* operator()(T* first, T* last, T* result) {
    typedef typename __type_traits<T>::has_trivial_assignment_operator t; 
    return __copy_t(first, last, result, t());
  }
};

template <class T>
struct __copy_dispatch<const T*, T*>
{
  T* operator()(const T* first, const T* last, T* result) {
    typedef typename __type_traits<T>::has_trivial_assignment_operator t; 
    return __copy_t(first, last, result, t());
  }
};



template <class InputIterator, class OutputIterator>
inline OutputIterator copy(InputIterator first, InputIterator last,
                           OutputIterator result)
{
  return __copy_dispatch<InputIterator,OutputIterator>()(first, last, result);
}

inline char* copy(const char* first, const char* last, char* result) {
  memmove(result, first, last - first);
  return result + (last - first);
}

inline wchar_t* copy(const wchar_t* first, const wchar_t* last,
                     wchar_t* result) {
  memmove(result, first, sizeof(wchar_t) * (last - first));
  return result + (last - first);
}

template <class BidirectionalIterator1, class BidirectionalIterator2>
inline BidirectionalIterator2 __copy_backward(BidirectionalIterator1 first, 
                                              BidirectionalIterator1 last, 
                                              BidirectionalIterator2 result) {
  while (first != last) *--result = *--last;
  return result;
}


template <class BidirectionalIterator1, class BidirectionalIterator2>
struct __copy_backward_dispatch
{
  BidirectionalIterator2 operator()(BidirectionalIterator1 first, 
                                    BidirectionalIterator1 last, 
                                    BidirectionalIterator2 result) {
    return __copy_backward(first, last, result);
  }
};



template <class T>
inline T* __copy_backward_t(const T* first, const T* last, T* result,
                            __true_type) {
  const ptrdiff_t N = last - first;
  memmove(result - N, first, sizeof(T) * N);
  return result - N;
}

template <class T>
inline T* __copy_backward_t(const T* first, const T* last, T* result,
                            __false_type) {
  return __copy_backward(first, last, result);
}

template <class T>
struct __copy_backward_dispatch<T*, T*>
{
  T* operator()(T* first, T* last, T* result) {
    typedef typename __type_traits<T>::has_trivial_assignment_operator t; 
    return __copy_backward_t(first, last, result, t());
  }
};

template <class T>
struct __copy_backward_dispatch<const T*, T*>
{
  T* operator()(const T* first, const T* last, T* result) {
    typedef typename __type_traits<T>::has_trivial_assignment_operator t; 
    return __copy_backward_t(first, last, result, t());
  }
};



template <class BidirectionalIterator1, class BidirectionalIterator2>
inline BidirectionalIterator2 copy_backward(BidirectionalIterator1 first, 
                                            BidirectionalIterator1 last, 
                                            BidirectionalIterator2 result) {
  return __copy_backward_dispatch<BidirectionalIterator1, 
                                  BidirectionalIterator2>()(first, last, 
                                                            result);
}

template <class InputIterator, class Size, class OutputIterator>
pair<InputIterator, OutputIterator> __copy_n(InputIterator first, Size count,
                                             OutputIterator result,
                                             input_iterator_tag) {
  for ( ; count > 0; --count, ++first, ++result)
    *result = *first;
  return pair<InputIterator, OutputIterator>(first, result);
}

template <class RandomAccessIterator, class Size, class OutputIterator>
inline pair<RandomAccessIterator, OutputIterator>
__copy_n(RandomAccessIterator first, Size count,
         OutputIterator result,
         random_access_iterator_tag) {
  RandomAccessIterator last = first + count;
  return pair<RandomAccessIterator, OutputIterator>(last,
                                                    copy(first, last, result));
}

template <class InputIterator, class Size, class OutputIterator>
inline pair<InputIterator, OutputIterator>
copy_n(InputIterator first, Size count,
       OutputIterator result) {
  return __copy_n(first, count, result, iterator_category(first));
}

template <class ForwardIterator, class T>
void fill(ForwardIterator first, ForwardIterator last, const T& value) {
  for ( ; first != last; ++first)
    *first = value;
}

template <class OutputIterator, class Size, class T>
OutputIterator fill_n(OutputIterator first, Size n, const T& value) {
  for ( ; n > 0; --n, ++first)
    *first = value;
  return first;
}

template <class InputIterator1, class InputIterator2>
pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1,
					      InputIterator1 last1,
					      InputIterator2 first2) {
  while (first1 != last1 && *first1 == *first2) {
    ++first1;
    ++first2;
  }
  return pair<InputIterator1, InputIterator2>(first1, first2);
}

template <class InputIterator1, class InputIterator2, class BinaryPredicate>
pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1,
					      InputIterator1 last1,
					      InputIterator2 first2,
					      BinaryPredicate binary_pred) {
  while (first1 != last1 && binary_pred(*first1, *first2)) {
    ++first1;
    ++first2;
  }
  return pair<InputIterator1, InputIterator2>(first1, first2);
}

template <class InputIterator1, class InputIterator2>
inline bool equal(InputIterator1 first1, InputIterator1 last1,
		  InputIterator2 first2) {
  for ( ; first1 != last1; ++first1, ++first2)
    if (*first1 != *first2)
      return false;
  return true;
}

template <class InputIterator1, class InputIterator2, class BinaryPredicate>
inline bool equal(InputIterator1 first1, InputIterator1 last1,
		  InputIterator2 first2, BinaryPredicate binary_pred) {
  for ( ; first1 != last1; ++first1, ++first2)
    if (!binary_pred(*first1, *first2))
      return false;
  return true;
}

template <class InputIterator1, class InputIterator2>
bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
			     InputIterator2 first2, InputIterator2 last2) {
  for ( ; first1 != last1 && first2 != last2; ++first1, ++first2) {
    if (*first1 < *first2)
      return true;
    if (*first2 < *first1)
      return false;
  }
  return first1 == last1 && first2 != last2;
}

template <class InputIterator1, class InputIterator2, class Compare>
bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
			     InputIterator2 first2, InputIterator2 last2,
			     Compare comp) {
  for ( ; first1 != last1 && first2 != last2; ++first1, ++first2) {
    if (comp(*first1, *first2))
      return true;
    if (comp(*first2, *first1))
      return false;
  }
  return first1 == last1 && first2 != last2;
}

inline bool 
lexicographical_compare(const unsigned char* first1,
                        const unsigned char* last1,
                        const unsigned char* first2,
                        const unsigned char* last2)
{
  const size_t len1 = last1 - first1;
  const size_t len2 = last2 - first2;
  const int result = memcmp(first1, first2, min(len1, len2));
  return result != 0 ? result < 0 : len1 < len2;
}

inline bool lexicographical_compare(const char* first1, const char* last1,
                                    const char* first2, const char* last2)
{






  return lexicographical_compare((const unsigned char*) first1,
                                 (const unsigned char*) last1,
                                 (const unsigned char*) first2,
                                 (const unsigned char*) last2);

}

template <class InputIterator1, class InputIterator2>
int lexicographical_compare_3way(InputIterator1 first1, InputIterator1 last1,
                                 InputIterator2 first2, InputIterator2 last2)
{
  while (first1 != last1 && first2 != last2) {
    if (*first1 < *first2) return -1;
    if (*first2 < *first1) return 1;
    ++first1; ++first2;
  }
  if (first2 == last2) {
    return !(first1 == last1);
  } else {
    return -1;
  }
}

inline int
lexicographical_compare_3way(const unsigned char* first1,
                             const unsigned char* last1,
                             const unsigned char* first2,
                             const unsigned char* last2)
{
  const ptrdiff_t len1 = last1 - first1;
  const ptrdiff_t len2 = last2 - first2;
  const int result = memcmp(first1, first2, min(len1, len2));
  return result != 0 ? result : (len1 == len2 ? 0 : (len1 < len2 ? -1 : 1));
}

inline int lexicographical_compare_3way(const char* first1, const char* last1,
                                        const char* first2, const char* last2)
{







  return lexicographical_compare_3way((const unsigned char*) first1,
                                      (const unsigned char*) last1,
                                      (const unsigned char*) first2,
                                      (const unsigned char*) last2);

}

 



 
 
 
# 56 "/u/tveldhui/software/egcs-irix/include/g++/stl_tree.h" 2 3


# 1 "/u/tveldhui/software/egcs-irix/include/g++/stl_construct.h" 1 3
 

























 








 

template <class T>
inline void destroy(T* pointer) {
    pointer->~T();
}

template <class T1, class T2>
inline void construct(T1* p, const T2& value) {
  new (p) T1(value);
}

template <class ForwardIterator>
inline void
__destroy_aux(ForwardIterator first, ForwardIterator last, __false_type) {
  for ( ; first < last; ++first)
    destroy(&*first);
}

template <class ForwardIterator> 
inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type) {}

template <class ForwardIterator, class T>
inline void __destroy(ForwardIterator first, ForwardIterator last, T*) {
  typedef typename __type_traits<T>::has_trivial_destructor trivial_destructor;
  __destroy_aux(first, last, trivial_destructor());
}

template <class ForwardIterator>
inline void destroy(ForwardIterator first, ForwardIterator last) {
  __destroy(first, last, value_type(first));
}

inline void destroy(char*, char*) {}
inline void destroy(wchar_t*, wchar_t*) {}

 



 
 
 
# 58 "/u/tveldhui/software/egcs-irix/include/g++/stl_tree.h" 2 3

# 1 "/u/tveldhui/software/egcs-irix/include/g++/stl_function.h" 1 3
 

























 






 

template <class Arg, class Result>
struct unary_function {
    typedef Arg argument_type;
    typedef Result result_type;
};

template <class Arg1, class Arg2, class Result>
struct binary_function {
    typedef Arg1 first_argument_type;
    typedef Arg2 second_argument_type;
    typedef Result result_type;
};      

template <class T>
struct plus : public binary_function<T, T, T> {
    T operator()(const T& x, const T& y) const { return x + y; }
};

template <class T>
struct minus : public binary_function<T, T, T> {
    T operator()(const T& x, const T& y) const { return x - y; }
};

template <class T>
struct multiplies : public binary_function<T, T, T> {
    T operator()(const T& x, const T& y) const { return x * y; }
};

template <class T>
struct divides : public binary_function<T, T, T> {
    T operator()(const T& x, const T& y) const { return x / y; }
};

template <class T> inline T identity_element(plus<T>) { return T(0); }

template <class T> inline T identity_element(multiplies<T>) { return T(1); }

template <class T>
struct modulus : public binary_function<T, T, T> {
    T operator()(const T& x, const T& y) const { return x % y; }
};

template <class T>
struct negate : public unary_function<T, T> {
    T operator()(const T& x) const { return -x; }
};

template <class T>
struct equal_to : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x == y; }
};

template <class T>
struct not_equal_to : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x != y; }
};

template <class T>
struct greater : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x > y; }
};

template <class T>
struct less : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x < y; }
};

template <class T>
struct greater_equal : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x >= y; }
};

template <class T>
struct less_equal : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x <= y; }
};

template <class T>
struct logical_and : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x && y; }
};

template <class T>
struct logical_or : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x || y; }
};

template <class T>
struct logical_not : public unary_function<T, bool> {
    bool operator()(const T& x) const { return !x; }
};

template <class Predicate>
class unary_negate
  : public unary_function<typename Predicate::argument_type, bool> {
protected:
  Predicate pred;
public:
  explicit unary_negate(const Predicate& x) : pred(x) {}
  bool operator()(const typename Predicate::argument_type& x) const {
    return !pred(x);
  }
};

template <class Predicate>
inline unary_negate<Predicate> not1(const Predicate& pred) {
  return unary_negate<Predicate>(pred);
}

template <class Predicate> 
class binary_negate 
  : public binary_function<typename Predicate::first_argument_type,
                           typename Predicate::second_argument_type,
                           bool> {
protected:
  Predicate pred;
public:
  explicit binary_negate(const Predicate& x) : pred(x) {}
  bool operator()(const typename Predicate::first_argument_type& x, 
                  const typename Predicate::second_argument_type& y) const {
    return !pred(x, y); 
  }
};

template <class Predicate>
inline binary_negate<Predicate> not2(const Predicate& pred) {
  return binary_negate<Predicate>(pred);
}

template <class Operation> 
class binder1st
  : public unary_function<typename Operation::second_argument_type,
                          typename Operation::result_type> {
protected:
  Operation op;
  typename Operation::first_argument_type value;
public:
  binder1st(const Operation& x,
            const typename Operation::first_argument_type& y)
      : op(x), value(y) {}
  typename Operation::result_type
  operator()(const typename Operation::second_argument_type& x) const {
    return op(value, x); 
  }
};

template <class Operation, class T>
inline binder1st<Operation> bind1st(const Operation& op, const T& x) {
  typedef typename Operation::first_argument_type arg1_type;
  return binder1st<Operation>(op, arg1_type(x));
}

template <class Operation> 
class binder2nd
  : public unary_function<typename Operation::first_argument_type,
                          typename Operation::result_type> {
protected:
  Operation op;
  typename Operation::second_argument_type value;
public:
  binder2nd(const Operation& x,
            const typename Operation::second_argument_type& y) 
      : op(x), value(y) {}
  typename Operation::result_type
  operator()(const typename Operation::first_argument_type& x) const {
    return op(x, value); 
  }
};

template <class Operation, class T>
inline binder2nd<Operation> bind2nd(const Operation& op, const T& x) {
  typedef typename Operation::second_argument_type arg2_type;
  return binder2nd<Operation>(op, arg2_type(x));
}

template <class Operation1, class Operation2>
class unary_compose : public unary_function<typename Operation2::argument_type,
                                            typename Operation1::result_type> {
protected:
  Operation1 op1;
  Operation2 op2;
public:
  unary_compose(const Operation1& x, const Operation2& y) : op1(x), op2(y) {}
  typename Operation1::result_type
  operator()(const typename Operation2::argument_type& x) const {
    return op1(op2(x));
  }
};

template <class Operation1, class Operation2>
inline unary_compose<Operation1, Operation2> compose1(const Operation1& op1, 
                                                      const Operation2& op2) {
  return unary_compose<Operation1, Operation2>(op1, op2);
}

template <class Operation1, class Operation2, class Operation3>
class binary_compose
  : public unary_function<typename Operation2::argument_type,
                          typename Operation1::result_type> {
protected:
  Operation1 op1;
  Operation2 op2;
  Operation3 op3;
public:
  binary_compose(const Operation1& x, const Operation2& y, 
                 const Operation3& z) : op1(x), op2(y), op3(z) { }
  typename Operation1::result_type
  operator()(const typename Operation2::argument_type& x) const {
    return op1(op2(x), op3(x));
  }
};

template <class Operation1, class Operation2, class Operation3>
inline binary_compose<Operation1, Operation2, Operation3> 
compose2(const Operation1& op1, const Operation2& op2, const Operation3& op3) {
  return binary_compose<Operation1, Operation2, Operation3>(op1, op2, op3);
}

template <class Arg, class Result>
class pointer_to_unary_function : public unary_function<Arg, Result> {
protected:
  Result (*ptr)(Arg);
public:
  pointer_to_unary_function() {}
  explicit pointer_to_unary_function(Result (*x)(Arg)) : ptr(x) {}
  Result operator()(Arg x) const { return ptr(x); }
};

template <class Arg, class Result>
inline pointer_to_unary_function<Arg, Result> ptr_fun(Result (*x)(Arg)) {
  return pointer_to_unary_function<Arg, Result>(x);
}

template <class Arg1, class Arg2, class Result>
class pointer_to_binary_function : public binary_function<Arg1, Arg2, Result> {
protected:
    Result (*ptr)(Arg1, Arg2);
public:
    pointer_to_binary_function() {}
    explicit pointer_to_binary_function(Result (*x)(Arg1, Arg2)) : ptr(x) {}
    Result operator()(Arg1 x, Arg2 y) const { return ptr(x, y); }
};

template <class Arg1, class Arg2, class Result>
inline pointer_to_binary_function<Arg1, Arg2, Result> 
ptr_fun(Result (*x)(Arg1, Arg2)) {
  return pointer_to_binary_function<Arg1, Arg2, Result>(x);
}

template <class T>
struct identity : public unary_function<T, T> {
  const T& operator()(const T& x) const { return x; }
};

template <class Pair>
struct select1st : public unary_function<Pair, typename Pair::first_type> {
  const typename Pair::first_type& operator()(const Pair& x) const
  {
    return x.first;
  }
};

template <class Pair>
struct select2nd : public unary_function<Pair, typename Pair::second_type> {
  const typename Pair::second_type& operator()(const Pair& x) const
  {
    return x.second;
  }
};

template <class Arg1, class Arg2>
struct project1st : public binary_function<Arg1, Arg2, Arg1> {
  Arg1 operator()(const Arg1& x, const Arg2&) const { return x; }
};

template <class Arg1, class Arg2>
struct project2nd : public binary_function<Arg1, Arg2, Arg2> {
  Arg2 operator()(const Arg1&, const Arg2& y) const { return y; }
};

template <class Result>
struct constant_void_fun
{
  typedef Result result_type;
  result_type val;
  constant_void_fun(const result_type& v) : val(v) {}
  const result_type& operator()() const { return val; }
};  


template <class Result, class Argument = Result>



struct constant_unary_fun : public unary_function<Argument, Result> {
  Result val;
  constant_unary_fun(const Result& v) : val(v) {}
  const Result& operator()(const Argument&) const { return val; }
};


template <class Result, class Arg1 = Result, class Arg2 = Arg1>



struct constant_binary_fun : public binary_function<Arg1, Arg2, Result> {
  Result val;
  constant_binary_fun(const Result& v) : val(v) {}
  const Result& operator()(const Arg1&, const Arg2&) const {
    return val;
  }
};

template <class Result>
inline constant_void_fun<Result> constant0(const Result& val)
{
  return constant_void_fun<Result>(val);
}

template <class Result>
inline constant_unary_fun<Result,Result> constant1(const Result& val)
{
  return constant_unary_fun<Result,Result>(val);
}

template <class Result>
inline constant_binary_fun<Result,Result,Result> constant2(const Result& val)
{
  return constant_binary_fun<Result,Result,Result>(val);
}

 
class subtractive_rng : public unary_function<unsigned int, unsigned int> {
private:
  unsigned int table[55];
  size_t index1;
  size_t index2;
public:
  unsigned int operator()(unsigned int limit) {
    index1 = (index1 + 1) % 55;
    index2 = (index2 + 1) % 55;
    table[index1] = table[index1] - table[index2];
    return table[index1] % limit;
  }

  void initialize(unsigned int seed)
  {
    unsigned int k = 1;
    table[54] = seed;
    size_t i;
    for (i = 0; i < 54; i++) {
        size_t ii = (21 * (i + 1) % 55) - 1;
        table[ii] = k;
        k = seed - k;
        seed = table[ii];
    }
    for (int loop = 0; loop < 4; loop++) {
        for (i = 0; i < 55; i++)
            table[i] = table[i] - table[(1 + i + 30) % 55];
    }
    index1 = 0;
    index2 = 31;
  }

  subtractive_rng(unsigned int seed) { initialize(seed); }
  subtractive_rng() { initialize(161803398u); }
};


 

 
 
 
 
 
 
 

 
 
 
 
 
 
 
 

 
 
 
 


template <class S, class T>
class mem_fun_t : public unary_function<T*, S> {
public:
  explicit mem_fun_t(S (T::*pf)()) : f(pf) {}
  S operator()(T* p) const { return (p->*f)(); }
private:
  S (T::*f)();
};

template <class S, class T>
class const_mem_fun_t : public unary_function<const T*, S> {
public:
  explicit const_mem_fun_t(S (T::*pf)() const) : f(pf) {}
  S operator()(const T* p) const { return (p->*f)(); }
private:
  S (T::*f)() const;
};


template <class S, class T>
class mem_fun_ref_t : public unary_function<T, S> {
public:
  explicit mem_fun_ref_t(S (T::*pf)()) : f(pf) {}
  S operator()(T& r) const { return (r.*f)(); }
private:
  S (T::*f)();
};

template <class S, class T>
class const_mem_fun_ref_t : public unary_function<T, S> {
public:
  explicit const_mem_fun_ref_t(S (T::*pf)() const) : f(pf) {}
  S operator()(const T& r) const { return (r.*f)(); }
private:
  S (T::*f)() const;
};

template <class S, class T, class A>
class mem_fun1_t : public binary_function<T*, A, S> {
public:
  explicit mem_fun1_t(S (T::*pf)(A)) : f(pf) {}
  S operator()(T* p, A x) const { return (p->*f)(x); }
private:
  S (T::*f)(A);
};

template <class S, class T, class A>
class const_mem_fun1_t : public binary_function<const T*, A, S> {
public:
  explicit const_mem_fun1_t(S (T::*pf)(A) const) : f(pf) {}
  S operator()(const T* p, A x) const { return (p->*f)(x); }
private:
  S (T::*f)(A) const;
};

template <class S, class T, class A>
class mem_fun1_ref_t : public binary_function<T, A, S> {
public:
  explicit mem_fun1_ref_t(S (T::*pf)(A)) : f(pf) {}
  S operator()(T& r, A x) const { return (r.*f)(x); }
private:
  S (T::*f)(A);
};

template <class S, class T, class A>
class const_mem_fun1_ref_t : public binary_function<T, A, S> {
public:
  explicit const_mem_fun1_ref_t(S (T::*pf)(A) const) : f(pf) {}
  S operator()(const T& r, A x) const { return (r.*f)(x); }
private:
  S (T::*f)(A) const;
};



template <class T>
class mem_fun_t<void, T> : public unary_function<T*, void> {
public:
  explicit mem_fun_t(void (T::*pf)()) : f(pf) {}
  void operator()(T* p) const { (p->*f)(); }
private:
  void (T::*f)();
};

template <class T>
class const_mem_fun_t<void, T> : public unary_function<const T*, void> {
public:
  explicit const_mem_fun_t(void (T::*pf)() const) : f(pf) {}
  void operator()(const T* p) const { (p->*f)(); }
private:
  void (T::*f)() const;
};

template <class T>
class mem_fun_ref_t<void, T> : public unary_function<T, void> {
public:
  explicit mem_fun_ref_t(void (T::*pf)()) : f(pf) {}
  void operator()(T& r) const { (r.*f)(); }
private:
  void (T::*f)();
};

template <class T>
class const_mem_fun_ref_t<void, T> : public unary_function<T, void> {
public:
  explicit const_mem_fun_ref_t(void (T::*pf)() const) : f(pf) {}
  void operator()(const T& r) const { (r.*f)(); }
private:
  void (T::*f)() const;
};

template <class T, class A>
class mem_fun1_t<void, T, A> : public binary_function<T*, A, void> {
public:
  explicit mem_fun1_t(void (T::*pf)(A)) : f(pf) {}
  void operator()(T* p, A x) const { (p->*f)(x); }
private:
  void (T::*f)(A);
};

template <class T, class A>
class const_mem_fun1_t<void, T, A> : public binary_function<const T*, A, void> {
public:
  explicit const_mem_fun1_t(void (T::*pf)(A) const) : f(pf) {}
  void operator()(const T* p, A x) const { (p->*f)(x); }
private:
  void (T::*f)(A) const;
};

template <class T, class A>
class mem_fun1_ref_t<void, T, A> : public binary_function<T, A, void> {
public:
  explicit mem_fun1_ref_t(void (T::*pf)(A)) : f(pf) {}
  void operator()(T& r, A x) const { (r.*f)(x); }
private:
  void (T::*f)(A);
};

template <class T, class A>
class const_mem_fun1_ref_t<void, T, A> : public binary_function<T, A, void> {
public:
  explicit const_mem_fun1_ref_t(void (T::*pf)(A) const) : f(pf) {}
  void operator()(const T& r, A x) const { (r.*f)(x); }
private:
  void (T::*f)(A) const;
};



 
 

template <class S, class T>
inline mem_fun_t<S,T> mem_fun(S (T::*f)()) { 
  return mem_fun_t<S,T>(f);
}

template <class S, class T>
inline const_mem_fun_t<S,T> mem_fun(S (T::*f)() const) {
  return const_mem_fun_t<S,T>(f);
}

template <class S, class T>
inline mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)()) { 
  return mem_fun_ref_t<S,T>(f);
}

template <class S, class T>
inline const_mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)() const) {
  return const_mem_fun_ref_t<S,T>(f);
}

template <class S, class T, class A>
inline mem_fun1_t<S,T,A> mem_fun1(S (T::*f)(A)) { 
  return mem_fun1_t<S,T,A>(f);
}

template <class S, class T, class A>
inline const_mem_fun1_t<S,T,A> mem_fun1(S (T::*f)(A) const) {
  return const_mem_fun1_t<S,T,A>(f);
}

template <class S, class T, class A>
inline mem_fun1_ref_t<S,T,A> mem_fun1_ref(S (T::*f)(A)) { 
  return mem_fun1_ref_t<S,T,A>(f);
}

template <class S, class T, class A>
inline const_mem_fun1_ref_t<S,T,A> mem_fun1_ref(S (T::*f)(A) const) {
  return const_mem_fun1_ref_t<S,T,A>(f);
}

 



 
 
 
# 59 "/u/tveldhui/software/egcs-irix/include/g++/stl_tree.h" 2 3


  

typedef bool __rb_tree_color_type;
const __rb_tree_color_type __rb_tree_red = false;
const __rb_tree_color_type __rb_tree_black = true;

struct __rb_tree_node_base
{
  typedef __rb_tree_color_type color_type;
  typedef __rb_tree_node_base* base_ptr;

  color_type color; 
  base_ptr parent;
  base_ptr left;
  base_ptr right;

  static base_ptr minimum(base_ptr x)
  {
    while (x->left != 0) x = x->left;
    return x;
  }

  static base_ptr maximum(base_ptr x)
  {
    while (x->right != 0) x = x->right;
    return x;
  }
};

template <class Value>
struct __rb_tree_node : public __rb_tree_node_base
{
  typedef __rb_tree_node<Value>* link_type;
  Value value_field;
};


struct __rb_tree_base_iterator
{
  typedef __rb_tree_node_base::base_ptr base_ptr;
  typedef bidirectional_iterator_tag iterator_category;
  typedef ptrdiff_t difference_type;
  base_ptr node;

  void increment()
  {
    if (node->right != 0) {
      node = node->right;
      while (node->left != 0)
        node = node->left;
    }
    else {
      base_ptr y = node->parent;
      while (node == y->right) {
        node = y;
        y = y->parent;
      }
      if (node->right != y)
        node = y;
    }
  }

  void decrement()
  {
    if (node->color == __rb_tree_red &&
        node->parent->parent == node)
      node = node->right;
    else if (node->left != 0) {
      base_ptr y = node->left;
      while (y->right != 0)
        y = y->right;
      node = y;
    }
    else {
      base_ptr y = node->parent;
      while (node == y->left) {
        node = y;
        y = y->parent;
      }
      node = y;
    }
  }
};

template <class Value, class Ref, class Ptr>
struct __rb_tree_iterator : public __rb_tree_base_iterator
{
  typedef Value value_type;
  typedef Ref reference;
  typedef Ptr pointer;
  typedef __rb_tree_iterator<Value, Value&, Value*>             iterator;
  typedef __rb_tree_iterator<Value, const Value&, const Value*> const_iterator;
  typedef __rb_tree_iterator<Value, Ref, Ptr>                   self;
  typedef __rb_tree_node<Value>* link_type;

  __rb_tree_iterator() {}
  __rb_tree_iterator(link_type x) { node = x; }
  __rb_tree_iterator(const iterator& it) { node = it.node; }

  reference operator*() const { return link_type(node)->value_field; }

  pointer operator->() const { return &(operator*()); }


  self& operator++() { increment(); return *this; }
  self operator++(int) {
    self tmp = *this;
    increment();
    return tmp;
  }
    
  self& operator--() { decrement(); return *this; }
  self operator--(int) {
    self tmp = *this;
    decrement();
    return tmp;
  }
};

inline bool operator==(const __rb_tree_base_iterator& x,
                       const __rb_tree_base_iterator& y) {
  return x.node == y.node;
}

inline bool operator!=(const __rb_tree_base_iterator& x,
                       const __rb_tree_base_iterator& y) {
  return x.node != y.node;
}

# 207 "/u/tveldhui/software/egcs-irix/include/g++/stl_tree.h" 3


inline void 
__rb_tree_rotate_left(__rb_tree_node_base* x, __rb_tree_node_base*& root)
{
  __rb_tree_node_base* y = x->right;
  x->right = y->left;
  if (y->left !=0)
    y->left->parent = x;
  y->parent = x->parent;

  if (x == root)
    root = y;
  else if (x == x->parent->left)
    x->parent->left = y;
  else
    x->parent->right = y;
  y->left = x;
  x->parent = y;
}

inline void 
__rb_tree_rotate_right(__rb_tree_node_base* x, __rb_tree_node_base*& root)
{
  __rb_tree_node_base* y = x->left;
  x->left = y->right;
  if (y->right != 0)
    y->right->parent = x;
  y->parent = x->parent;

  if (x == root)
    root = y;
  else if (x == x->parent->right)
    x->parent->right = y;
  else
    x->parent->left = y;
  y->right = x;
  x->parent = y;
}

inline void 
__rb_tree_rebalance(__rb_tree_node_base* x, __rb_tree_node_base*& root)
{
  x->color = __rb_tree_red;
  while (x != root && x->parent->color == __rb_tree_red) {
    if (x->parent == x->parent->parent->left) {
      __rb_tree_node_base* y = x->parent->parent->right;
      if (y && y->color == __rb_tree_red) {
        x->parent->color = __rb_tree_black;
        y->color = __rb_tree_black;
        x->parent->parent->color = __rb_tree_red;
        x = x->parent->parent;
      }
      else {
        if (x == x->parent->right) {
          x = x->parent;
          __rb_tree_rotate_left(x, root);
        }
        x->parent->color = __rb_tree_black;
        x->parent->parent->color = __rb_tree_red;
        __rb_tree_rotate_right(x->parent->parent, root);
      }
    }
    else {
      __rb_tree_node_base* y = x->parent->parent->left;
      if (y && y->color == __rb_tree_red) {
        x->parent->color = __rb_tree_black;
        y->color = __rb_tree_black;
        x->parent->parent->color = __rb_tree_red;
        x = x->parent->parent;
      }
      else {
        if (x == x->parent->left) {
          x = x->parent;
          __rb_tree_rotate_right(x, root);
        }
        x->parent->color = __rb_tree_black;
        x->parent->parent->color = __rb_tree_red;
        __rb_tree_rotate_left(x->parent->parent, root);
      }
    }
  }
  root->color = __rb_tree_black;
}

inline __rb_tree_node_base*
__rb_tree_rebalance_for_erase(__rb_tree_node_base* z,
                              __rb_tree_node_base*& root,
                              __rb_tree_node_base*& leftmost,
                              __rb_tree_node_base*& rightmost)
{
  __rb_tree_node_base* y = z;
  __rb_tree_node_base* x = 0;
  __rb_tree_node_base* x_parent = 0;
  if (y->left == 0)              
    x = y->right;                
  else
    if (y->right == 0)           
      x = y->left;               
    else {                       
      y = y->right;              
      while (y->left != 0)
        y = y->left;
      x = y->right;
    }
  if (y != z) {                  
    z->left->parent = y; 
    y->left = z->left;
    if (y != z->right) {
      x_parent = y->parent;
      if (x) x->parent = y->parent;
      y->parent->left = x;       
      y->right = z->right;
      z->right->parent = y;
    }
    else
      x_parent = y;  
    if (root == z)
      root = y;
    else if (z->parent->left == z)
      z->parent->left = y;
    else 
      z->parent->right = y;
    y->parent = z->parent;
     ::swap(y->color, z->color);
    y = z;
     
  }
  else {                         
    x_parent = y->parent;
    if (x) x->parent = y->parent;   
    if (root == z)
      root = x;
    else 
      if (z->parent->left == z)
        z->parent->left = x;
      else
        z->parent->right = x;
    if (leftmost == z) 
      if (z->right == 0)         
        leftmost = z->parent;
     
      else
        leftmost = __rb_tree_node_base::minimum(x);
    if (rightmost == z)  
      if (z->left == 0)          
        rightmost = z->parent;  
     
      else                       
        rightmost = __rb_tree_node_base::maximum(x);
  }
  if (y->color != __rb_tree_red) { 
    while (x != root && (x == 0 || x->color == __rb_tree_black))
      if (x == x_parent->left) {
        __rb_tree_node_base* w = x_parent->right;
        if (w->color == __rb_tree_red) {
          w->color = __rb_tree_black;
          x_parent->color = __rb_tree_red;
          __rb_tree_rotate_left(x_parent, root);
          w = x_parent->right;
        }
        if ((w->left == 0 || w->left->color == __rb_tree_black) &&
            (w->right == 0 || w->right->color == __rb_tree_black)) {
          w->color = __rb_tree_red;
          x = x_parent;
          x_parent = x_parent->parent;
        } else {
          if (w->right == 0 || w->right->color == __rb_tree_black) {
            if (w->left) w->left->color = __rb_tree_black;
            w->color = __rb_tree_red;
            __rb_tree_rotate_right(w, root);
            w = x_parent->right;
          }
          w->color = x_parent->color;
          x_parent->color = __rb_tree_black;
          if (w->right) w->right->color = __rb_tree_black;
          __rb_tree_rotate_left(x_parent, root);
          break;
        }
      } else {                   
        __rb_tree_node_base* w = x_parent->left;
        if (w->color == __rb_tree_red) {
          w->color = __rb_tree_black;
          x_parent->color = __rb_tree_red;
          __rb_tree_rotate_right(x_parent, root);
          w = x_parent->left;
        }
        if ((w->right == 0 || w->right->color == __rb_tree_black) &&
            (w->left == 0 || w->left->color == __rb_tree_black)) {
          w->color = __rb_tree_red;
          x = x_parent;
          x_parent = x_parent->parent;
        } else {
          if (w->left == 0 || w->left->color == __rb_tree_black) {
            if (w->right) w->right->color = __rb_tree_black;
            w->color = __rb_tree_red;
            __rb_tree_rotate_left(w, root);
            w = x_parent->left;
          }
          w->color = x_parent->color;
          x_parent->color = __rb_tree_black;
          if (w->left) w->left->color = __rb_tree_black;
          __rb_tree_rotate_right(x_parent, root);
          break;
        }
      }
    if (x) x->color = __rb_tree_black;
  }
  return y;
}

template <class Key, class Value, class KeyOfValue, class Compare,
          class Alloc = alloc>
class rb_tree {
protected:
  typedef void* void_pointer;
  typedef __rb_tree_node_base* base_ptr;
  typedef __rb_tree_node<Value> rb_tree_node;
  typedef simple_alloc<rb_tree_node, Alloc> rb_tree_node_allocator;
  typedef __rb_tree_color_type color_type;
public:
  typedef Key key_type;
  typedef Value value_type;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef rb_tree_node* link_type;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
protected:
  link_type get_node() { return rb_tree_node_allocator::allocate(); }
  void put_node(link_type p) { rb_tree_node_allocator::deallocate(p); }

  link_type create_node(const value_type& x) {
    link_type tmp = get_node();
    try  {
      construct(&tmp->value_field, x);
    }
    catch(...) {  put_node(tmp) ; throw; } ;
    return tmp;
  }

  link_type clone_node(link_type x) {
    link_type tmp = create_node(x->value_field);
    tmp->color = x->color;
    tmp->left = 0;
    tmp->right = 0;
    return tmp;
  }

  void destroy_node(link_type p) {
    destroy(&p->value_field);
    put_node(p);
  }

protected:
  size_type node_count;  
  link_type header;  
  Compare key_compare;

  link_type& root() const { return (link_type&) header->parent; }
  link_type& leftmost() const { return (link_type&) header->left; }
  link_type& rightmost() const { return (link_type&) header->right; }

  static link_type& left(link_type x) { return (link_type&)(x->left); }
  static link_type& right(link_type x) { return (link_type&)(x->right); }
  static link_type& parent(link_type x) { return (link_type&)(x->parent); }
  static reference value(link_type x) { return x->value_field; }
  static const Key& key(link_type x) { return KeyOfValue()(value(x)); }
  static color_type& color(link_type x) { return (color_type&)(x->color); }

  static link_type& left(base_ptr x) { return (link_type&)(x->left); }
  static link_type& right(base_ptr x) { return (link_type&)(x->right); }
  static link_type& parent(base_ptr x) { return (link_type&)(x->parent); }
  static reference value(base_ptr x) { return ((link_type)x)->value_field; }
  static const Key& key(base_ptr x) { return KeyOfValue()(value(link_type(x)));} 
  static color_type& color(base_ptr x) { return (color_type&)(link_type(x)->color); }

  static link_type minimum(link_type x) { 
    return (link_type)  __rb_tree_node_base::minimum(x);
  }
  static link_type maximum(link_type x) {
    return (link_type) __rb_tree_node_base::maximum(x);
  }

public:
  typedef __rb_tree_iterator<value_type, reference, pointer> iterator;
  typedef __rb_tree_iterator<value_type, const_reference, const_pointer> 
          const_iterator;


  typedef reverse_iterator<const_iterator> const_reverse_iterator;
  typedef reverse_iterator<iterator> reverse_iterator;







 
private:
  iterator __insert(base_ptr x, base_ptr y, const value_type& v);
  link_type __copy(link_type x, link_type p);
  void __erase(link_type x);
  void init() {
    header = get_node();
    color(header) = __rb_tree_red;  
                                    
    root() = 0;
    leftmost() = header;
    rightmost() = header;
  }
public:
                                 
  rb_tree(const Compare& comp = Compare())
    : node_count(0), key_compare(comp) { init(); }

  rb_tree(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x) 
    : node_count(0), key_compare(x.key_compare)
  { 
    header = get_node();
    color(header) = __rb_tree_red;
    if (x.root() == 0) {
      root() = 0;
      leftmost() = header;
      rightmost() = header;
    }
    else {
      try  {
        root() = __copy(x.root(), header);
      }
      catch(...) {  put_node(header) ; throw; } ;
      leftmost() = minimum(root());
      rightmost() = maximum(root());
    }
    node_count = x.node_count;
  }
  ~rb_tree() {
    clear();
    put_node(header);
  }
  rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& 
  operator=(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x);

public:    
                                 
  Compare key_comp() const { return key_compare; }
  iterator begin() { return leftmost(); }
  const_iterator begin() const { return leftmost(); }
  iterator end() { return header; }
  const_iterator end() const { return header; }
  reverse_iterator rbegin() { return reverse_iterator(end()); }
  const_reverse_iterator rbegin() const { 
    return const_reverse_iterator(end()); 
  }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rend() const { 
    return const_reverse_iterator(begin());
  } 
  bool empty() const { return node_count == 0; }
  size_type size() const { return node_count; }
  size_type max_size() const { return size_type(-1); }

  void swap(rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& t) {
     ::swap(header, t.header);
     ::swap(node_count, t.node_count);
     ::swap(key_compare, t.key_compare);
  }
    
public:
                                 
  pair<iterator,bool> insert_unique(const value_type& x);
  iterator insert_equal(const value_type& x);

  iterator insert_unique(iterator position, const value_type& x);
  iterator insert_equal(iterator position, const value_type& x);


  template <class InputIterator>
  void insert_unique(InputIterator first, InputIterator last);
  template <class InputIterator>
  void insert_equal(InputIterator first, InputIterator last);







  void erase(iterator position);
  size_type erase(const key_type& x);
  void erase(iterator first, iterator last);
  void erase(const key_type* first, const key_type* last);
  void clear() {
    if (node_count != 0) {
      __erase(root());
      leftmost() = header;
      root() = 0;
      rightmost() = header;
      node_count = 0;
    }
  }      

public:
                                 
  iterator find(const key_type& x);
  const_iterator find(const key_type& x) const;
  size_type count(const key_type& x) const;
  iterator lower_bound(const key_type& x);
  const_iterator lower_bound(const key_type& x) const;
  iterator upper_bound(const key_type& x);
  const_iterator upper_bound(const key_type& x) const;
  pair<iterator,iterator> equal_range(const key_type& x);
  pair<const_iterator, const_iterator> equal_range(const key_type& x) const;

public:
                                 
  bool __rb_verify() const;
};

template <class Key, class Value, class KeyOfValue, class Compare, class Alloc>
inline bool operator==(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x, 
                       const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& y) {
  return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());
}

template <class Key, class Value, class KeyOfValue, class Compare, class Alloc>
inline bool operator<(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x, 
                      const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& y) {
  return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
}



template <class Key, class Value, class KeyOfValue, class Compare, class Alloc>
inline void swap(rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x, 
                 rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& y) {
  x.swap(y);
}




template <class Key, class Value, class KeyOfValue, class Compare, class Alloc>
rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& 
rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::
operator=(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x) {
  if (this != &x) {
                                 
    clear();
    node_count = 0;
    key_compare = x.key_compare;        
    if (x.root() == 0) {
      root() = 0;
      leftmost() = header;
      rightmost() = header;
    }
    else {
      root() = __copy(x.root(), header);
      leftmost() = minimum(root());
      rightmost() = maximum(root());
      node_count = x.node_count;
    }
  }
  return *this;
}

template <class Key, class Value, class KeyOfValue, class Compare, class Alloc>
typename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::iterator
rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::
__insert(base_ptr x_, base_ptr y_, const Value& v) {
  link_type x = (link_type) x_;
  link_type y = (link_type) y_;
  link_type z;

  if (y == header || x != 0 || key_compare(KeyOfValue()(v), key(y))) {
    z = create_node(v);
    left(y) = z;                 
    if (y == header) {
      root() = z;
      rightmost() = z;
    }
    else if (y == leftmost())
      leftmost() = z;            
  }
  else {
    z = create_node(v);
    right(y) = z;
    if (y == rightmost())
      rightmost() = z;           
  }
  parent(z) = y;
  left(z) = 0;
  right(z) = 0;
  __rb_tree_rebalance(z, header->parent);
  ++node_count;
  return iterator(z);
}

template <class Key, class Value, class KeyOfValue, class Compare, class Alloc>
typename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::iterator
rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::insert_equal(const Value& v)
{
  link_type y = header;
  link_type x = root();
  while (x != 0) {
    y = x;
    x = key_compare(KeyOfValue()(v), key(x)) ? left(x) : right(x);
  }
  return __insert(x, y, v);
}


template <class Key, class Value, class KeyOfValue, class Compare, class Alloc>
pair<typename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::iterator, bool>
rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::insert_unique(const Value& v)
{
  link_type y = header;
  link_type x = root();
  bool comp = true;
  while (x != 0) {
    y = x;
    comp = key_compare(KeyOfValue()(v), key(x));
    x = comp ? left(x) : right(x);
  }
  iterator j = iterator(y);   
  if (comp)
    if (j == begin())     
      return pair<iterator,bool>(__insert(x, y, v), true);
    else
      --j;
  if (key_compare(key(j.node), KeyOfValue()(v)))
    return pair<iterator,bool>(__insert(x, y, v), true);
  return pair<iterator,bool>(j, false);
}


template <class Key, class Val, class KeyOfValue, class Compare, class Alloc>
typename rb_tree<Key, Val, KeyOfValue, Compare, Alloc>::iterator 
rb_tree<Key, Val, KeyOfValue, Compare, Alloc>::insert_unique(iterator position,
                                                             const Val& v) {
  if (position.node == header->left)  
    if (size() > 0 && key_compare(KeyOfValue()(v), key(position.node)))
      return __insert(position.node, position.node, v);
   
    else
      return insert_unique(v).first;
  else if (position.node == header)  
    if (key_compare(key(rightmost()), KeyOfValue()(v)))
      return __insert(0, rightmost(), v);
    else
      return insert_unique(v).first;
  else {
    iterator before = position;
    --before;
    if (key_compare(key(before.node), KeyOfValue()(v))
        && key_compare(KeyOfValue()(v), key(position.node)))
      if (right(before.node) == 0)
        return __insert(0, before.node, v); 
      else
        return __insert(position.node, position.node, v);
     
    else
      return insert_unique(v).first;
  }
}

template <class Key, class Val, class KeyOfValue, class Compare, class Alloc>
typename rb_tree<Key, Val, KeyOfValue, Compare, Alloc>::iterator 
rb_tree<Key, Val, KeyOfValue, Compare, Alloc>::insert_equal(iterator position,
                                                            const Val& v) {
  if (position.node == header->left)  
    if (size() > 0 && key_compare(KeyOfValue()(v), key(position.node)))
      return __insert(position.node, position.node, v);
   
    else
      return insert_equal(v);
  else if (position.node == header)  
    if (!key_compare(KeyOfValue()(v), key(rightmost())))
      return __insert(0, rightmost(), v);
    else
      return insert_equal(v);
  else {
    iterator before = position;
    --before;
    if (!key_compare(KeyOfValue()(v), key(before.node))
        && !key_compare(key(position.node), KeyOfValue()(v)))
      if (right(before.node) == 0)
        return __insert(0, before.node, v); 
      else
        return __insert(position.node, position.node, v);
     
    else
      return insert_equal(v);
  }
}



template <class K, class V, class KoV, class Cmp, class Al> template<class II>
void rb_tree<K, V, KoV, Cmp, Al>::insert_equal(II first, II last) {
  for ( ; first != last; ++first)
    insert_equal(*first);
}

template <class K, class V, class KoV, class Cmp, class Al> template<class II>
void rb_tree<K, V, KoV, Cmp, Al>::insert_unique(II first, II last) {
  for ( ; first != last; ++first)
    insert_unique(*first);
}

# 852 "/u/tveldhui/software/egcs-irix/include/g++/stl_tree.h" 3

         
template <class Key, class Value, class KeyOfValue, class Compare, class Alloc>
inline void
rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(iterator position) {
  link_type y = (link_type) __rb_tree_rebalance_for_erase(position.node,
                                                          header->parent,
                                                          header->left,
                                                          header->right);
  destroy_node(y);
  --node_count;
}

template <class Key, class Value, class KeyOfValue, class Compare, class Alloc>
typename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::size_type 
rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(const Key& x) {
  pair<iterator,iterator> p = equal_range(x);
  size_type n = 0;
  distance(p.first, p.second, n);
  erase(p.first, p.second);
  return n;
}

template <class K, class V, class KeyOfValue, class Compare, class Alloc>
typename rb_tree<K, V, KeyOfValue, Compare, Alloc>::link_type 
rb_tree<K, V, KeyOfValue, Compare, Alloc>::__copy(link_type x, link_type p) {
                                 
  link_type top = clone_node(x);
  top->parent = p;
 
  try  {
    if (x->right)
      top->right = __copy(right(x), top);
    p = top;
    x = left(x);

    while (x != 0) {
      link_type y = clone_node(x);
      p->left = y;
      y->parent = p;
      if (x->right)
        y->right = __copy(right(x), y);
      p = y;
      x = left(x);
    }
  }
  catch(...) {  __erase(top) ; throw; } ;

  return top;
}

template <class Key, class Value, class KeyOfValue, class Compare, class Alloc>
void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::__erase(link_type x) {
                                 
  while (x != 0) {
    __erase(right(x));
    link_type y = left(x);
    destroy_node(x);
    x = y;
  }
}

template <class Key, class Value, class KeyOfValue, class Compare, class Alloc>
void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(iterator first, 
                                                            iterator last) {
  if (first == begin() && last == end())
    clear();
  else
    while (first != last) erase(first++);
}

template <class Key, class Value, class KeyOfValue, class Compare, class Alloc>
void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(const Key* first, 
                                                            const Key* last) {
  while (first != last) erase(*first++);
}

template <class Key, class Value, class KeyOfValue, class Compare, class Alloc>
typename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::iterator 
rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::find(const Key& k) {
  link_type y = header;         
  link_type x = root();         

  while (x != 0) 
    if (!key_compare(key(x), k))
      y = x, x = left(x);
    else
      x = right(x);

  iterator j = iterator(y);   
  return (j == end() || key_compare(k, key(j.node))) ? end() : j;
}

template <class Key, class Value, class KeyOfValue, class Compare, class Alloc>
typename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::const_iterator 
rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::find(const Key& k) const {
  link_type y = header;  
  link_type x = root();  

  while (x != 0) {
    if (!key_compare(key(x), k))
      y = x, x = left(x);
    else
      x = right(x);
  }
  const_iterator j = const_iterator(y);   
  return (j == end() || key_compare(k, key(j.node))) ? end() : j;
}

template <class Key, class Value, class KeyOfValue, class Compare, class Alloc>
typename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::size_type 
rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::count(const Key& k) const {
  pair<const_iterator, const_iterator> p = equal_range(k);
  size_type n = 0;
  distance(p.first, p.second, n);
  return n;
}

template <class Key, class Value, class KeyOfValue, class Compare, class Alloc>
typename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::iterator 
rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::lower_bound(const Key& k) {
  link_type y = header;  
  link_type x = root();  

  while (x != 0) 
    if (!key_compare(key(x), k))
      y = x, x = left(x);
    else
      x = right(x);

  return iterator(y);
}

template <class Key, class Value, class KeyOfValue, class Compare, class Alloc>
typename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::const_iterator 
rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::lower_bound(const Key& k) const {
  link_type y = header;  
  link_type x = root();  

  while (x != 0) 
    if (!key_compare(key(x), k))
      y = x, x = left(x);
    else
      x = right(x);

  return const_iterator(y);
}

template <class Key, class Value, class KeyOfValue, class Compare, class Alloc>
typename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::iterator 
rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::upper_bound(const Key& k) {
  link_type y = header;  
  link_type x = root();  

   while (x != 0) 
     if (key_compare(k, key(x)))
       y = x, x = left(x);
     else
       x = right(x);

   return iterator(y);
}

template <class Key, class Value, class KeyOfValue, class Compare, class Alloc>
typename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::const_iterator 
rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::upper_bound(const Key& k) const {
  link_type y = header;  
  link_type x = root();  

   while (x != 0) 
     if (key_compare(k, key(x)))
       y = x, x = left(x);
     else
       x = right(x);

   return const_iterator(y);
}

template <class Key, class Value, class KeyOfValue, class Compare, class Alloc>
inline pair<typename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::iterator,
            typename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::iterator>
rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::equal_range(const Key& k) {
  return pair<iterator, iterator>(lower_bound(k), upper_bound(k));
}

template <class Key, class Value, class KoV, class Compare, class Alloc>
inline pair<typename rb_tree<Key, Value, KoV, Compare, Alloc>::const_iterator,
            typename rb_tree<Key, Value, KoV, Compare, Alloc>::const_iterator>
rb_tree<Key, Value, KoV, Compare, Alloc>::equal_range(const Key& k) const {
  return pair<const_iterator,const_iterator>(lower_bound(k), upper_bound(k));
}

inline int __black_count(__rb_tree_node_base* node, __rb_tree_node_base* root)
{
  if (node == 0)
    return 0;
  else {
    int bc = node->color == __rb_tree_black ? 1 : 0;
    if (node == root)
      return bc;
    else
      return bc + __black_count(node->parent, root);
  }
}

template <class Key, class Value, class KeyOfValue, class Compare, class Alloc>
bool 
rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::__rb_verify() const
{
  if (node_count == 0 || begin() == end())
    return node_count == 0 && begin() == end() &&
      header->left == header && header->right == header;
  
  int len = __black_count(leftmost(), root());
  for (const_iterator it = begin(); it != end(); ++it) {
    link_type x = (link_type) it.node;
    link_type L = left(x);
    link_type R = right(x);

    if (x->color == __rb_tree_red)
      if ((L && L->color == __rb_tree_red) ||
          (R && R->color == __rb_tree_red))
        return false;

    if (L && key_compare(key(x), key(L)))
      return false;
    if (R && key_compare(key(R), key(x)))
      return false;

    if (!L && !R && __black_count(x, root()) != len)
      return false;
  }

  if (leftmost() != __rb_tree_node_base::minimum(root()))
    return false;
  if (rightmost() != __rb_tree_node_base::maximum(root()))
    return false;

  return true;
}

  



 
 
 
# 31 "/u/tveldhui/software/egcs-irix/include/g++/set" 2 3


# 1 "/u/tveldhui/software/egcs-irix/include/g++/stl_set.h" 1 3
 

























 






 






template <class Key, class Compare = less<Key>, class Alloc = alloc>



class set {
public:
   

  typedef Key key_type;
  typedef Key value_type;
  typedef Compare key_compare;
  typedef Compare value_compare;
private:
  typedef rb_tree<key_type, value_type, 
                  identity<value_type>, key_compare, Alloc> rep_type;
  rep_type t;   
public:
  typedef typename rep_type::const_pointer pointer;
  typedef typename rep_type::const_pointer const_pointer;
  typedef typename rep_type::const_reference reference;
  typedef typename rep_type::const_reference const_reference;
  typedef typename rep_type::const_iterator iterator;
  typedef typename rep_type::const_iterator const_iterator;
  typedef typename rep_type::const_reverse_iterator reverse_iterator;
  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;
  typedef typename rep_type::size_type size_type;
  typedef typename rep_type::difference_type difference_type;

   

  set() : t(Compare()) {}
  explicit set(const Compare& comp) : t(comp) {}


  template <class InputIterator>
  set(InputIterator first, InputIterator last)
    : t(Compare()) { t.insert_unique(first, last); }

  template <class InputIterator>
  set(InputIterator first, InputIterator last, const Compare& comp)
    : t(comp) { t.insert_unique(first, last); }
# 92 "/u/tveldhui/software/egcs-irix/include/g++/stl_set.h" 3


  set(const set<Key, Compare, Alloc>& x) : t(x.t) {}
  set<Key, Compare, Alloc>& operator=(const set<Key, Compare, Alloc>& x) { 
    t = x.t; 
    return *this;
  }

   

  key_compare key_comp() const { return t.key_comp(); }
  value_compare value_comp() const { return t.key_comp(); }
  iterator begin() const { return t.begin(); }
  iterator end() const { return t.end(); }
  reverse_iterator rbegin() const { return t.rbegin(); } 
  reverse_iterator rend() const { return t.rend(); }
  bool empty() const { return t.empty(); }
  size_type size() const { return t.size(); }
  size_type max_size() const { return t.max_size(); }
  void swap(set<Key, Compare, Alloc>& x) { t.swap(x.t); }

   
  typedef  pair<iterator, bool> pair_iterator_bool; 
  pair<iterator,bool> insert(const value_type& x) { 
    pair<typename rep_type::iterator, bool> p = t.insert_unique(x); 
    return pair<iterator, bool>(p.first, p.second);
  }
  iterator insert(iterator position, const value_type& x) {
    typedef typename rep_type::iterator rep_iterator;
    return t.insert_unique((rep_iterator&)position, x);
  }

  template <class InputIterator>
  void insert(InputIterator first, InputIterator last) {
    t.insert_unique(first, last);
  }








  void erase(iterator position) { 
    typedef typename rep_type::iterator rep_iterator;
    t.erase((rep_iterator&)position); 
  }
  size_type erase(const key_type& x) { 
    return t.erase(x); 
  }
  void erase(iterator first, iterator last) { 
    typedef typename rep_type::iterator rep_iterator;
    t.erase((rep_iterator&)first, (rep_iterator&)last); 
  }
  void clear() { t.clear(); }

   

  iterator find(const key_type& x) const { return t.find(x); }
  size_type count(const key_type& x) const { return t.count(x); }
  iterator lower_bound(const key_type& x) const {
    return t.lower_bound(x);
  }
  iterator upper_bound(const key_type& x) const {
    return t.upper_bound(x); 
  }
  pair<iterator,iterator> equal_range(const key_type& x) const {
    return t.equal_range(x);
  }
  friend bool operator== <>  (const set&, const set&);
  friend bool operator< <>  (const set&, const set&);
};

template <class Key, class Compare, class Alloc>
inline bool operator==(const set<Key, Compare, Alloc>& x, 
                       const set<Key, Compare, Alloc>& y) {
  return x.t == y.t;
}

template <class Key, class Compare, class Alloc>
inline bool operator<(const set<Key, Compare, Alloc>& x, 
                      const set<Key, Compare, Alloc>& y) {
  return x.t < y.t;
}



template <class Key, class Compare, class Alloc>
inline void swap(set<Key, Compare, Alloc>& x, 
                 set<Key, Compare, Alloc>& y) {
  x.swap(y);
}







 



 
 
 
# 33 "/u/tveldhui/software/egcs-irix/include/g++/set" 2 3

# 1 "/u/tveldhui/software/egcs-irix/include/g++/stl_multiset.h" 1 3
 

























 






 






template <class Key, class Compare = less<Key>, class Alloc = alloc>



class multiset {
public:
   

  typedef Key key_type;
  typedef Key value_type;
  typedef Compare key_compare;
  typedef Compare value_compare;
private:
  typedef rb_tree<key_type, value_type, 
                  identity<value_type>, key_compare, Alloc> rep_type;
  rep_type t;   
public:
  typedef typename rep_type::const_pointer pointer;
  typedef typename rep_type::const_pointer const_pointer;
  typedef typename rep_type::const_reference reference;
  typedef typename rep_type::const_reference const_reference;
  typedef typename rep_type::const_iterator iterator;
  typedef typename rep_type::const_iterator const_iterator;
  typedef typename rep_type::const_reverse_iterator reverse_iterator;
  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;
  typedef typename rep_type::size_type size_type;
  typedef typename rep_type::difference_type difference_type;

   

  multiset() : t(Compare()) {}
  explicit multiset(const Compare& comp) : t(comp) {}


  template <class InputIterator>
  multiset(InputIterator first, InputIterator last)
    : t(Compare()) { t.insert_equal(first, last); }
  template <class InputIterator>
  multiset(InputIterator first, InputIterator last, const Compare& comp)
    : t(comp) { t.insert_equal(first, last); }
# 92 "/u/tveldhui/software/egcs-irix/include/g++/stl_multiset.h" 3


  multiset(const multiset<Key, Compare, Alloc>& x) : t(x.t) {}
  multiset<Key, Compare, Alloc>&
  operator=(const multiset<Key, Compare, Alloc>& x) {
    t = x.t; 
    return *this;
  }

   

  key_compare key_comp() const { return t.key_comp(); }
  value_compare value_comp() const { return t.key_comp(); }
  iterator begin() const { return t.begin(); }
  iterator end() const { return t.end(); }
  reverse_iterator rbegin() const { return t.rbegin(); } 
  reverse_iterator rend() const { return t.rend(); }
  bool empty() const { return t.empty(); }
  size_type size() const { return t.size(); }
  size_type max_size() const { return t.max_size(); }
  void swap(multiset<Key, Compare, Alloc>& x) { t.swap(x.t); }

   
  iterator insert(const value_type& x) { 
    return t.insert_equal(x);
  }
  iterator insert(iterator position, const value_type& x) {
    typedef typename rep_type::iterator rep_iterator;
    return t.insert_equal((rep_iterator&)position, x);
  }


  template <class InputIterator>
  void insert(InputIterator first, InputIterator last) {
    t.insert_equal(first, last);
  }








  void erase(iterator position) { 
    typedef typename rep_type::iterator rep_iterator;
    t.erase((rep_iterator&)position); 
  }
  size_type erase(const key_type& x) { 
    return t.erase(x); 
  }
  void erase(iterator first, iterator last) { 
    typedef typename rep_type::iterator rep_iterator;
    t.erase((rep_iterator&)first, (rep_iterator&)last); 
  }
  void clear() { t.clear(); }

   

  iterator find(const key_type& x) const { return t.find(x); }
  size_type count(const key_type& x) const { return t.count(x); }
  iterator lower_bound(const key_type& x) const {
    return t.lower_bound(x);
  }
  iterator upper_bound(const key_type& x) const {
    return t.upper_bound(x); 
  }
  pair<iterator,iterator> equal_range(const key_type& x) const {
    return t.equal_range(x);
  }
  friend bool operator== <>  (const multiset&,
                                               const multiset&);
  friend bool operator< <>  (const multiset&,
                                              const multiset&);
};

template <class Key, class Compare, class Alloc>
inline bool operator==(const multiset<Key, Compare, Alloc>& x, 
                       const multiset<Key, Compare, Alloc>& y) {
  return x.t == y.t;
}

template <class Key, class Compare, class Alloc>
inline bool operator<(const multiset<Key, Compare, Alloc>& x, 
                      const multiset<Key, Compare, Alloc>& y) {
  return x.t < y.t;
}



template <class Key, class Compare, class Alloc>
inline void swap(multiset<Key, Compare, Alloc>& x, 
                 multiset<Key, Compare, Alloc>& y) {
  x.swap(y);
}







 



 
 
 
# 34 "/u/tveldhui/software/egcs-irix/include/g++/set" 2 3




 
 
 
# 49 "../blitz/traversal.h" 2


namespace  blitz  { 

template<int N_dimensions>
class TraversalOrder {

public:
    typedef TinyVector<int, N_dimensions> T_coord;
    typedef Vector<T_coord>               T_traversal;

    TraversalOrder()
    {
        size_ = 0;
    }

    TraversalOrder(const T_coord& size, T_traversal& order)
        : size_(size), order_(order)
    { }

    TraversalOrder(const T_coord& size)
        : size_(size)
    { }

    T_coord operator[](int i) const
    { return order_[i]; }

    T_coord& operator[](int i)
    { return order_[i]; }

    int length() const
    { return order_.length(); }

    bool operator<(const TraversalOrder<N_dimensions>& x) const
    {
        for (int i=0; i < N_dimensions; ++i)
        {
            if (size_[i] < x.size_[i])
                return true;
            else if (size_[i] > x.size_[i])
                return false;
        }
        return false;
    }

    bool operator==(const TraversalOrder<N_dimensions>& x) const
    {
        for (int i=0; i < N_dimensions; ++i)
        {
            if (size_[i] != x.size_[i])
                return false;
        }

        return true;
    }

protected:
    T_traversal order_;
    T_coord     size_;
};

 



template<>
class TraversalOrder<0> {
public:
     TraversalOrder () {}  
};

template<int N_dimensions>
class TraversalOrderCollection {
public:
    typedef TraversalOrder<N_dimensions>        T_traversal;
    typedef typename  T_traversal::T_coord   T_coord;
    typedef set<T_traversal>                    T_set;
    typedef typename  set<T_traversal>::const_iterator T_iterator;

    const T_traversal* find(const T_coord& size)
    {
        T_iterator iter = traversals_.find(T_traversal(size));
        if (iter != traversals_.end())
            return &(*iter);
        return 0;
    }

    void insert(T_traversal x)
    {
        traversals_.insert(x);
    }

protected:
    static T_set traversals_;
};

 




template<>
class TraversalOrderCollection<0> {
public:
    typedef int T_traversal;
    typedef int T_coord;
    typedef int T_set;
    typedef int T_iterator;

    const T_traversal* find(const T_coord& size)
    { return 0; }
};

} 

# 1 "../blitz/traversal.cc" 1







namespace  blitz  { 

 
 
static set<TraversalOrder<2> > *_bz_intel_kludge;

template<int N_dimensions>
typename  TraversalOrderCollection<N_dimensions>::T_set
    TraversalOrderCollection<N_dimensions>::traversals_;

template<int N>
void makeHilbert(Vector<TinyVector<int,N> >& coord, 
    int x0, int y0, int xis, int xjs,
    int yis, int yjs, int n, int& i)
{
     
     ;

    if (!n)
    {
        if (i > coord.length())
        {
            cerr << "makeHilbert: vector not long enough" << endl;
            exit(1);
        }
        coord[i][0] = x0 + (xis+yis)/2;
        coord[i][1] = y0 + (xjs+yjs)/2;
        ++i;
    }
    else {
        makeHilbert(coord,x0,y0,yis/2, yjs/2, xis/2, xjs/2, n-1, i);
        makeHilbert(coord,x0+xis/2,y0+xjs/2,xis/2,xjs/2,yis/2,yjs/2,n-1,i);
        makeHilbert(coord,x0+xis/2+yis/2,y0+xjs/2+yjs/2,xis/2,xjs/2,yis/2,
            yjs/2,n-1,i);
        makeHilbert(coord,x0+xis/2+yis, y0+xjs/2+yjs, -yis/2,-yjs/2,-xis/2,
            -xjs/2,n-1,i);
    }
}

template<int N_dimensions>
void MakeHilbertTraversal(Vector<TinyVector<int,N_dimensions> >& coord, 
    int length)
{
     
     ;

     
    int d = (int)(::ceil(::log((double)length) / 0.693147180559945309417));  

    int N = 1 << d;
    const int Npoints = N*N;
    Vector<TinyVector<int,2> > coord2(Npoints);

    int i=0;
    makeHilbert(coord2,0,0,32768,0,0,32768,d,i);

    int xp0 = coord2[0][0];
    int yp0 = coord2[0][1];

    int j=0;

    coord.resize(length * length);

    for (int i=0; i < Npoints; ++i)
    {
        coord2[i][0] = (coord2[i][0]-xp0)/(2*xp0);
        coord2[i][1] = (coord2[i][1]-yp0)/(2*yp0);

        if ((coord2[i][0] < length) && (coord2[i][1] < length) 
            && (coord2[i][0] >= 0) && (coord2[i][1] >= 0))
        {
            coord[j][0] = coord2[i][0];
            coord[j][1] = coord2[i][1];
            ++j;
        }
    }
}

template<int N_dimensions>
void generateFastTraversalOrder(const TinyVector<int,N_dimensions>& size)
{
     ;
     ;

    TraversalOrderCollection<2> travCol;
    if (travCol.find(size))
        return;

    Vector<TinyVector<int,2> > ordering(size[0]);

    MakeHilbertTraversal(ordering, size[0]);
    travCol.insert(TraversalOrder<2>(size, ordering));
}

} 


# 164 "../blitz/traversal.h" 2






# 65 "../blitz/array.h" 2




 
# 1 "../blitz/indexexpr.h" 1
 












































 
# 1 "../blitz/etbase.h" 1



namespace  blitz  { 

template<class T>
class ETBase { 
public:
    ETBase() 
    { }

    ETBase(const ETBase<T>&)
    { }
};

} 



# 46 "../blitz/indexexpr.h" 2



namespace  blitz  { 

template<int N>
class IndexPlaceholder 

  : public ETBase<IndexPlaceholder<N> > 

{
public:
    IndexPlaceholder()
    { }

    IndexPlaceholder(const IndexPlaceholder<N>&)
    { }

    ~IndexPlaceholder()
    { }

    void operator=(const IndexPlaceholder<N>&)
    { }

    typedef int T_numtype;
    typedef int T_ctorArg1;      
    typedef int T_ctorArg2;      

    enum { numArrayOperands = 0, numIndexPlaceholders = 1,
        rank = N+1 };

     
     
     
     
    int operator*()
    { 
         ; 
        return 0;
    }






    template<int N_rank>
    T_numtype operator()(const TinyVector<int, N_rank>& i)
    { return i[N]; }


    int lbound(int) const
    { return (- 2147483647  -1) ; }    

    int ubound(int) const
    { return 2147483647  ; }   

     
    void push(int)
    { 
         ; 
    }

     
    void pop(int)
    { 
         ; 
    }

     
    void advance()
    { 
         ; 
    }

     
    void advance(int)
    { 
         ; 
    }

     
    void loadStride(int)
    { 
         ; 
    }

    bool  isUnitStride(int rank) const
    { 
         ;
        return false;
    }

    void advanceUnitStride()
    { 
         ;
    }

    bool  canCollapse(int,int) const
    {   
         ; 
        return false ; 
    }

    T_numtype operator[](int)
    {
         ;
        return T_numtype();
    }

    T_numtype fastRead(int)
    {
         ;
        return T_numtype();
    }

    int suggestStride(int) const
    {
         ;
        return 0;
    }

    bool  isStride(int,int) const
    {
         ;
        return true ;
    }

    void prettyPrint(string& str, prettyPrintFormat& format) const
    {
         
        str += "index-expr[NEEDS_WORK]";
    }

    template<class T_shape>
    bool  shapeCheck(const T_shape& shape) const
    {
        return true ;
    }
};

typedef IndexPlaceholder<0> firstIndex;
typedef IndexPlaceholder<1> secondIndex;
typedef IndexPlaceholder<2> thirdIndex;
typedef IndexPlaceholder<3> fourthIndex;
typedef IndexPlaceholder<4> fifthIndex;
typedef IndexPlaceholder<5> sixthIndex;
typedef IndexPlaceholder<6> seventhIndex;
typedef IndexPlaceholder<7> eighthIndex;
typedef IndexPlaceholder<8> ninthIndex;
typedef IndexPlaceholder<9> tenthIndex;
typedef IndexPlaceholder<10> eleventhIndex;



namespace  tensor  { 
    extern  blitz::IndexPlaceholder<0> i;
    extern  blitz::IndexPlaceholder<1> j;
    extern  blitz::IndexPlaceholder<2> k;
    extern  blitz::IndexPlaceholder<3> l;
    extern  blitz::IndexPlaceholder<4> m;
    extern  blitz::IndexPlaceholder<5> n;
    extern  blitz::IndexPlaceholder<6> o;
    extern  blitz::IndexPlaceholder<7> p;
    extern  blitz::IndexPlaceholder<8> q;
    extern  blitz::IndexPlaceholder<9> r;
    extern  blitz::IndexPlaceholder<10> s;
    extern  blitz::IndexPlaceholder<11> t;
}   



} 



# 69 "../blitz/array.h" 2







# 1 "../blitz/array/slice.h" 1
 







































namespace  blitz  { 

 
template<class T, int N>
class Array;



class nilArraySection { };

template<class T>
class ArraySectionInfo {
public:
    enum { isValidType = 0, rank = 0, isPick = 0 };
};

template<>
class ArraySectionInfo<Range> {
public:
    enum { isValidType = 1, rank = 1, isPick = 0 };
};

template<>
class ArraySectionInfo<int> {
public:
    enum { isValidType = 1, rank = 0, isPick = 0 };
};

template<>
class ArraySectionInfo<nilArraySection> {
public:
    enum { isValidType = 1, rank = 0, isPick = 0 };
};

template<class T_numtype, class T1, class T2 = nilArraySection, 
    class T3 = nilArraySection, class T4 = nilArraySection, 
    class T5 = nilArraySection, class T6 = nilArraySection, 
    class T7 = nilArraySection, class T8 = nilArraySection, 
    class T9 = nilArraySection, class T10 = nilArraySection, 
    class T11 = nilArraySection>
class SliceInfo {
public:
    enum { 
        numValidTypes = ArraySectionInfo<T1>::isValidType
                      + ArraySectionInfo<T2>::isValidType
                      + ArraySectionInfo<T3>::isValidType
                      + ArraySectionInfo<T4>::isValidType
                      + ArraySectionInfo<T5>::isValidType
                      + ArraySectionInfo<T6>::isValidType
                      + ArraySectionInfo<T7>::isValidType
                      + ArraySectionInfo<T8>::isValidType
                      + ArraySectionInfo<T9>::isValidType
                      + ArraySectionInfo<T10>::isValidType
                      + ArraySectionInfo<T11>::isValidType,

        rank          = ArraySectionInfo<T1>::rank
                      + ArraySectionInfo<T2>::rank
                      + ArraySectionInfo<T3>::rank
                      + ArraySectionInfo<T4>::rank
                      + ArraySectionInfo<T5>::rank
                      + ArraySectionInfo<T6>::rank
                      + ArraySectionInfo<T7>::rank
                      + ArraySectionInfo<T8>::rank
                      + ArraySectionInfo<T9>::rank
                      + ArraySectionInfo<T10>::rank
                      + ArraySectionInfo<T11>::rank,

        isPick        = ArraySectionInfo<T1>::isPick
                      + ArraySectionInfo<T2>::isPick
                      + ArraySectionInfo<T3>::isPick
                      + ArraySectionInfo<T4>::isPick
                      + ArraySectionInfo<T5>::isPick
                      + ArraySectionInfo<T6>::isPick
                      + ArraySectionInfo<T7>::isPick
                      + ArraySectionInfo<T8>::isPick
                      + ArraySectionInfo<T9>::isPick
                      + ArraySectionInfo<T10>::isPick
                      + ArraySectionInfo<T11>::isPick
        };

    typedef Array<T_numtype,numValidTypes> T_array;
    typedef Array<T_numtype,rank> T_slice;
};

} 


# 76 "../blitz/array.h" 2

# 1 "../blitz/array/map.h" 1
 
































 





















namespace  blitz  { 

 




template<int N_rank>
struct _bz_doArrayIndexMapping {
    template<class T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, N_rank>&, 
        const TinyVector<int,N_destRank>&, int, int, int, int, int, int,
        int, int, int, int, int)
    {
         
         
         
         ;
    }
};

template<>
struct _bz_doArrayIndexMapping<1> {
    template<class T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, 1>& array,
        const TinyVector<int,N_destRank>& index, int i0, int, int, int, int, 
        int, int, int, int, int, int)
    {
        return array(index[i0]);
    }
};


template<>
struct _bz_doArrayIndexMapping<2> {
    template<class T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, 2>& array,
        const TinyVector<int,N_destRank>& index, int i0, int i1, int, 
        int, int, int, int, int, int, int, int)
    {
        return array(index[i0], index[i1]);
    }
};

template<>
struct _bz_doArrayIndexMapping<3> {
    template<class T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, 3>& array,
        const TinyVector<int,N_destRank>& index, int i0, int i1, int i2,
        int, int, int, int, int, int, int, int)
    {
        return array(index[i0], index[i1], index[i2]);
    }
};

template<>
struct _bz_doArrayIndexMapping<4> {
    template<class T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, 4>& array,
        const TinyVector<int,N_destRank>& index, int i0, int i1, int i2,
        int i3, int, int, int, int, int, int, int)
    {
        return array(index[i0], index[i1], index[i2], index[i3]);
    }
};

template<>
struct _bz_doArrayIndexMapping<5> {
    template<class T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, 5>& array,
        const TinyVector<int,N_destRank>& index, int i0, int i1, int i2,
        int i3, int i4, int, int, int, int, int, int)
    {
        return array(index[i0], index[i1], index[i2], index[i3], index[i4]);
    }
};

template<>
struct _bz_doArrayIndexMapping<6> {
    template<class T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, 6>& array,
        const TinyVector<int,N_destRank>& index, int i0, int i1, int i2,
        int i3, int i4, int i5, int, int, int, int, int)
    {
        return array(index[i0], index[i1], index[i2], index[i3], index[i4],
            index[i5]);
    }
};

template<>
struct _bz_doArrayIndexMapping<7> {
    template<class T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, 7>& array,
        const TinyVector<int,N_destRank>& index, int i0, int i1, int i2,
        int i3, int i4, int i5, int i6, int, int, int, int)
    {
        return array(index[i0], index[i1], index[i2], index[i3], index[i4],
            index[i5], index[i6]);
    }
};

template<>
struct _bz_doArrayIndexMapping<8> {
    template<class T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, 8>& array,
        const TinyVector<int,N_destRank>& index, int i0, int i1, int i2,
        int i3, int i4, int i5, int i6, int i7, int, int, int)
    {
        return array(index[i0], index[i1], index[i2], index[i3], index[i4],
            index[i5], index[i6], index[i7]);
    }
};

template<>
struct _bz_doArrayIndexMapping<9> {
    template<class T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, 9>& array,
        const TinyVector<int,N_destRank>& index, int i0, int i1, int i2,
        int i3, int i4, int i5, int i6, int i7, int i8, int, int)
    {
        return array(index[i0], index[i1], index[i2], index[i3], index[i4],
            index[i5], index[i6], index[i7], index[i8]);
    }
};

template<>
struct _bz_doArrayIndexMapping<10> {
    template<class T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, 10>& array,
        const TinyVector<int,N_destRank>& index, int i0, int i1, int i2,
        int i3, int i4, int i5, int i6, int i7, int i8, int i9, int)
    {
        return array(index[i0], index[i1], index[i2], index[i3], index[i4],
            index[i5], index[i6], index[i7], index[i8], index[i9]);
    }
};

template<>
struct _bz_doArrayIndexMapping<11> {
    template<class T_numtype, int N_destRank>
    static T_numtype map(const Array<T_numtype, 11>& array,
        const TinyVector<int,N_destRank>& index, int i0, int i1, int i2,
        int i3, int i4, int i5, int i6, int i7, int i8, int i9, int i10)
    {
        return array(index[i0], index[i1], index[i2], index[i3], index[i4],
            index[i5], index[i6], index[i7], index[i8], index[i9],
            index[i10]);
    }
};

template<class P_numtype, int N_rank, int N_map0, int N_map1=0, int N_map2=0,
    int N_map3=0, int N_map4=0, int N_map5=0, int N_map6=0, int N_map7=0, 
    int N_map8=0, int N_map9=0, int N_map10=0>
class ArrayIndexMapping {
public:
    typedef P_numtype T_numtype;
    typedef const Array<T_numtype,N_rank>& T_ctorArg1;
    typedef int                            T_ctorArg2;     

     





    enum {
        maxRank1 = (N_map0 > N_map1) ? N_map0 : N_map1,
        maxRank2 = (N_map2 > maxRank1) ? N_map2 : maxRank1,
        maxRank3 = (N_map3 > maxRank2) ? N_map3 : maxRank2,
        maxRank4 = (N_map4 > maxRank3) ? N_map4 : maxRank3,
        maxRank5 = (N_map5 > maxRank4) ? N_map5 : maxRank4,
        maxRank6 = (N_map6 > maxRank5) ? N_map6 : maxRank5,
        maxRank7 = (N_map7 > maxRank6) ? N_map7 : maxRank6,
        maxRank8 = (N_map8 > maxRank7) ? N_map8 : maxRank7,
        maxRank9 = (N_map9 > maxRank8) ? N_map9 : maxRank8,
        maxRank10 = (N_map10 > maxRank9) ? N_map10 : maxRank9
    };

    enum { numArrayOperands = 1, numIndexPlaceholders = 1,
        rank = maxRank10 + 1 };

    ArrayIndexMapping(const Array<T_numtype, N_rank>& array)
        : array_(array)
    { 
    }

    ArrayIndexMapping(const ArrayIndexMapping<T_numtype,N_rank,N_map0,
        N_map1,N_map2,N_map3,N_map4,N_map5,N_map6,N_map7,N_map8,N_map9,
        N_map10>& z)
        : array_(z.array_)
    { 
    }

# 257 "../blitz/array/map.h"

    template<int N_destRank>
    T_numtype operator()(const TinyVector<int, N_destRank>& i)
    {
        return _bz_doArrayIndexMapping<N_rank>::map(array_, i,
            N_map0, N_map1, N_map2, N_map3, N_map4, N_map5, N_map6,
            N_map7, N_map8, N_map9, N_map10);
    }


    int lbound(int rank)
    { 
        if (N_map0 == rank)    
            return array_.lbound(0);
        else if ((N_map1 == rank) && (N_rank > 1))
            return array_.lbound(1);
        else if ((N_map2 == rank) && (N_rank > 2))
            return array_.lbound(2);
        else if ((N_map3 == rank) && (N_rank > 3))
            return array_.lbound(3);
        else if ((N_map4 == rank) && (N_rank > 4))
            return array_.lbound(4);
        else if ((N_map5 == rank) && (N_rank > 5))
            return array_.lbound(5);
        else if ((N_map6 == rank) && (N_rank > 6))
            return array_.lbound(6);
        else if ((N_map7 == rank) && (N_rank > 7))
            return array_.lbound(7);
        else if ((N_map8 == rank) && (N_rank > 8))
            return array_.lbound(8);
        else if ((N_map9 == rank) && (N_rank > 9))
            return array_.lbound(9);
        else if ((N_map10 == rank) && (N_rank > 10))
            return array_.lbound(10);
        else
            return (- 2147483647  -1) ;    
    }

    int ubound(int rank)
    {   
        if (N_map0 == rank)
            return array_.ubound(0);
        else if ((N_map1 == rank) && (N_rank > 1))
            return array_.ubound(1);
        else if ((N_map2 == rank) && (N_rank > 2))
            return array_.ubound(2);
        else if ((N_map3 == rank) && (N_rank > 3))
            return array_.ubound(3);
        else if ((N_map4 == rank) && (N_rank > 4))
            return array_.ubound(4);
        else if ((N_map5 == rank) && (N_rank > 5))
            return array_.ubound(5);
        else if ((N_map6 == rank) && (N_rank > 6))
            return array_.ubound(6);
        else if ((N_map7 == rank) && (N_rank > 7))
            return array_.ubound(7);
        else if ((N_map8 == rank) && (N_rank > 8))
            return array_.ubound(8);
        else if ((N_map9 == rank) && (N_rank > 9))
            return array_.ubound(9);
        else if ((N_map10 == rank) && (N_rank > 10))
            return array_.ubound(10);
        else
            return 2147483647  ;    
    }

     
     
     
     
    int operator*()
    {
         ;
        return 0;
    }

     
    void push(int)
    {
         ;
    }

     
    void pop(int)
    {
         ;
    }

     
    void advance()
    {
         ;
    }

     
    void advance(int)
    {
         ;
    }

     
    void loadStride(int)
    {
         ;
    }

    bool  isUnitStride(int rank) const
    {
         ;
        return false;
    }

    void advanceUnitStride()
    {
         ;
    }

    bool  canCollapse(int,int) const
    {    ;  return false ; }

    T_numtype operator[](int)
    {   
         ;
        return T_numtype();
    }

    T_numtype fastRead(int)
    {
         ;
        return T_numtype();
    }

    int suggestStride(int) const
    {
         ;
        return 0;
    }

    bool  isStride(int,int) const
    {
         ;
        return true ;
    }

    template<int N_rank2>
    void moveTo(const TinyVector<int,N_rank2>& i)
    {
         ;
        return ;
    }

    void prettyPrint(string& str, prettyPrintFormat& format) const
    {
         
        str += "map[NEEDS_WORK]";
    }

    template<class T_shape>
    bool  shapeCheck(const T_shape& shape) const
    { 
         
        return true ; 
    }

private:
    ArrayIndexMapping() { }

    const Array<T_numtype, N_rank>& array_;
};

} 



# 77 "../blitz/array.h" 2

# 1 "../blitz/array/multi.h" 1
 








namespace  blitz  { 

 










 
template<class T_component>
struct multicomponent_traits {
    typedef T_component T_element;
    enum { numComponents = 0 };
};

 
template<class T_numtype, int N_rank>
struct multicomponent_traits<TinyVector<T_numtype,N_rank> > {
    typedef T_numtype T_element;
    enum { numComponents = N_rank };
};

 
template<class T>
struct multicomponent_traits<complex<T> > {
    typedef T T_element;
    enum { numComponents = 2 };
};

 
 








} 


# 78 "../blitz/array.h" 2

# 1 "../blitz/array/domain.h" 1











 




namespace  blitz  { 

template<int N_rank>
class RectDomain {

public:
    RectDomain(const TinyVector<int,N_rank>& lbound,
        const TinyVector<int,N_rank>& ubound)
      : lbound_(lbound), ubound_(ubound)
    { }

     
     
     

    const TinyVector<int,N_rank>& lbound() const
    { return lbound_; }

    int lbound(int i) const
    { return lbound_(i); }

    const TinyVector<int,N_rank>& ubound() const
    { return ubound_; }

    int ubound(int i) const
    { return ubound_(i); }

    Range operator[](int rank) const
    { return Range(lbound_(rank), ubound_(rank)); }

    void shrink(int amount)
    {
        lbound_ += amount;
        ubound_ -= amount;
    }

    void shrink(int dim, int amount)
    {
        lbound_(dim) += amount;
        ubound_(dim) -= amount;
    }

    void expand(int amount)
    {
        lbound_ -= amount;
        ubound_ += amount;
    }

    void expand(int dim, int amount)
    {
        lbound_(dim) -= amount;
        ubound_(dim) += amount;
    }

private:
    TinyVector<int,N_rank> lbound_, ubound_;
};

template<int N_rank>
inline RectDomain<N_rank> strip(const TinyVector<int,N_rank>& startPosition,
    int stripDimension, int ubound)
{
     ;
     ;

    TinyVector<int,N_rank> endPosition = startPosition;
    endPosition(stripDimension) = ubound;
    return RectDomain<N_rank>(startPosition, endPosition);
}

} 


# 79 "../blitz/array.h" 2

# 1 "../blitz/array/storage.h" 1



namespace  blitz  { 

 




















template<int N_rank>
class GeneralArrayStorage {
public:
    class noInitializeFlag { };

    GeneralArrayStorage(noInitializeFlag)
    { }

    GeneralArrayStorage()
    {
        ordering_ = Range(N_rank - 1, 0, -1);
        ascendingFlag_ = 1;
        base_ = 0;
    }

    GeneralArrayStorage(const GeneralArrayStorage<N_rank>& x)
        : ordering_(x.ordering_), ascendingFlag_(x.ascendingFlag_),
          base_(x.base_)
    { 
    }

    ~GeneralArrayStorage()
    { }

    TinyVector<int, N_rank>& ordering()
    { return ordering_; }

    const TinyVector<int, N_rank>& ordering() const
    { return ordering_; }

    int ordering(int i) const
    { return ordering_[i]; }

    void setOrdering(int i, int order) 
    { ordering_[i] = order; }

    bool  allRanksStoredAscending() const
    {
        bool  result = true ;
        for (int i=0; i < N_rank; ++i)
            result &= ascendingFlag_[i];
        return result;
    }

    bool  isRankStoredAscending(int i) const
    { return ascendingFlag_[i]; }

    TinyVector<bool, N_rank>& ascendingFlag() 
    { return ascendingFlag_; }

    const TinyVector<bool, N_rank>& ascendingFlag() const
    { return ascendingFlag_; }

    void setAscendingFlag(int i, int ascendingFlag) 
    { ascendingFlag_[i] = ascendingFlag; }

    TinyVector<int, N_rank>& base()
    { return base_; }

    const TinyVector<int, N_rank>& base() const
    { return base_; }

    int base(int i) const
    { return base_[i]; }

    void setBase(int i, int base)
    { base_[i] = base; }

    void setBase(const TinyVector<int, N_rank>& base)
    { base_ = base; }

protected:
     




















    TinyVector<int,  N_rank> ordering_;
    TinyVector<bool, N_rank> ascendingFlag_;
    TinyVector<int,  N_rank> base_;
};

 






template<int N_rank>
class FortranArray : public GeneralArrayStorage<N_rank> {
public:
    FortranArray()
        : GeneralArrayStorage<N_rank>(noInitializeFlag())
    {
        ordering_ = Range(0, N_rank - 1);
        ascendingFlag_ = 1;
        base_ = 1;
    }
};


 
 
 
 
 
 

class _bz_fortranTag {
public:
    operator GeneralArrayStorage<1>()
    { return FortranArray<1>(); }

    operator GeneralArrayStorage<2>()
    { return FortranArray<2>(); }

    operator GeneralArrayStorage<3>()
    { return FortranArray<3>(); }

    operator GeneralArrayStorage<4>()
    { return FortranArray<4>(); }

    operator GeneralArrayStorage<5>()
    { return FortranArray<5>(); }

    operator GeneralArrayStorage<6>()
    { return FortranArray<6>(); }

    operator GeneralArrayStorage<7>()
    { return FortranArray<7>(); }

    operator GeneralArrayStorage<8>()
    { return FortranArray<8>(); }

    operator GeneralArrayStorage<9>()
    { return FortranArray<9>(); }

    operator GeneralArrayStorage<10>()
    { return FortranArray<10>(); }

    operator GeneralArrayStorage<11>()
    { return FortranArray<11>(); }
};

 
 

extern  _bz_fortranTag fortranArray;


 




template<int N_rank>
class ColumnMajorArray : public GeneralArrayStorage<N_rank> {
public:
    ColumnMajorArray()
        : GeneralArrayStorage<N_rank>(noInitializeFlag())
    {
        ordering_ = Range(0, N_rank - 1);
        ascendingFlag_ = 1;
        base_ = 0;
    }
};

} 



# 80 "../blitz/array.h" 2



namespace  blitz  { 

 



template<class T_numtype, int N_rank>
class ArrayIterator;

template<class T_numtype, int N_rank>
class ConstArrayIterator;

template<class T_numtype, int N_rank>
class FastArrayIterator;

template<class P_expr>
class _bz_ArrayExpr;

template<class T_array, class T_index>
class IndirectArray;

class _bz_endTag;



 



 
 
 

template<class P_numtype, int N_rank>
class Array : public MemoryBlockReference<P_numtype> 

    , public ETBase<Array<P_numtype,N_rank> >

{

public:
     
     
     

     










    typedef P_numtype                T_numtype;
    typedef TinyVector<int, N_rank>  T_index;
    typedef Array<T_numtype, N_rank> T_array;
    typedef FastArrayIterator<T_numtype, N_rank> T_iterator;

    typedef ArrayIterator<T_numtype,N_rank> iterator;
    typedef ConstArrayIterator<T_numtype,N_rank> const_iterator;

    enum { _bz_rank = N_rank };

     
     
     

    
     



    template<class T_expr>
    Array(_bz_ArrayExpr<T_expr> expr);

     






    Array(GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        length_ = 0;
        stride_ = 0;
        zeroOffset_ = 0;
    }

    explicit  Array(int length0, 
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        length_[0] = length0;
        setupStorage(0);
    }

    Array(int length0, int length1,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
         ;
         ;

         ;

        length_[0] = length0;
        length_[1] = length1;
        setupStorage(1);
    }

    Array(int length0, int length1, int length2,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
         ;
        length_[0] = length0;
        length_[1] = length1;
        length_[2] = length2;
        setupStorage(2);
    }

    Array(int length0, int length1, int length2, int length3,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
         ;
        length_[0] = length0;
        length_[1] = length1;
        length_[2] = length2;
        length_[3] = length3;
        setupStorage(3);
    }

    Array(int length0, int length1, int length2, int length3, int length4,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
         ;
        length_[0] = length0;
        length_[1] = length1;
        length_[2] = length2;
        length_[3] = length3;
        length_[4] = length4;
        setupStorage(4);
    }

    Array(int length0, int length1, int length2, int length3, int length4,
        int length5,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
         ;
        length_[0] = length0;
        length_[1] = length1;
        length_[2] = length2;
        length_[3] = length3;
        length_[4] = length4;
        length_[5] = length5;
        setupStorage(5);
    }

    Array(int length0, int length1, int length2, int length3, int length4,
        int length5, int length6,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
         ;
        length_[0] = length0;
        length_[1] = length1;
        length_[2] = length2;
        length_[3] = length3;
        length_[4] = length4;
        length_[5] = length5;
        length_[6] = length6;
        setupStorage(6);
    }

    Array(int length0, int length1, int length2, int length3, int length4,
        int length5, int length6, int length7,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
         ;
        length_[0] = length0;
        length_[1] = length1;
        length_[2] = length2;
        length_[3] = length3;
        length_[4] = length4;
        length_[5] = length5;
        length_[6] = length6;
        length_[7] = length7;
        setupStorage(7);
    }

    Array(int length0, int length1, int length2, int length3, int length4,
        int length5, int length6, int length7, int length8,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
         ;
        length_[0] = length0;
        length_[1] = length1;
        length_[2] = length2;
        length_[3] = length3;
        length_[4] = length4;
        length_[5] = length5;
        length_[6] = length6;
        length_[7] = length7;
        length_[8] = length8;
        setupStorage(8);
    }

    Array(int length0, int length1, int length2, int length3, int length4,
        int length5, int length6, int length7, int length8, int length9,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
         ;
        length_[0] = length0;
        length_[1] = length1;
        length_[2] = length2;
        length_[3] = length3;
        length_[4] = length4;
        length_[5] = length5;
        length_[6] = length6;
        length_[7] = length7;
        length_[8] = length8;
        length_[9] = length9;
        setupStorage(9);
    }

    Array(int length0, int length1, int length2, int length3, int length4,
        int length5, int length6, int length7, int length8, int length9,
        int length10,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
         ;
        length_[0] = length0;
        length_[1] = length1;
        length_[2] = length2;
        length_[3] = length3;
        length_[4] = length4;
        length_[5] = length5;
        length_[6] = length6;
        length_[7] = length7;
        length_[8] = length8;
        length_[9] = length9;
        length_[10] = length10;
        setupStorage(10);
    }

     



    Array(T_numtype*   dataFirst, TinyVector<int, N_rank> shape,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
      : MemoryBlockReference<T_numtype>(product(shape), dataFirst, 
          neverDeleteData),
        storage_(storage)
    {
         ;

        length_ = shape;
        computeStrides();
        data_ += zeroOffset_;
    }

     




    Array(T_numtype*   dataFirst, TinyVector<int, N_rank> shape,
        TinyVector<int, N_rank> stride, 
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
      : MemoryBlockReference<T_numtype>(product(shape), dataFirst, 
          neverDeleteData),
        storage_(storage)
    {
         ;

        length_ = shape;
        stride_ = stride;
        calculateZeroOffset();
        data_ += zeroOffset_;
    }

     


    Array(T_numtype*   dataFirst, TinyVector<int, N_rank> shape,
        preexistingMemoryPolicy deletionPolicy,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
      : MemoryBlockReference<T_numtype>(product(shape), dataFirst, 
            deletionPolicy),
        storage_(storage)
    {
         ;

        length_ = shape;
        computeStrides();
        data_ += zeroOffset_;

        if (deletionPolicy == duplicateData)
            reference(copy());
    }

     



    Array(T_numtype*   dataFirst, TinyVector<int, N_rank> shape,
        TinyVector<int, N_rank> stride,
        preexistingMemoryPolicy deletionPolicy,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
      : MemoryBlockReference<T_numtype>(product(shape), dataFirst, 
          deletionPolicy),
        storage_(storage)
    {
         ;

        length_ = shape;
        stride_ = stride;
        calculateZeroOffset();
        data_ += zeroOffset_;

        if (deletionPolicy == duplicateData)
            reference(copy());
    }

     



    Array(const TinyVector<int, N_rank>& extent, 
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
        length_ = extent;
        setupStorage(N_rank - 1);
    }

     




    Array(const TinyVector<int, N_rank>& lbounds,
        const TinyVector<int, N_rank>& extent,
        const GeneralArrayStorage<N_rank>& storage 
           = GeneralArrayStorage<N_rank>());

     




    Array(Range r0, 
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
         ;

        length_[0] = r0.length();
        storage_.setBase(0, r0.first());
        setupStorage(0);
    }

    Array(Range r0, Range r1,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
         ;


        length_[0] = r0.length();
        storage_.setBase(0, r0.first());
        length_[1] = r1.length();
        storage_.setBase(1, r1.first());

        setupStorage(1);
    }

    Array(Range r0, Range r1, Range r2,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
         ;


        length_[0] = r0.length();
        storage_.setBase(0, r0.first());
        length_[1] = r1.length();
        storage_.setBase(1, r1.first());
        length_[2] = r2.length();
        storage_.setBase(2, r2.first());

        setupStorage(2);
    }

    Array(Range r0, Range r1, Range r2, Range r3,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
         ;



        length_[0] = r0.length();
        storage_.setBase(0, r0.first());
        length_[1] = r1.length();
        storage_.setBase(1, r1.first());
        length_[2] = r2.length();
        storage_.setBase(2, r2.first());
        length_[3] = r3.length();
        storage_.setBase(3, r3.first());

        setupStorage(3);
    }

    Array(Range r0, Range r1, Range r2, Range r3, Range r4,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
         ;



        length_[0] = r0.length();
        storage_.setBase(0, r0.first());
        length_[1] = r1.length();
        storage_.setBase(1, r1.first());
        length_[2] = r2.length();
        storage_.setBase(2, r2.first());
        length_[3] = r3.length();
        storage_.setBase(3, r3.first());
        length_[4] = r4.length();
        storage_.setBase(4, r4.first());

        setupStorage(4);
    }

    Array(Range r0, Range r1, Range r2, Range r3, Range r4, Range r5,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
         ;




        length_[0] = r0.length();
        storage_.setBase(0, r0.first());
        length_[1] = r1.length();
        storage_.setBase(1, r1.first());
        length_[2] = r2.length();
        storage_.setBase(2, r2.first());
        length_[3] = r3.length();
        storage_.setBase(3, r3.first());
        length_[4] = r4.length();
        storage_.setBase(4, r4.first());
        length_[5] = r5.length();
        storage_.setBase(5, r5.first());

        setupStorage(5);
    }

    Array(Range r0, Range r1, Range r2, Range r3, Range r4, Range r5,
        Range r6,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
         ;




        length_[0] = r0.length();
        storage_.setBase(0, r0.first());
        length_[1] = r1.length();
        storage_.setBase(1, r1.first());
        length_[2] = r2.length();
        storage_.setBase(2, r2.first());
        length_[3] = r3.length();
        storage_.setBase(3, r3.first());
        length_[4] = r4.length();
        storage_.setBase(4, r4.first());
        length_[5] = r5.length();
        storage_.setBase(5, r5.first());
        length_[6] = r6.length();
        storage_.setBase(6, r6.first());

        setupStorage(6);
    }

    Array(Range r0, Range r1, Range r2, Range r3, Range r4, Range r5,
        Range r6, Range r7,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
         ;





        length_[0] = r0.length();
        storage_.setBase(0, r0.first());
        length_[1] = r1.length();
        storage_.setBase(1, r1.first());
        length_[2] = r2.length();
        storage_.setBase(2, r2.first());
        length_[3] = r3.length();
        storage_.setBase(3, r3.first());
        length_[4] = r4.length();
        storage_.setBase(4, r4.first());
        length_[5] = r5.length();
        storage_.setBase(5, r5.first());
        length_[6] = r6.length();
        storage_.setBase(6, r6.first());
        length_[7] = r7.length();
        storage_.setBase(7, r7.first());

        setupStorage(7);
    }

    Array(Range r0, Range r1, Range r2, Range r3, Range r4, Range r5,
        Range r6, Range r7, Range r8,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
         ;





        length_[0] = r0.length();
        storage_.setBase(0, r0.first());
        length_[1] = r1.length();
        storage_.setBase(1, r1.first());
        length_[2] = r2.length();
        storage_.setBase(2, r2.first());
        length_[3] = r3.length();
        storage_.setBase(3, r3.first());
        length_[4] = r4.length();
        storage_.setBase(4, r4.first());
        length_[5] = r5.length();
        storage_.setBase(5, r5.first());
        length_[6] = r6.length();
        storage_.setBase(6, r6.first());
        length_[7] = r7.length();
        storage_.setBase(7, r7.first());
        length_[8] = r8.length();
        storage_.setBase(8, r8.first());

        setupStorage(8);
    }

    Array(Range r0, Range r1, Range r2, Range r3, Range r4, Range r5,
        Range r6, Range r7, Range r8, Range r9,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
         ;






        length_[0] = r0.length();
        storage_.setBase(0, r0.first());
        length_[1] = r1.length();
        storage_.setBase(1, r1.first());
        length_[2] = r2.length();
        storage_.setBase(2, r2.first());
        length_[3] = r3.length();
        storage_.setBase(3, r3.first());
        length_[4] = r4.length();
        storage_.setBase(4, r4.first());
        length_[5] = r5.length();
        storage_.setBase(5, r5.first());
        length_[6] = r6.length();
        storage_.setBase(6, r6.first());
        length_[7] = r7.length();
        storage_.setBase(7, r7.first());
        length_[8] = r8.length();
        storage_.setBase(8, r8.first());
        length_[9] = r9.length();
        storage_.setBase(9, r9.first());

        setupStorage(9);
    }

    Array(Range r0, Range r1, Range r2, Range r3, Range r4, Range r5,
        Range r6, Range r7, Range r8, Range r9, Range r10,
        GeneralArrayStorage<N_rank> storage = GeneralArrayStorage<N_rank>())
        : storage_(storage)
    {
         ;






        length_[0] = r0.length();
        storage_.setBase(0, r0.first());
        length_[1] = r1.length();
        storage_.setBase(1, r1.first());
        length_[2] = r2.length();
        storage_.setBase(2, r2.first());
        length_[3] = r3.length();
        storage_.setBase(3, r3.first());
        length_[4] = r4.length();
        storage_.setBase(4, r4.first());
        length_[5] = r5.length();
        storage_.setBase(5, r5.first());
        length_[6] = r6.length();
        storage_.setBase(6, r6.first());
        length_[7] = r7.length();
        storage_.setBase(7, r7.first());
        length_[8] = r8.length();
        storage_.setBase(8, r8.first());
        length_[9] = r9.length();
        storage_.setBase(9, r9.first());
        length_[10] = r10.length();
        storage_.setBase(10, r10.first());

        setupStorage(10);
    }

     


    Array(const Array<T_numtype, N_rank>& array)
    {
         
        reference(const_cast<T_array&>(array));
    }

     



    Array(const TinyVector<int,N_rank-1>& shape,
        int lastExtent, const GeneralArrayStorage<N_rank>& storage);
     
     

     








    Array(Array<T_numtype, N_rank>& array, Range r0)
    {
        constructSubarray(array, r0);
    }

    Array(Array<T_numtype, N_rank>& array, Range r0, Range r1)
    {
        constructSubarray(array, r0, r1);
    }

    Array(Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2)
    {
        constructSubarray(array, r0, r1, r2);
    }

    Array(Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2,
        Range r3)
    {
        constructSubarray(array, r0, r1, r2, r3);
    }

    Array(Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2,
        Range r3, Range r4)
    {
        constructSubarray(array, r0, r1, r2, r3, r4);
    }

    Array(Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2,
        Range r3, Range r4, Range r5)
    {
        constructSubarray(array, r0, r1, r2, r3, r4, r5);
    }

    Array(Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2,
        Range r3, Range r4, Range r5, Range r6)
    {
        constructSubarray(array, r0, r1, r2, r3, r4, r5, r6);
    }

    Array(Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2,
        Range r3, Range r4, Range r5, Range r6, Range r7)
    {
        constructSubarray(array, r0, r1, r2, r3, r4, r5, r6, r7);
    }

    Array(Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2,
        Range r3, Range r4, Range r5, Range r6, Range r7, Range r8)
    {
        constructSubarray(array, r0, r1, r2, r3, r4, r5, r6, r7, r8);
    }

    Array(Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2,
        Range r3, Range r4, Range r5, Range r6, Range r7, Range r8, Range r9)
    {
        constructSubarray(array, r0, r1, r2, r3, r4, r5, r6, r7, r8, r9);
    }

    Array(Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2,
        Range r3, Range r4, Range r5, Range r6, Range r7, Range r8, Range r9,
        Range r10)
    {
        constructSubarray(array, r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10);
    }

    Array(Array<T_numtype, N_rank>& array, 
        const RectDomain<N_rank>& subdomain)
    {
        constructSubarray(array, subdomain);
    }

     




    template<int N_rank2, class R0, class R1, class R2, class R3, class R4,
        class R5, class R6, class R7, class R8, class R9, class R10>
    Array(Array<T_numtype,N_rank2>& array, R0 r0, R1 r1, R2 r2,
        R3 r3, R4 r4, R5 r5, R6 r6, R7 r7, R8 r8, R9 r9, R10 r10)
    {
        constructSlice(array, r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10);
    }

     
     
     

    const TinyVector<int, N_rank>&    base() const
    { return storage_.base(); }

    int                               base(int rank) const
    { return storage_.base(rank); }

    iterator                          begin() 
    { return iterator(*this); }

    const_iterator                    begin() const
    { return const_iterator(*this); }

    T_iterator                        beginFast() const
    { return T_iterator(*this); }

     
    template<class T_numtype2>
    Array<T_numtype2,N_rank>          chopComponent(T_numtype2 a, int compNum,
                                          int numComponents) const
    { return extractComponent(a, compNum, numComponents); }

    int                               cols() const
    { return length_[1]; }

    int                               columns() const
    { return length_[1]; }

    T_array                           copy() const;

     
     
     
     
     

    const T_numtype*       data() const
    { return data_ + dot(storage_.base(), stride_); }

    T_numtype*             data() 
    { return data_ + dot(storage_.base(), stride_); }

     
     
    
    const T_numtype*       dataZero() const
    { return data_; }

    T_numtype*             dataZero()
    { return data_; }

     
     
    
    const T_numtype*       dataFirst() const
    {
        return data_ + dot(storage_.base() 
            + (1 - storage_.ascendingFlag()) * (length_ - 1), stride_);
    }

    T_numtype*             dataFirst()
    {
        return data_ + dot(storage_.base()
            + (1 - storage_.ascendingFlag()) * (length_ - 1), stride_);
    }

    int                               depth() const
    { return length_[2]; }

    int                               dimensions() const
    { return N_rank; }

    RectDomain<N_rank>                domain() const
    {
        return RectDomain<N_rank>(lbound(), ubound());
    }

    void dumpStructureInformation(ostream& os = cout) const;

    iterator                          end()
    {
        return iterator(*this, _bz_endTag());
    }

    const_iterator                    end() const
    {
        return const_iterator(*this, _bz_endTag());
    }

    int                               extent(int rank) const
    { return length_[rank]; }

    const TinyVector<int,N_rank>&     extent() const
    { return length_; }

    template<class T_numtype2>
    Array<T_numtype2,N_rank>          extractComponent(T_numtype2, int compNum,
                                          int numComponents) const;

    void                              free() 
    {
        changeToNullBlock();
        length_ = 0;
    }
 
    bool                           isMajorRank(int rank) const
    { return storage_.ordering(rank) == 0; }

    bool                           isMinorRank(int rank) const
    { return storage_.ordering(rank) != 0; }

    bool                           isRankStoredAscending(int rank) const
    { return storage_.isRankStoredAscending(rank); }

    bool                           isStorageContiguous() const;

    int                               lbound(int rank) const
    { return base(rank); }

    TinyVector<int,N_rank>            lbound() const
    {
        return base();
    }

    int                               length(int rank) const
    { return length_[rank]; }

    const TinyVector<int, N_rank>&    length() const
    { return length_; }

    void                              makeUnique();

    int                               numElements() const
    { return product(length_); }

     
     

     
     
     
     
     
    int                               ordering(int storageRankIndex) const
    { return storage_.ordering(storageRankIndex); }

    const TinyVector<int, N_rank>&    ordering() const
    { return storage_.ordering(); }

    void                              transposeSelf(int r0, int r1, int r2=0, 
        int r3=0, int r4=0, int r5=0, int r6=0, int r7=0, int r8=0, int 
        r9=0, int r10=0);
    T_array                           transpose(int r0, int r1, int r2=0,
        int r3=0, int r4=0, int r5=0, int r6=0, int r7=0, int r8=0, int
        r9=0, int r10=0);

    int                               rank() const
    { return N_rank; }

    void                              reference(const T_array&);

     
    T_array                           reindex(const TinyVector<int,N_rank>&);
    void                              reindexSelf(const 
                                                TinyVector<int,N_rank>&);

    void                              resize(int extent);
    void                              resize(int extent1, int extent2);
    void                              resize(int extent1, int extent2,
                                        int extent3);
    void                              resize(int extent1, int extent2,
                                        int extent3, int extent4);
    void                              resize(int extent1, int extent2,
                                        int extent3, int extent4, int extent5);
    void                              resize(int extent1, int extent2,
                                        int extent3, int extent4, int extent5,
                                        int extent6);
    void                              resize(int extent1, int extent2,
                                        int extent3, int extent4, int extent5,
                                        int extent6, int extent7);
    void                              resize(int extent1, int extent2,
                                        int extent3, int extent4, int extent5,
                                        int extent6, int extent7, int extent8);
    void                              resize(int extent1, int extent2,
                                        int extent3, int extent4, int extent5,
                                        int extent6, int extent7, int extent8,
                                        int extent9);
    void                              resize(int extent1, int extent2,
                                        int extent3, int extent4, int extent5,
                                        int extent6, int extent7, int extent8,
                                        int extent9, int extent10);
    void                              resize(int extent1, int extent2,
                                        int extent3, int extent4, int extent5,
                                        int extent6, int extent7, int extent8,
                                        int extent9, int extent10, 
                                        int extent11);


    void                              resize(Range r1);
    void                              resize(Range r1, Range r2);
    void                              resize(Range r1, Range r2, Range r3);
    void                              resize(Range r1, Range r2, Range r3,
                                        Range r4);
    void                              resize(Range r1, Range r2, Range r3,
                                        Range r4, Range r5);
    void                              resize(Range r1, Range r2, Range r3,
                                        Range r4, Range r5, Range r6);
    void                              resize(Range r1, Range r2, Range r3,
                                        Range r4, Range r5, Range r6,
                                        Range r7);
    void                              resize(Range r1, Range r2, Range r3,
                                        Range r4, Range r5, Range r6,
                                        Range r7, Range r8);
    void                              resize(Range r1, Range r2, Range r3,
                                        Range r4, Range r5, Range r6,
                                        Range r7, Range r8, Range r9);
    void                              resize(Range r1, Range r2, Range r3,
                                        Range r4, Range r5, Range r6,
                                        Range r7, Range r8, Range r9, 
                                        Range r10);
    void                              resize(Range r1, Range r2, Range r3,
                                        Range r4, Range r5, Range r6,
                                        Range r7, Range r8, Range r9, 
                                        Range r10, Range r11);

    void                              resize(const TinyVector<int,N_rank>&);
 

    void                              resizeAndPreserve(int extent);
    void                              resizeAndPreserve(int extent1, 
                                        int extent2);
    void                              resizeAndPreserve(int extent1, 
                                        int extent2, int extent3);
    void                              resizeAndPreserve(int extent1,
                                        int extent2, int extent3, int extent4);
    void                              resizeAndPreserve(int extent1,
                                        int extent2, int extent3, int extent4,
                                        int extent5);
    void                              resizeAndPreserve(int extent1,
                                        int extent2, int extent3, int extent4,
                                        int extent5, int extent6);
    void                              resizeAndPreserve(int extent1,
                                        int extent2, int extent3, int extent4,
                                        int extent5, int extent6, int extent7);
    void                              resizeAndPreserve(int extent1,
                                        int extent2, int extent3, int extent4,
                                        int extent5, int extent6, int extent7,
                                        int extent8);
    void                              resizeAndPreserve(int extent1,
                                        int extent2, int extent3, int extent4,
                                        int extent5, int extent6, int extent7,
                                        int extent8, int extent9);
    void                              resizeAndPreserve(int extent1,
                                        int extent2, int extent3, int extent4,
                                        int extent5, int extent6, int extent7,
                                        int extent8, int extent9, 
                                        int extent10);
    void                              resizeAndPreserve(int extent1,
                                        int extent2, int extent3, int extent4,
                                        int extent5, int extent6, int extent7,
                                        int extent8, int extent9, int extent10,
                                        int extent11);

     
     
     

    T_array                           reverse(int rank);
    void                              reverseSelf(int rank);

    int                               rows() const
    { return length_[0]; }

    void                              slice(int rank, Range r);

    const TinyVector<int, N_rank>&    shape() const
    { return length_; }

    int                               size() const
    { return numElements(); }

    const TinyVector<int, N_rank>&    stride() const
    { return stride_; }

    int                               stride(int rank) const
    { return stride_[rank]; }

    int                               ubound(int rank) const
    { return base(rank) + length_(rank) - 1; }

    TinyVector<int, N_rank>           ubound() const
    { 
        TinyVector<int, N_rank> ub;
        ub = base() + extent() - 1;
        return ub;
    }

    int                               zeroOffset() const
    { return zeroOffset_; }

     
     
     

    bool  isInRangeForDim(int i, int d) const
    {
        return unsigned(i - base(d)) < length_[d];
    }

    bool  isInRange(int i0) const
    {
        return unsigned(i0 - base(0)) < length_[0];
    }

    bool  isInRange(int i0, int i1) const
    {
        return unsigned(i0 - base(0)) < length_[0]
            && unsigned(i1 - base(1)) < length_[1];
    }

    bool  isInRange(int i0, int i1, int i2) const
    {
        return unsigned(i0 - base(0)) < length_[0]
            && unsigned(i1 - base(1)) < length_[1]
            && unsigned(i2 - base(2)) < length_[2];
    }

    bool  isInRange(int i0, int i1, int i2, int i3) const
    {
        return unsigned(i0 - base(0)) < length_[0]
            && unsigned(i1 - base(1)) < length_[1]
            && unsigned(i2 - base(2)) < length_[2]
            && unsigned(i3 - base(3)) < length_[3];
    }

    bool  isInRange(int i0, int i1, int i2, int i3, int i4) const
    {
        return unsigned(i0 - base(0)) < length_[0]
            && unsigned(i1 - base(1)) < length_[1]
            && unsigned(i2 - base(2)) < length_[2]
            && unsigned(i3 - base(3)) < length_[3]
            && unsigned(i4 - base(4)) < length_[4];
    }

    bool  isInRange(int i0, int i1, int i2, int i3, int i4,
        int i5) const
    {
        return unsigned(i0 - base(0)) < length_[0]
            && unsigned(i1 - base(1)) < length_[1]
            && unsigned(i2 - base(2)) < length_[2]
            && unsigned(i3 - base(3)) < length_[3]
            && unsigned(i4 - base(4)) < length_[4]
            && unsigned(i5 - base(5)) < length_[5];
    }

    bool  isInRange(int i0, int i1, int i2, int i3, int i4,
        int i5, int i6) const
    {
        return unsigned(i0 - base(0)) < length_[0]
            && unsigned(i1 - base(1)) < length_[1]
            && unsigned(i2 - base(2)) < length_[2]
            && unsigned(i3 - base(3)) < length_[3]
            && unsigned(i4 - base(4)) < length_[4]
            && unsigned(i5 - base(5)) < length_[5]
            && unsigned(i6 - base(6)) < length_[6];
    }

    bool  isInRange(int i0, int i1, int i2, int i3, int i4,
        int i5, int i6, int i7) const
    {
        return unsigned(i0 - base(0)) < length_[0]
            && unsigned(i1 - base(1)) < length_[1]
            && unsigned(i2 - base(2)) < length_[2]
            && unsigned(i3 - base(3)) < length_[3]
            && unsigned(i4 - base(4)) < length_[4]
            && unsigned(i5 - base(5)) < length_[5]
            && unsigned(i6 - base(6)) < length_[6]
            && unsigned(i7 - base(7)) < length_[7];
    }

    bool  isInRange(int i0, int i1, int i2, int i3, int i4,
        int i5, int i6, int i7, int i8) const
    {
        return unsigned(i0 - base(0)) < length_[0]
            && unsigned(i1 - base(1)) < length_[1]
            && unsigned(i2 - base(2)) < length_[2]
            && unsigned(i3 - base(3)) < length_[3]
            && unsigned(i4 - base(4)) < length_[4]
            && unsigned(i5 - base(5)) < length_[5]
            && unsigned(i6 - base(6)) < length_[6]
            && unsigned(i7 - base(7)) < length_[7]
            && unsigned(i8 - base(8)) < length_[8];
    }

    bool  isInRange(int i0, int i1, int i2, int i3, int i4,
        int i5, int i6, int i7, int i8, int i9) const
    {
        return unsigned(i0 - base(0)) < length_[0]
            && unsigned(i1 - base(1)) < length_[1]
            && unsigned(i2 - base(2)) < length_[2]
            && unsigned(i3 - base(3)) < length_[3]
            && unsigned(i4 - base(4)) < length_[4]
            && unsigned(i5 - base(5)) < length_[5]
            && unsigned(i6 - base(6)) < length_[6]
            && unsigned(i7 - base(7)) < length_[7]
            && unsigned(i8 - base(8)) < length_[8]
            && unsigned(i9 - base(9)) < length_[9];
    }

    bool  isInRange(int i0, int i1, int i2, int i3, int i4,
        int i5, int i6, int i7, int i8, int i9, int i10) const
    {
        return unsigned(i0 - base(0)) < length_[0]
            && unsigned(i1 - base(1)) < length_[1]
            && unsigned(i2 - base(2)) < length_[2]
            && unsigned(i3 - base(3)) < length_[3]
            && unsigned(i4 - base(4)) < length_[4]
            && unsigned(i5 - base(5)) < length_[5]
            && unsigned(i6 - base(6)) < length_[6]
            && unsigned(i7 - base(7)) < length_[7]
            && unsigned(i8 - base(8)) < length_[8]
            && unsigned(i9 - base(9)) < length_[9]
            && unsigned(i10 - base(10)) < length_[10];
    }

    bool  isInRange(const T_index& index) const
    {
        for (int i=0; i < N_rank; ++i)
            if (unsigned(index[i] - base(i)) >= length_[i])
                return false ;

        return true ;
    }

    bool  assertInRange(const T_index& index) const
    {
         ;


        return true ;
    }

    bool  assertInRange(int i0) const
    {
         ;


        return true ;
    }

    bool  assertInRange(int i0, int i1) const
    {
         ;



        return true ;
    }

    bool  assertInRange(int i0, int i1, int i2) const
    {
         ;



        return true ;
    }

    bool  assertInRange(int i0, int i1, int i2, int i3) const
    {
         ;



        return true ;
    }

    bool  assertInRange(int i0, int i1, int i2, int i3, int i4) const
    {
         ;




        return true ;
    }

    bool  assertInRange(int i0, int i1, int i2, int i3, int i4, 
        int i5) const
    {
         ;




        return true ;
    }

    bool  assertInRange(int i0, int i1, int i2, int i3, int i4,
        int i5, int i6) const
    {
         ;





        return true ;
    }

    bool  assertInRange(int i0, int i1, int i2, int i3, int i4,
        int i5, int i6, int i7) const
    {
         ;





        return true ;
    }

    bool  assertInRange(int i0, int i1, int i2, int i3, int i4,
        int i5, int i6, int i7, int i8) const
    {
         ;






        return true ;
    }

    bool  assertInRange(int i0, int i1, int i2, int i3, int i4,
        int i5, int i6, int i7, int i8, int i9) const
    {
         ;






        return true ;
    }

    bool  assertInRange(int i0, int i1, int i2, int i3, int i4,
        int i5, int i6, int i7, int i8, int i9, int i10) const
    {
         ;






        return true ;
    }

     
     
     

    template<int N_rank2>
    T_numtype operator()(const TinyVector<int,N_rank2>& index) const
    {
        assertInRange(index);
        return data_[dot(index, stride_)];
    }

    template<int N_rank2>
    T_numtype&   operator()(const TinyVector<int,N_rank2>& index) 
    {
        assertInRange(index);
        return data_[dot(index, stride_)];
    }

    T_numtype operator()(TinyVector<int,1> index) const
    {
        assertInRange(index[0]);
        return data_[index[0] * stride_[0]];
    }

    T_numtype& operator()(TinyVector<int,1> index)
    {
        assertInRange(index[0]);
        return data_[index[0] * stride_[0]];
    }

    T_numtype operator()(TinyVector<int,2> index) const
    {
        assertInRange(index[0], index[1]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]];
    }

    T_numtype& operator()(TinyVector<int,2> index)
    {
        assertInRange(index[0], index[1]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]];
    }

    T_numtype operator()(TinyVector<int,3> index) const
    {
        assertInRange(index[0], index[1], index[2]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2]];
    }

    T_numtype& operator()(TinyVector<int,3> index)
    {
        assertInRange(index[0], index[1], index[2]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2]];
    }

    T_numtype operator()(const TinyVector<int,4>& index) const
    {
        assertInRange(index[0], index[1], index[2], index[3]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]];
    }

    T_numtype& operator()(const TinyVector<int,4>& index)
    {
        assertInRange(index[0], index[1], index[2], index[3]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]];
    }

    T_numtype operator()(const TinyVector<int,5>& index) const
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4]];
    }

    T_numtype& operator()(const TinyVector<int,5>& index)
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4]];
    }

    T_numtype operator()(const TinyVector<int,6>& index) const
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]];
    }

    T_numtype& operator()(const TinyVector<int,6>& index)
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]];
    }

    T_numtype operator()(const TinyVector<int,7>& index) const
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5], index[6]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]
            + index[6] * stride_[6]];
    }

    T_numtype& operator()(const TinyVector<int,7>& index)
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5], index[6]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]
            + index[6] * stride_[6]];
    }

    T_numtype operator()(const TinyVector<int,8>& index) const
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5], index[6], index[7]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]
            + index[6] * stride_[6] + index[7] * stride_[7]];
    }

    T_numtype& operator()(const TinyVector<int,8>& index)
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5], index[6], index[7]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]
            + index[6] * stride_[6] + index[7] * stride_[7]];
    }

    T_numtype operator()(const TinyVector<int,9>& index) const
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5], index[6], index[7], index[8]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]
            + index[6] * stride_[6] + index[7] * stride_[7]
            + index[8] * stride_[8]];
    }

    T_numtype& operator()(const TinyVector<int,9>& index)
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5], index[6], index[7], index[8]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]
            + index[6] * stride_[6] + index[7] * stride_[7]
            + index[8] * stride_[8]];
    }

    T_numtype operator()(const TinyVector<int,10>& index) const
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5], index[6], index[7], index[8], index[9]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]
            + index[6] * stride_[6] + index[7] * stride_[7]
            + index[8] * stride_[8] + index[9] * stride_[9]];
    }

    T_numtype& operator()(const TinyVector<int,10>& index)
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5], index[6], index[7], index[8], index[9]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]
            + index[6] * stride_[6] + index[7] * stride_[7]
            + index[8] * stride_[8] + index[9] * stride_[9]];
    }

    T_numtype operator()(const TinyVector<int,11>& index) const
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5], index[6], index[7], index[8], index[9],
            index[10]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]
            + index[6] * stride_[6] + index[7] * stride_[7]
            + index[8] * stride_[8] + index[9] * stride_[9]
            + index[10] * stride_[10]];
    }

    T_numtype& operator()(const TinyVector<int,11>& index)
    {
        assertInRange(index[0], index[1], index[2], index[3],
            index[4], index[5], index[6], index[7], index[8], index[9],
            index[10]);
        return data_[index[0] * stride_[0] + index[1] * stride_[1]
            + index[2] * stride_[2] + index[3] * stride_[3]
            + index[4] * stride_[4] + index[5] * stride_[5]
            + index[6] * stride_[6] + index[7] * stride_[7]
            + index[8] * stride_[8] + index[9] * stride_[9]
            + index[10] * stride_[10]];
    }

    T_numtype operator()(int i0) const
    { 
        assertInRange(i0);
        return data_[i0 * stride_[0]]; 
    }

    T_numtype&   operator()(int i0) 
    {
        assertInRange(i0);
        return data_[i0 * stride_[0]];
    }

    T_numtype operator()(int i0, int i1) const
    { 
        assertInRange(i0, i1);
        return data_[i0 * stride_[0] + i1 * stride_[1]];
    }

    T_numtype&   operator()(int i0, int i1)
    {
        assertInRange(i0, i1);
        return data_[i0 * stride_[0] + i1 * stride_[1]];
    }

    T_numtype operator()(int i0, int i1, int i2) const
    {
        assertInRange(i0, i1, i2);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2]];
    }

    T_numtype&   operator()(int i0, int i1, int i2) 
    {
        assertInRange(i0, i1, i2);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2]];
    }

    T_numtype operator()(int i0, int i1, int i2, int i3) const
    {
        assertInRange(i0, i1, i2, i3);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3]];
    }

    T_numtype&   operator()(int i0, int i1, int i2, int i3)
    {
        assertInRange(i0, i1, i2, i3);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3]];
    }

    T_numtype operator()(int i0, int i1, int i2, int i3,
        int i4) const
    {
        assertInRange(i0, i1, i2, i3, i4);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]];
    }

    T_numtype&   operator()(int i0, int i1, int i2, int i3,
        int i4)
    {
        assertInRange(i0, i1, i2, i3, i4);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]];
    }

    T_numtype operator()(int i0, int i1, int i2, int i3,
        int i4, int i5) const
    {
        assertInRange(i0, i1, i2, i3, i4, i5);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5]];
    }

    T_numtype&   operator()(int i0, int i1, int i2, int i3,
        int i4, int i5)
    {
        assertInRange(i0, i1, i2, i3, i4, i5);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5]];
    }

    T_numtype operator()(int i0, int i1, int i2, int i3,
        int i4, int i5, int i6) const
    {
        assertInRange(i0, i1, i2, i3, i4, i5, i6);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5] + i6 * stride_[6]];
    }

    T_numtype&   operator()(int i0, int i1, int i2, int i3,
        int i4, int i5, int i6)
    {
        assertInRange(i0, i1, i2, i3, i4, i5, i6);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5] + i6 * stride_[6]];
    }

    T_numtype operator()(int i0, int i1, int i2, int i3,
        int i4, int i5, int i6, int i7) const
    {
        assertInRange(i0, i1, i2, i3, i4, i5, i6, i7);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5] + i6 * stride_[6] + i7 * stride_[7]];
    }

    T_numtype&   operator()(int i0, int i1, int i2, int i3,
        int i4, int i5, int i6, int i7)
    {
        assertInRange(i0, i1, i2, i3, i4, i5, i6, i7);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5] + i6 * stride_[6] + i7 * stride_[7]];
    }

    T_numtype operator()(int i0, int i1, int i2, int i3,
        int i4, int i5, int i6, int i7, int i8) const
    {
        assertInRange(i0, i1, i2, i3, i4, i5, i6, i7, i8);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5] + i6 * stride_[6] + i7 * stride_[7]
            + i8 * stride_[8]];
    }

    T_numtype&   operator()(int i0, int i1, int i2, int i3,
        int i4, int i5, int i6, int i7, int i8)
    {
        assertInRange(i0, i1, i2, i3, i4, i5, i6, i7, i8);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5] + i6 * stride_[6] + i7 * stride_[7]
            + i8 * stride_[8]];
    }

    T_numtype operator()(int i0, int i1, int i2, int i3,
        int i4, int i5, int i6, int i7, int i8, int i9) const
    {
        assertInRange(i0, i1, i2, i3, i4, i5, i6, i7, i8, i9);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5] + i6 * stride_[6] + i7 * stride_[7]
            + i8 * stride_[8] + i9 * stride_[9]];
    }

    T_numtype&   operator()(int i0, int i1, int i2, int i3,
        int i4, int i5, int i6, int i7, int i8, int i9)
    {
        assertInRange(i0, i1, i2, i3, i4, i5, i6, i7, i8, i9);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5] + i6 * stride_[6] + i7 * stride_[7]
            + i8 * stride_[8] + i9 * stride_[9]];
    }

    T_numtype operator()(int i0, int i1, int i2, int i3,
        int i4, int i5, int i6, int i7, int i8, int i9, int i10) const
    {
        assertInRange(i0, i1, i2, i3, i4, i5, i6, i7, i8, 
            i9, i10);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5] + i6 * stride_[6] + i7 * stride_[7]
            + i8 * stride_[8] + i9 * stride_[9] + i10 * stride_[10]];
    }

    T_numtype&   operator()(int i0, int i1, int i2, int i3,
        int i4, int i5, int i6, int i7, int i8, int i9, int i10)
    {
        assertInRange(i0, i1, i2, i3, i4, i5, i6, i7, i8, 
            i9, i10);
        return data_[i0 * stride_[0] + i1 * stride_[1]
            + i2 * stride_[2] + i3 * stride_[3] + i4 * stride_[4]
            + i5 * stride_[5] + i6 * stride_[6] + i7 * stride_[7]
            + i8 * stride_[8] + i9 * stride_[9] + i10 * stride_[10]];
    }

     




    T_array& noConst() const
    { return const_cast<T_array&>(*this); }

    T_array operator()(const RectDomain<N_rank>& subdomain) const
    {
        return T_array(noConst(), subdomain);
    }

    T_array operator()(Range r0) const
    {
        return T_array(noConst(), r0);
    }

    T_array operator()(Range r0, Range r1) const
    {
        return T_array(noConst(), r0, r1);
    }

    T_array operator()(Range r0, Range r1, Range r2) const
    {
        return T_array(noConst(), r0, r1, r2);
    }

    T_array operator()(Range r0, Range r1, Range r2, Range r3) const
    {
        return T_array(noConst(), r0, r1, r2, r3);
    }

    T_array operator()(Range r0, Range r1, Range r2, Range r3, Range r4) const
    {
        return T_array(noConst(), r0, r1, r2, r3, r4);
    }

    T_array operator()(Range r0, Range r1, Range r2, Range r3, Range r4,
        Range r5) const
    {
        return T_array(noConst(), r0, r1, r2, r3, r4, r5);
    }

    T_array operator()(Range r0, Range r1, Range r2, Range r3, Range r4,
        Range r5, Range r6) const
    {
        return T_array(noConst(), r0, r1, r2, r3, r4, r5, r6);
    }

    T_array operator()(Range r0, Range r1, Range r2, Range r3, Range r4,
        Range r5, Range r6, Range r7) const
    {
        return T_array(noConst(), r0, r1, r2, r3, r4, r5, r6, r7);
    }

    T_array operator()(Range r0, Range r1, Range r2, Range r3, Range r4,
        Range r5, Range r6, Range r7, Range r8) const
    {
        return T_array(noConst(), r0, r1, r2, r3, r4, r5, r6, r7, r8);
    }

    T_array operator()(Range r0, Range r1, Range r2, Range r3, Range r4,
        Range r5, Range r6, Range r7, Range r8, Range r9) const
    {
        return T_array(noConst(), r0, r1, r2, r3, r4, r5, r6, r7, r8, r9);
    }

    T_array operator()(Range r0, Range r1, Range r2, Range r3, Range r4,
        Range r5, Range r6, Range r7, Range r8, Range r9, Range r10) const
    {
        return T_array(noConst(), r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10);
    }

     
     

     





















    template<class T1, class T2>
    typename  SliceInfo<T_numtype,T1,T2>::T_slice
    operator()(T1 r1, T2 r2) const
    {
        return SliceInfo<T_numtype,T1,T2>::T_slice(noConst(), r1, r2,
            nilArraySection(), nilArraySection(), nilArraySection(),
            nilArraySection(), nilArraySection(), nilArraySection(),
            nilArraySection(), nilArraySection(), nilArraySection());
    }

    template<class T1, class T2, class T3>
    typename  SliceInfo<T_numtype,T1,T2,T3>::T_slice 
    operator()(T1 r1, T2 r2, T3 r3) const
    {
        return SliceInfo<T_numtype,T1,T2,T3>::T_slice(noConst(), r1, r2, r3,
            nilArraySection(), nilArraySection(), nilArraySection(),
            nilArraySection(), nilArraySection(), nilArraySection(),
            nilArraySection(), nilArraySection());
    }

    template<class T1, class T2, class T3, class T4>
    typename  SliceInfo<T_numtype,T1,T2,T3,T4>::T_slice
    operator()(T1 r1, T2 r2, T3 r3, T4 r4) const
    {
        return SliceInfo<T_numtype,T1,T2,T3,T4>::T_slice(noConst(), r1, r2, r3,
            r4, nilArraySection(), nilArraySection(),
            nilArraySection(), nilArraySection(), nilArraySection(),
            nilArraySection(), nilArraySection());
    }

    template<class T1, class T2, class T3, class T4, class T5>
    typename  SliceInfo<T_numtype,T1,T2,T3,T4,T5>::T_slice
    operator()(T1 r1, T2 r2, T3 r3, T4 r4, T5 r5) const
    {
        return SliceInfo<T_numtype,T1,T2,T3,T4,T5>::T_slice(noConst(), r1, r2, 
            r3, r4, r5, nilArraySection(),
            nilArraySection(), nilArraySection(), nilArraySection(),
            nilArraySection(), nilArraySection());
    }

    template<class T1, class T2, class T3, class T4, class T5, class T6>
    typename  SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6>::T_slice
    operator()(T1 r1, T2 r2, T3 r3, T4 r4, T5 r5, T6 r6) const
    {
        return SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6>::T_slice(noConst(), r1, 
            r2, r3, r4, r5, r6, 
            nilArraySection(), nilArraySection(), nilArraySection(),
            nilArraySection(), nilArraySection());
    }

    template<class T1, class T2, class T3, class T4, class T5, class T6,
        class T7>
    typename  SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6,T7>::T_slice
    operator()(T1 r1, T2 r2, T3 r3, T4 r4, T5 r5, T6 r6, T7 r7) const
    {
        return SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6,T7>::T_slice(noConst(), 
            r1, r2, r3, r4, r5, r6, r7,
            nilArraySection(), nilArraySection(),
            nilArraySection(), nilArraySection());
    }

    template<class T1, class T2, class T3, class T4, class T5, class T6,
        class T7, class T8>
    typename  SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6,T7,T8>::T_slice
    operator()(T1 r1, T2 r2, T3 r3, T4 r4, T5 r5, T6 r6, T7 r7, T8 r8) const
    {
        return SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6,T7,T8>::T_slice(noConst(), 
            r1, r2, r3, r4, r5, r6, r7, r8,
            nilArraySection(), nilArraySection(), nilArraySection());
    }

    template<class T1, class T2, class T3, class T4, class T5, class T6,
        class T7, class T8, class T9>
    typename  SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6,T7,T8,T9>::T_slice
    operator()(T1 r1, T2 r2, T3 r3, T4 r4, T5 r5, T6 r6, T7 r7, T8 r8, 
        T9 r9) const
    {
        return SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6,T7,T8,T9>
            ::T_slice(noConst(), 
            r1, r2, r3, r4, r5, r6, r7, r8, r9, 
            nilArraySection(), nilArraySection());
    }

    template<class T1, class T2, class T3, class T4, class T5, class T6,
        class T7, class T8, class T9, class T10>
    typename  SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10>::T_slice
    operator()(T1 r1, T2 r2, T3 r3, T4 r4, T5 r5, T6 r6, T7 r7, T8 r8,
        T9 r9, T10 r10) const
    {
        return SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6,T7,T8,T9,
            T10>::T_slice(noConst(), r1, r2, r3, r4, r5, r6, r7, r8, 
            r9, r10, nilArraySection());
    }

    template<class T1, class T2, class T3, class T4, class T5, class T6,
        class T7, class T8, class T9, class T10, class T11>
    typename  SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,
        T11>::T_slice
    operator()(T1 r1, T2 r2, T3 r3, T4 r4, T5 r5, T6 r6, T7 r7, T8 r8,
        T9 r9, T10 r10, T11 r11) const
    {
        return SliceInfo<T_numtype,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,
            T11>::T_slice(noConst(), r1, r2, r3, r4, r5, r6, r7, r8, r9, 
            r10, r11);
    }



     










    template<int N0>
    _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0> >
    operator()(IndexPlaceholder<N0>) const
    { 
        return _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0> >
            (noConst());
    }

    template<int N0, int N1>
    _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0, N1> >
    operator()(IndexPlaceholder<N0>, IndexPlaceholder<N1>) const
    {
        return _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0,
            N1> >(noConst());
    } 

    template<int N0, int N1, int N2>
    _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0, N1, N2> >
    operator()(IndexPlaceholder<N0>, IndexPlaceholder<N1>,
        IndexPlaceholder<N2>) const
    {
        return _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0,
            N1, N2> >(noConst());
    }

    template<int N0, int N1, int N2, int N3>
    _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0, N1, N2, N3> >
    operator()(IndexPlaceholder<N0>, IndexPlaceholder<N1>,
        IndexPlaceholder<N2>, IndexPlaceholder<N3>) const
    {
        return _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0,
            N1, N2, N3> >(noConst());
    }

    template<int N0, int N1, int N2, int N3, int N4>
    _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0, N1, N2, N3, N4> >
    operator()(IndexPlaceholder<N0>, IndexPlaceholder<N1>,
        IndexPlaceholder<N2>, IndexPlaceholder<N3>, 
        IndexPlaceholder<N4>) const
    {
        return _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0,
            N1, N2, N3, N4> >(noConst());
    }

    template<int N0, int N1, int N2, int N3, int N4, int N5>
    _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0, N1, N2, N3, 
        N4, N5> >
    operator()(IndexPlaceholder<N0>, IndexPlaceholder<N1>,
        IndexPlaceholder<N2>, IndexPlaceholder<N3>, IndexPlaceholder<N4>,
        IndexPlaceholder<N5>) const
    {
        return _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0,
            N1, N2, N3, N4, N5> >(noConst());
    }

    template<int N0, int N1, int N2, int N3, int N4, int N5, int N6>
    _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0, N1, N2, N3,
        N4, N5, N6> >
    operator()(IndexPlaceholder<N0>, IndexPlaceholder<N1>,
        IndexPlaceholder<N2>, IndexPlaceholder<N3>, IndexPlaceholder<N4>,
        IndexPlaceholder<N5>, IndexPlaceholder<N6>) const
    {
        return _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0,
            N1, N2, N3, N4, N5, N6> >(noConst());
    }

    template<int N0, int N1, int N2, int N3, int N4, int N5, int N6,
        int N7>
    _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0, N1, N2, N3,
        N4, N5, N6, N7> >
    operator()(IndexPlaceholder<N0>, IndexPlaceholder<N1>,
        IndexPlaceholder<N2>, IndexPlaceholder<N3>, IndexPlaceholder<N4>,
        IndexPlaceholder<N5>, IndexPlaceholder<N6>, 
        IndexPlaceholder<N7>) const
    {
        return _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0,
            N1, N2, N3, N4, N5, N6, N7> >(noConst());
    }

    template<int N0, int N1, int N2, int N3, int N4, int N5, int N6,
        int N7, int N8>
    _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0, N1, N2, N3,
        N4, N5, N6, N7, N8> >
    operator()(IndexPlaceholder<N0>, IndexPlaceholder<N1>,
        IndexPlaceholder<N2>, IndexPlaceholder<N3>, IndexPlaceholder<N4>,
        IndexPlaceholder<N5>, IndexPlaceholder<N6>, IndexPlaceholder<N7>,
        IndexPlaceholder<N8>) const
    {
        return _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0,
            N1, N2, N3, N4, N5, N6, N7, N8> >(noConst());
    }

    template<int N0, int N1, int N2, int N3, int N4, int N5, int N6,
        int N7, int N8, int N9>
    _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0, N1, N2, N3,
        N4, N5, N6, N7, N8, N9> >
    operator()(IndexPlaceholder<N0>, IndexPlaceholder<N1>,
        IndexPlaceholder<N2>, IndexPlaceholder<N3>, IndexPlaceholder<N4>,
        IndexPlaceholder<N5>, IndexPlaceholder<N6>, IndexPlaceholder<N7>,
        IndexPlaceholder<N8>, IndexPlaceholder<N9>) const
    {
        return _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0,
            N1, N2, N3, N4, N5, N6, N7, N8, N9> >(noConst());
    }

    template<int N0, int N1, int N2, int N3, int N4, int N5, int N6,
        int N7, int N8, int N9, int N10>
    _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0, N1, N2, N3,
        N4, N5, N6, N7, N8, N9, N10> >
    operator()(IndexPlaceholder<N0>, IndexPlaceholder<N1>,
        IndexPlaceholder<N2>, IndexPlaceholder<N3>, IndexPlaceholder<N4>,
        IndexPlaceholder<N5>, IndexPlaceholder<N6>, IndexPlaceholder<N7>,
        IndexPlaceholder<N8>, IndexPlaceholder<N9>, 
        IndexPlaceholder<N10>) const
    {
        return _bz_ArrayExpr<ArrayIndexMapping<T_numtype, N_rank, N0,
            N1, N2, N3, N4, N5, N6, N7, N8, N9, N10> >(noConst());
    }

     
     
     

     




     
    Array< typename  multicomponent_traits<T_numtype>::T_element,N_rank>
    operator[](int component)
    {
        typedef typename  multicomponent_traits<T_numtype>::T_element 
            T_compType;

        return extractComponent(T_compType(), 
            component, multicomponent_traits<T_numtype>::numComponents);
    }

     
     
     
 
    template<class T_indexContainer>
    IndirectArray<T_array, T_indexContainer>
    operator[](const T_indexContainer& index)
    {
        return IndirectArray<T_array, T_indexContainer>(*this,
            const_cast<T_indexContainer&>(index));
    }
 
     
     
     

     
     
     
    ListInitializationSwitch<T_array> operator=(T_numtype x)
    {
        return ListInitializationSwitch<T_array>(*this, x);
    }

    T_array& initialize(T_numtype);

     
     


    template<class T_expr>
    T_array& operator=(const ETBase<T_expr>&);
    T_array& operator=(const Array<T_numtype,N_rank>&);

    template<class T> T_array& operator+=(const T&);
    template<class T> T_array& operator-=(const T&);
    template<class T> T_array& operator*=(const T&);
    template<class T> T_array& operator/=(const T&);
    template<class T> T_array& operator%=(const T&);
    template<class T> T_array& operator^=(const T&);
    template<class T> T_array& operator&=(const T&);
    template<class T> T_array& operator|=(const T&);
    template<class T> T_array& operator>>=(const T&);
    template<class T> T_array& operator<<=(const T&);

# 2264 "../blitz/array.h"


public:
     

    template<class T_expr, class T_update>
    inline T_array& evaluate(T_expr expr, T_update);


    template<class T_expr, class T_update>
    inline T_array& evaluateWithFastTraversal(
        const TraversalOrder<N_rank - 1>& order, 
        T_expr expr, T_update);



    template<class T_expr, class T_update>
    inline T_array& evaluateWithTiled2DTraversal(
        T_expr expr, T_update);


    template<class T_expr, class T_update>
    inline T_array& evaluateWithIndexTraversal1(
        T_expr expr, T_update);

    template<class T_expr, class T_update>
    inline T_array& evaluateWithIndexTraversalN(
        T_expr expr, T_update);

    template<class T_expr, class T_update>
    inline T_array& evaluateWithStackTraversal1(
        T_expr expr, T_update);

    template<class T_expr, class T_update>
    inline T_array& evaluateWithStackTraversalN(
        T_expr expr, T_update);


    T_numtype*   getInitializationIterator()
    { return dataFirst(); }

    bool  canCollapse(int outerRank, int innerRank) const
    { 





        return (stride(innerRank) * extent(innerRank) == stride(outerRank)); 
    }

protected:
     
     
     

    inline  void computeStrides();
    inline  void setupStorage(int rank);
    void constructSubarray(Array<T_numtype, N_rank>& array, 
        const RectDomain<N_rank>&);
    void constructSubarray(Array<T_numtype, N_rank>& array, Range r0);
    void constructSubarray(Array<T_numtype, N_rank>& array, Range r0, Range r1);
    void constructSubarray(Array<T_numtype, N_rank>& array, Range r0,
        Range r1, Range r2);
    void constructSubarray(Array<T_numtype, N_rank>& array, Range r0,
        Range r1, Range r2, Range r3);
    void constructSubarray(Array<T_numtype, N_rank>& array, Range r0,
        Range r1, Range r2, Range r3, Range r4);
    void constructSubarray(Array<T_numtype, N_rank>& array, Range r0,
        Range r1, Range r2, Range r3, Range r4, Range r5);
    void constructSubarray(Array<T_numtype, N_rank>& array, Range r0,
        Range r1, Range r2, Range r3, Range r4, Range r5, Range r6);
    void constructSubarray(Array<T_numtype, N_rank>& array, Range r0,
        Range r1, Range r2, Range r3, Range r4, Range r5, Range r6,
        Range r7);
    void constructSubarray(Array<T_numtype, N_rank>& array, Range r0,
        Range r1, Range r2, Range r3, Range r4, Range r5, Range r6,
        Range r7, Range r8);
    void constructSubarray(Array<T_numtype, N_rank>& array, Range r0,
        Range r1, Range r2, Range r3, Range r4, Range r5, Range r6,
        Range r7, Range r8, Range r9);
    void constructSubarray(Array<T_numtype, N_rank>& array, Range r0,
        Range r1, Range r2, Range r3, Range r4, Range r5, Range r6,
        Range r7, Range r8, Range r9, Range r10);

    void calculateZeroOffset();

    template<int N_rank2, class R0, class R1, class R2, class R3, class R4, 
        class R5, class R6, class R7, class R8, class R9, class R10>
    void constructSlice(Array<T_numtype, N_rank2>& array, R0 r0, R1 r1, R2 r2, 
        R3 r3, R4 r4, R5 r5, R6 r6, R7 r7, R8 r8, R9 r9, R10 r10);

    template<int N_rank2>
    void slice(int& setRank, Range r, Array<T_numtype,N_rank2>& array,
        TinyVector<int,N_rank2>& rankMap, int sourceRank);

    template<int N_rank2>
    void slice(int& setRank, int i, Array<T_numtype,N_rank2>& array,
        TinyVector<int,N_rank2>& rankMap, int sourceRank);

    template<int N_rank2>
    void slice(int& setRank, nilArraySection, Array<T_numtype,N_rank2>& array,
        TinyVector<int,N_rank2>& rankMap, int sourceRank)
    { }

    void doTranspose(int destRank, int sourceRank, T_array& array);

protected:
     
     
     

     

     














    GeneralArrayStorage<N_rank> storage_;
    TinyVector<int, N_rank> length_;
    TinyVector<int, N_rank> stride_;
    int zeroOffset_;
};

 











const int firstRank    = 0;
const int secondRank   = 1;
const int thirdRank    = 2;
const int fourthRank   = 3;
const int fifthRank    = 4;
const int sixthRank    = 5;
const int seventhRank  = 6;
const int eighthRank   = 7;
const int ninthRank    = 8;
const int tenthRank    = 9;
const int eleventhRank = 10;

const int firstDim    = 0;
const int secondDim   = 1;
const int thirdDim    = 2;
const int fourthDim   = 3;
const int fifthDim    = 4;
const int sixthDim    = 5;
const int seventhDim  = 6;
const int eighthDim   = 7;
const int ninthDim    = 8;
const int tenthDim    = 9;
const int eleventhDim = 10;

 



template<class T_numtype>
ostream& operator<<(ostream&, const Array<T_numtype,1>&);

template<class T_numtype>
ostream& operator<<(ostream&, const Array<T_numtype,2>&);

template<class T_numtype, int N_rank>
ostream& operator<<(ostream&, const Array<T_numtype,N_rank>&);

template<class T_numtype, int N_rank>
istream& operator>>(istream& is, Array<T_numtype,N_rank>& x);

} 

 




# 1 "../blitz/array/iter.h" 1







namespace  blitz  { 

struct _bz_endTag { };


template<class T, int N>
class ConstArrayIterator {

public:
    ConstArrayIterator(const Array<T,N>& array)
    {
         
         
        strides_ = array.stride();
        lbound_ = array.lbound();
        extent_ = array.extent();
        order_ = array.ordering();
        first_ = const_cast<T*>(array.dataFirst());
        data_ = first_;

        maxRank_ = order_(0);
        stride_ = strides_(maxRank_);

        for (int i=0; i < N; ++i)
        {
            stack_[i] = data_;
            last_[i] = data_ + array.extent(order_(i))  
                * strides_(order_(i));
        }

        pos_ = lbound_;
    }

    ConstArrayIterator(const Array<T,N>& array, _bz_endTag)
    {
         
         
         

         
         
         
        data_ = 0;
    }

    T operator*() const
    {
         ;

        return *data_;
    }

    const T*   operator->() const
    {
         ;

        return data_;
    }

    ConstArrayIterator<T,N>& operator++();

     
     
     
     
     
     
     
     
     
     
    void operator++(int)
    { ++(*this); }

    const TinyVector<int,N>& position() const
    { 
         ;

        return pos_; 
    }
   
    bool operator==(const ConstArrayIterator<T,N>& x) const
    {
        return data_ == x.data_;
    }

    bool operator!=(const ConstArrayIterator<T,N>& x) const
    {
        return data_ != x.data_;
    }
 
private:
    ConstArrayIterator() { }

private:
    TinyVector<int,N> strides_, lbound_, extent_, order_;
    T * stack_[N];
    T * last_[N];
    int stride_;
    int maxRank_;

protected:
    TinyVector<int,N> pos_;
    T *   data_;
    T *   first_;
};



template<class T, int N>
class ArrayIterator : public ConstArrayIterator<T,N> {
  public:
    ArrayIterator(Array<T,N>& x)
      : ConstArrayIterator<T,N>(x)
    { }

    ArrayIterator(Array<T,N>& x, _bz_endTag y)
      : ConstArrayIterator<T,N>(x,y)
    { }

    ArrayIterator<T,N>& operator++()
    {
        ConstArrayIterator<T,N>::operator++();
        return *this;
    }

    T& operator*()
    {
        return *data_;
    }

    T*   operator->() 
    {
        return data_;
    }
};



template<class T, int N>
ConstArrayIterator<T,N>& ConstArrayIterator<T,N>::operator++()
{
     ;

    data_ += stride_;

    if (data_ != last_[0])
    {
         
        ++pos_[maxRank_];
        return *this;
    }

     
     

    int j = 1;
    for (; j < N; ++j)
    {
        int r = order_(j);
        data_ = stack_[j];
        data_ += strides_[r];
        ++pos_(r);

        if (data_ != last_[j])
            break;
    }

     
    if (j == N)
    {
         
         
        data_ = 0;
        return *this;
    }

    stack_[j] = data_;

     
    for (--j; j >= 0; --j)
    {
        int r2 = order_(j);
        stack_[j] = data_;
        last_[j] = data_ + extent_(r2) * strides_(r2);
        pos_(r2) = lbound_(r2);
    }

    return *this;
}

} 



# 2458 "../blitz/array.h" 2

# 1 "../blitz/array/fastiter.h" 1
 




































 
# 1 "/u/tveldhui/software/egcs-irix/include/g++/strstream" 1 3
 
 



# 1 "/u/tveldhui/software/egcs-irix/include/g++/strstream.h" 1 3
 























 




#pragma interface


# 1 "/u/tveldhui/software/egcs-irix/include/g++/strfile.h" 1 3
 





































typedef void *(*_IO_alloc_type)  (_G_size_t )  ;
typedef void (*_IO_free_type)  (void*)  ;

struct _IO_str_fields
{
  _IO_alloc_type _allocate_buffer;
  _IO_free_type _free_buffer;
};

 




struct _IO_streambuf
{
  struct _IO_FILE _f;
  const void *_vtable;
};

typedef struct _IO_strfile_
{
  struct _IO_streambuf _sbf;
  struct _IO_str_fields _s;
} _IO_strfile;

 



 


# 33 "/u/tveldhui/software/egcs-irix/include/g++/strstream.h" 2 3


extern "C++" {
class strstreambuf : public streambuf
{
  struct _IO_str_fields _s;
  friend class istrstream;

    void init_dynamic(_IO_alloc_type alloc, _IO_free_type free,
		      int initial_size = 0);
    void init_static(char *ptr, int size, char *pstart);
    void init_readonly(const char *ptr, int size);
  protected:
    virtual int overflow(int = (-1) );
    virtual int underflow();
    virtual int pbackfail(int c);
  public:
    virtual ~strstreambuf();
    strstreambuf() { init_dynamic(0, 0); }
    strstreambuf(int initial_size) { init_dynamic(0, 0, initial_size); }
    strstreambuf(void *(*alloc)(_G_size_t ), void (*free)(void*))
	{ init_dynamic(alloc, free); }
    strstreambuf(char *ptr, int size, char *pstart = __null )
	{ init_static(ptr, size, pstart); }
    strstreambuf(unsigned char *ptr, int size, unsigned char *pstart = __null )
	{ init_static((char*)ptr, size, (char*)pstart); }
    strstreambuf(const char *ptr, int size)
	{ init_readonly(ptr, size); }
    strstreambuf(const unsigned char *ptr, int size)
	{ init_readonly((const char*)ptr, size); }
    strstreambuf(signed char *ptr, int size, signed char *pstart = __null )
	{ init_static((char*)ptr, size, (char*)pstart); }
    strstreambuf(const signed char *ptr, int size)
	{ init_readonly((const char*)ptr, size); }
     
    int frozen() { return _flags & 1  ? 1 : 0; }
    void freeze(int n=1)
	{ if ((( this )->_s._allocate_buffer != (_IO_alloc_type)0) )
	    { if (n) _flags |= 1 ; else _flags &= ~1 ; } }
    _G_ssize_t  pcount();
    char *str();
    virtual streampos seekoff(streamoff, _seek_dir, int mode=ios::in|ios::out);
};

class strstreambase : virtual public ios {
  protected:
    strstreambuf __my_sb;
  public:
    strstreambuf* rdbuf() { return &__my_sb; }
  protected:
    strstreambase() { init (&__my_sb); }
    strstreambase(char *cp, int n, int mode=ios::out);
};

class istrstream : public strstreambase, public istream {
  public:
    istrstream(const char*, int=0);
};

class ostrstream : public strstreambase, public ostream {
  public:
    ostrstream() { }
    ostrstream(char *cp, int n, int mode=ios::out) :strstreambase(cp,n,mode){}
    _G_ssize_t  pcount() { return ((strstreambuf*)_strbuf)->pcount(); }
    char *str() { return ((strstreambuf*)_strbuf)->str(); }
    void freeze(int n = 1) { ((strstreambuf*)_strbuf)->freeze(n); }
    int frozen() { return ((strstreambuf*)_strbuf)->frozen(); }
};

class strstream : public strstreambase, public iostream {
  public:
  strstream() { }
    strstream(char *cp, int n, int mode=ios::out) :strstreambase(cp,n,mode){}
    _G_ssize_t  pcount() { return ((strstreambuf*)_strbuf)->pcount(); }
    char *str() { return ((strstreambuf*)_strbuf)->str(); }
    void freeze(int n = 1) { ((strstreambuf*)_strbuf)->freeze(n); }
    int frozen() { return ((strstreambuf*)_strbuf)->frozen(); }
};
}  


# 6 "/u/tveldhui/software/egcs-irix/include/g++/strstream" 2 3


# 38 "../blitz/array/fastiter.h" 2





namespace  blitz  { 





template<class P_numtype, int N_rank>
class FastArrayIterator {
public:
    typedef P_numtype                T_numtype;
    typedef Array<T_numtype, N_rank> T_array;
    typedef FastArrayIterator<P_numtype, N_rank> T_iterator;
    typedef const T_array& T_ctorArg1;
    typedef int            T_ctorArg2;     

    enum { numArrayOperands = 1, numIndexPlaceholders = 0,
        rank = N_rank };

     
     
    FastArrayIterator(const FastArrayIterator<P_numtype, N_rank>& x)
        : array_(x.array_), data_(x.data_)
    { }

    void operator=(const FastArrayIterator<P_numtype, N_rank>& x)
    {
        array_ = x.array_;
        data_ = x.data_;
        stack_ = x.stack_;
        stride_ = x.stride_;
    }

    FastArrayIterator(const T_array& array)
        : array_(array)
    {
        data_   = array.data();
    }

    ~FastArrayIterator()
    { }





    T_numtype operator()(const TinyVector<int, N_rank>& i)
    { return array_(i); }


    int lbound(int rank)
    { 
        if (rank < N_rank)
            return array_.lbound(rank); 
        else
            return (- 2147483647  -1) ;    
    }

    int ubound(int rank)
    { 
        if (rank < N_rank)
            return array_.ubound(rank); 
        else
            return 2147483647  ;    
    }

    T_numtype operator*()
    { return *data_; }

    T_numtype operator[](int i)
    { return data_[i * stride_]; }

    T_numtype fastRead(int i)
    { return data_[i]; }

    int suggestStride(int rank) const
    { return array_.stride(rank); }

    bool  isStride(int rank, int stride) const
    { return array_.stride(rank) == stride; }

    void push(int position)
    {
        stack_[position] = data_;
    }
  
    void pop(int position)
    { 
        data_ = stack_[position];
    }

    void advance()
    {
        data_ += stride_;
    }

    void advance(int n)
    {
        data_ += n * stride_;
    }

    void loadStride(int rank)
    {
        stride_ = array_.stride(rank);
    }

    const T_numtype *   data() const
    { return data_; }

    void _bz_setData(const T_numtype* ptr)
    { data_ = ptr; }

    int stride() const
    { return stride_; }

    bool  isUnitStride(int rank) const
    { return array_.stride(rank) == 1; }

    void advanceUnitStride()
    { ++data_; }

    bool  canCollapse(int outerLoopRank, int innerLoopRank) const
    { return array_.canCollapse(outerLoopRank, innerLoopRank); }

    void prettyPrint(string& str, prettyPrintFormat& format) const
    {
        if (format.tersePrintingSelected())
            str += format.nextArrayOperandSymbol();
        else if (format.dumpArrayShapesMode())
        {
            ostrstream ostr;
            ostr << array_.shape();
            str += ostr.str();
        }
        else {
            str += "Array<";
            str += typeid( T_numtype ).name() ;
            str += ",";

            char tmpBuf[10];
            sprintf(tmpBuf, "%d", N_rank);

            str += tmpBuf;
            str += ">";
        }
    }

    template<class T_shape>
    bool  shapeCheck(const T_shape& shape)
    { return areShapesConformable(shape, array_.length()); }


     
    T_numtype& operator()(int i)
    {
        return (T_numtype&)data_[i*array_.stride(0)];
    }

     
    T_numtype& operator()(int i, int j)
    {
        return (T_numtype&)data_[i*array_.stride(0) + j*array_.stride(1)];
    }

     
    T_numtype& operator()(int i, int j, int k)
    {
        return (T_numtype&)data_[i*array_.stride(0) + j*array_.stride(1)
          + k*array_.stride(2)];
    }

     

    void moveTo(int i, int j)
    {
        data_ = &const_cast<T_array&>(array_)(i,j);
    }

    void moveTo(int i, int j, int k)
    {
        data_ = &const_cast<T_array&>(array_)(i,j,k);
    }

    void moveTo(const TinyVector<int,N_rank>& i)
    {
        data_ = &const_cast<T_array&>(array_)(i);
    }

     
    void operator=(T_numtype x)
    {   *const_cast<T_numtype*  >(data_) = x; }

     
    template<class T_value>
    void operator=(T_value x)
    {   *const_cast<T_numtype*  >(data_) = x; }

     
    template<class T_value>
    void operator+=(T_value x)
    { *const_cast<T_numtype*  >(data_) += x; }

     

     
    operator T_numtype() const
    { return *data_; }

     
    T_numtype shift(int offset, int dim)
    {
        return data_[offset*array_.stride(dim)];
    }

     
    T_numtype shift(int offset1, int dim1, int offset2, int dim2)
    {
        return data_[offset1*array_.stride(dim1) 
            + offset2*array_.stride(dim2)];
    }

private:
    const T_numtype *            data_;
    const T_array&                          array_;
    const T_numtype *                       stack_[N_rank];
    int                                     stride_;
};

} 


# 2459 "../blitz/array.h" 2

# 1 "../blitz/array/expr.h" 1
 








































 
# 1 "../blitz/ops.h" 1
 















































namespace  blitz  { 

 
































# 104 "../blitz/ops.h"

template<class T_numtype1, class T_numtype2> struct  Add  { typedef typename  promote_trait< T_numtype1 ,  T_numtype2 >::T_promote  T_numtype; static inline T_numtype apply(T_numtype1 a, T_numtype2 b) { return a  +  b; } template<class T1, class T2> static inline void prettyPrint(string& str, prettyPrintFormat& format, const T1& t1, const T2& t2) { str += "("; t1.prettyPrint(str, format); str +=  "+" ; t2.prettyPrint(str, format); str += ")"; } } ;
template<class T_numtype1, class T_numtype2> struct  Subtract  { typedef typename  promote_trait< T_numtype1 ,  T_numtype2 >::T_promote  T_numtype; static inline T_numtype apply(T_numtype1 a, T_numtype2 b) { return a  -  b; } template<class T1, class T2> static inline void prettyPrint(string& str, prettyPrintFormat& format, const T1& t1, const T2& t2) { str += "("; t1.prettyPrint(str, format); str +=  "-" ; t2.prettyPrint(str, format); str += ")"; } } ;
template<class T_numtype1, class T_numtype2> struct  Multiply  { typedef typename  promote_trait< T_numtype1 ,  T_numtype2 >::T_promote  T_numtype; static inline T_numtype apply(T_numtype1 a, T_numtype2 b) { return a  *  b; } template<class T1, class T2> static inline void prettyPrint(string& str, prettyPrintFormat& format, const T1& t1, const T2& t2) { str += "("; t1.prettyPrint(str, format); str +=  "*" ; t2.prettyPrint(str, format); str += ")"; } } ;
template<class T_numtype1, class T_numtype2> struct  Divide  { typedef typename  promote_trait< T_numtype1 ,  T_numtype2 >::T_promote  T_numtype; static inline T_numtype apply(T_numtype1 a, T_numtype2 b) { return a  /  b; } template<class T1, class T2> static inline void prettyPrint(string& str, prettyPrintFormat& format, const T1& t1, const T2& t2) { str += "("; t1.prettyPrint(str, format); str +=  "/" ; t2.prettyPrint(str, format); str += ")"; } } ;
template<class T_numtype1, class T_numtype2> struct  Modulo  { typedef typename  promote_trait< T_numtype1 ,  T_numtype2 >::T_promote  T_numtype; static inline T_numtype apply(T_numtype1 a, T_numtype2 b) { return a  %  b; } template<class T1, class T2> static inline void prettyPrint(string& str, prettyPrintFormat& format, const T1& t1, const T2& t2) { str += "("; t1.prettyPrint(str, format); str +=  "%" ; t2.prettyPrint(str, format); str += ")"; } } ;
template<class T_numtype1, class T_numtype2> struct  BitwiseXor  { typedef typename  promote_trait< T_numtype1 ,  T_numtype2 >::T_promote  T_numtype; static inline T_numtype apply(T_numtype1 a, T_numtype2 b) { return a  ^  b; } template<class T1, class T2> static inline void prettyPrint(string& str, prettyPrintFormat& format, const T1& t1, const T2& t2) { str += "("; t1.prettyPrint(str, format); str +=  "^" ; t2.prettyPrint(str, format); str += ")"; } } ;
template<class T_numtype1, class T_numtype2> struct  BitwiseAnd  { typedef typename  promote_trait< T_numtype1 ,  T_numtype2 >::T_promote  T_numtype; static inline T_numtype apply(T_numtype1 a, T_numtype2 b) { return a  &  b; } template<class T1, class T2> static inline void prettyPrint(string& str, prettyPrintFormat& format, const T1& t1, const T2& t2) { str += "("; t1.prettyPrint(str, format); str +=  "&" ; t2.prettyPrint(str, format); str += ")"; } } ;
template<class T_numtype1, class T_numtype2> struct  BitwiseOr  { typedef typename  promote_trait< T_numtype1 ,  T_numtype2 >::T_promote  T_numtype; static inline T_numtype apply(T_numtype1 a, T_numtype2 b) { return a  |  b; } template<class T1, class T2> static inline void prettyPrint(string& str, prettyPrintFormat& format, const T1& t1, const T2& t2) { str += "("; t1.prettyPrint(str, format); str +=  "|" ; t2.prettyPrint(str, format); str += ")"; } } ;
template<class T_numtype1, class T_numtype2> struct  ShiftRight  { typedef typename  promote_trait< T_numtype1 ,  T_numtype2 >::T_promote  T_numtype; static inline T_numtype apply(T_numtype1 a, T_numtype2 b) { return a  >>  b; } template<class T1, class T2> static inline void prettyPrint(string& str, prettyPrintFormat& format, const T1& t1, const T2& t2) { str += "("; t1.prettyPrint(str, format); str +=  ">>" ; t2.prettyPrint(str, format); str += ")"; } } ;
template<class T_numtype1, class T_numtype2> struct  ShiftLeft  { typedef typename  promote_trait< T_numtype1 ,  T_numtype2 >::T_promote  T_numtype; static inline T_numtype apply(T_numtype1 a, T_numtype2 b) { return a  <<  b; } template<class T1, class T2> static inline void prettyPrint(string& str, prettyPrintFormat& format, const T1& t1, const T2& t2) { str += "("; t1.prettyPrint(str, format); str +=  "<<" ; t2.prettyPrint(str, format); str += ")"; } } ;


# 136 "../blitz/ops.h"

template<class T_numtype1, class T_numtype2> struct  Greater  { typedef bool T_numtype; static inline bool apply(T_numtype1 a, T_numtype2 b) { return a  >  b; } template<class T1, class T2> static inline void prettyPrint(string& str, prettyPrintFormat& format, const T1& t1, const T2& t2) { str += "("; t1.prettyPrint(str, format); str +=  ">" ; t2.prettyPrint(str, format); str += ")"; } } ;
template<class T_numtype1, class T_numtype2> struct  Less  { typedef bool T_numtype; static inline bool apply(T_numtype1 a, T_numtype2 b) { return a  <  b; } template<class T1, class T2> static inline void prettyPrint(string& str, prettyPrintFormat& format, const T1& t1, const T2& t2) { str += "("; t1.prettyPrint(str, format); str +=  "<" ; t2.prettyPrint(str, format); str += ")"; } } ;
template<class T_numtype1, class T_numtype2> struct  GreaterOrEqual  { typedef bool T_numtype; static inline bool apply(T_numtype1 a, T_numtype2 b) { return a  >=  b; } template<class T1, class T2> static inline void prettyPrint(string& str, prettyPrintFormat& format, const T1& t1, const T2& t2) { str += "("; t1.prettyPrint(str, format); str +=  ">=" ; t2.prettyPrint(str, format); str += ")"; } } ;
template<class T_numtype1, class T_numtype2> struct  LessOrEqual  { typedef bool T_numtype; static inline bool apply(T_numtype1 a, T_numtype2 b) { return a  <=  b; } template<class T1, class T2> static inline void prettyPrint(string& str, prettyPrintFormat& format, const T1& t1, const T2& t2) { str += "("; t1.prettyPrint(str, format); str +=  "<=" ; t2.prettyPrint(str, format); str += ")"; } } ;
template<class T_numtype1, class T_numtype2> struct  Equal  { typedef bool T_numtype; static inline bool apply(T_numtype1 a, T_numtype2 b) { return a  ==  b; } template<class T1, class T2> static inline void prettyPrint(string& str, prettyPrintFormat& format, const T1& t1, const T2& t2) { str += "("; t1.prettyPrint(str, format); str +=  "==" ; t2.prettyPrint(str, format); str += ")"; } } ;
template<class T_numtype1, class T_numtype2> struct  NotEqual  { typedef bool T_numtype; static inline bool apply(T_numtype1 a, T_numtype2 b) { return a  !=  b; } template<class T1, class T2> static inline void prettyPrint(string& str, prettyPrintFormat& format, const T1& t1, const T2& t2) { str += "("; t1.prettyPrint(str, format); str +=  "!=" ; t2.prettyPrint(str, format); str += ")"; } } ;
template<class T_numtype1, class T_numtype2> struct  LogicalAnd  { typedef bool T_numtype; static inline bool apply(T_numtype1 a, T_numtype2 b) { return a  &&  b; } template<class T1, class T2> static inline void prettyPrint(string& str, prettyPrintFormat& format, const T1& t1, const T2& t2) { str += "("; t1.prettyPrint(str, format); str +=  "&&" ; t2.prettyPrint(str, format); str += ")"; } } ;
template<class T_numtype1, class T_numtype2> struct  LogicalOr  { typedef bool T_numtype; static inline bool apply(T_numtype1 a, T_numtype2 b) { return a  ||  b; } template<class T1, class T2> static inline void prettyPrint(string& str, prettyPrintFormat& format, const T1& t1, const T2& t2) { str += "("; t1.prettyPrint(str, format); str +=  "||" ; t2.prettyPrint(str, format); str += ")"; } } ;

template<class T_numtype1, class T_cast>
struct Cast {
    typedef T_cast T_numtype;
    static inline T_cast apply(T_numtype1 a)
    { return a; }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += typeid( T_cast ).name() ;
        str += "(";
        a.prettyPrint(str, format);
        str += ")";
    }
};

template<class T_numtype1>
struct LogicalNot {
    typedef bool T_numtype;
    static inline bool apply(T_numtype1 a)
    { return !a; }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "!";
        a.prettyPrint(str, format);
    }
};

template<class T_numtype1>
struct BitwiseNot {
    typedef T_numtype1 T_numtype;
    static inline T_numtype apply(T_numtype1 a)
    { return ~a; }

    template<class T1>
    static void prettyPrint(string& os, prettyPrintFormat& format,
        const T1& a)
    {
        str += "~";
        a.prettyPrint(os,format);
    }
};

template<class T_numtype1>
struct Negate {
    typedef T_numtype1 T_numtype;
    static inline T_numtype apply(T_numtype1 a)
    { return -a; }

    template<class T1>
    static void prettyPrint(string& str, prettyPrintFormat& format,
        const T1& a)
    {
        str += "-";
        a.prettyPrint(str, format);
    }
};
} 




# 42 "../blitz/array/expr.h" 2








 
# 1 "../blitz/shapecheck.h" 1
 
































namespace  blitz  { 

 








template<class T_shape1, class T_shape2>
inline bool  areShapesConformable(const T_shape1&, const T_shape2&)
{
     
     
     
     
    return false ;
}

template<class T_shape>
inline bool  areShapesConformable(const T_shape& a, const T_shape& b)
{
     

     
     
     

    for (int i=0; i < a.length(); ++i)
    {
        if (a[i] != b[i])
        {
             ;

            return false ;
        }
    }

    return true ;
}

} 


# 50 "../blitz/array/expr.h" 2




 
# 1 "../blitz/numinquire.h" 1
 
































 
















  
# 1 "../blitz/limits-hack.h" 1
 



 












 







# 1 "/u/tveldhui/software/egcs-irix/lib/gcc-lib/mips-sgi-irix6.5/egcs-2.91.66/include/float.h" 1 3
 


 

    


    


    


    


    


    


    


    


    


    


    



    


    


    


    


    


    


    


    


    



    


    


    


    


    


    


    


    


    




# 26 "../blitz/limits-hack.h" 2


namespace  std  { 

enum float_round_style {
  round_indeterminate       = -1,
  round_toward_zero         =  0,
  round_to_nearest          =  1,
  round_toward_infinity     =  2,
  round_toward_neg_infinity =  3
};

enum float_denorm_style {
  denorm_indeterminate = -1,
  denorm_absent        =  0,
  denorm_present       =  1
};

 

template <class __number>
class _Numeric_limits_base {
public:
  static const bool is_specialized = false;

  static __number min()  { return __number(); }
  static __number max()  { return __number(); }

  static const int digits   = 0;
  static const int digits10 = 0;

  static const bool is_signed  = false;
  static const bool is_integer = false;
  static const bool is_exact   = false;

  static const int radix = 0;

  static __number epsilon()      { return __number(); }
  static __number round_error()  { return __number(); }

  static const int min_exponent   = 0;
  static const int min_exponent10 = 0;
  static const int max_exponent   = 0;
  static const int max_exponent10 = 0;

  static const bool has_infinity      = false;
  static const bool has_quiet_NaN     = false;
  static const bool has_signaling_NaN = false;
  static const float_denorm_style has_denorm = denorm_absent;
  static const bool has_denorm_loss   = false;

  static __number infinity()       { return __number(); }
  static __number quiet_NaN()      { return __number(); }
  static __number signaling_NaN()  { return __number(); }
  static __number denorm_min()     { return __number(); }

  static const bool is_iec559  = false;
  static const bool is_bounded = false;
  static const bool is_modulo  = false;

  static const bool traps           = false;
  static const bool tinyness_before = false;
  static const float_round_style round_style = round_toward_zero;
};





template <class __number> const  bool  _Numeric_limits_base<__number>::   is_specialized  ;
template <class __number> const  int  _Numeric_limits_base<__number>::   digits  ;
template <class __number> const  int  _Numeric_limits_base<__number>::   digits10  ;
template <class __number> const  bool  _Numeric_limits_base<__number>::   is_signed  ;
template <class __number> const  bool  _Numeric_limits_base<__number>::   is_integer  ;
template <class __number> const  bool  _Numeric_limits_base<__number>::   is_exact  ;
template <class __number> const  int  _Numeric_limits_base<__number>::   radix  ;
template <class __number> const  int  _Numeric_limits_base<__number>::   min_exponent  ;
template <class __number> const  int  _Numeric_limits_base<__number>::   max_exponent  ;
template <class __number> const  int  _Numeric_limits_base<__number>::   min_exponent10  ;
template <class __number> const  int  _Numeric_limits_base<__number>::   max_exponent10  ;
template <class __number> const  bool  _Numeric_limits_base<__number>::   has_infinity  ;
template <class __number> const  bool  _Numeric_limits_base<__number>::   has_quiet_NaN  ;
template <class __number> const  bool  _Numeric_limits_base<__number>::   has_signaling_NaN  ;
template <class __number> const  float_denorm_style  _Numeric_limits_base<__number>::   has_denorm  ;
template <class __number> const  bool  _Numeric_limits_base<__number>::   has_denorm_loss  ;
template <class __number> const  bool  _Numeric_limits_base<__number>::   is_iec559  ;
template <class __number> const  bool  _Numeric_limits_base<__number>::   is_bounded  ;
template <class __number> const  bool  _Numeric_limits_base<__number>::   is_modulo  ;
template <class __number> const  bool  _Numeric_limits_base<__number>::   traps  ;
template <class __number> const  bool  _Numeric_limits_base<__number>::   tinyness_before  ;
template <class __number> const  float_round_style  _Numeric_limits_base<__number>::   round_style  ;



 

template <class _Int,
          _Int __imin,
          _Int __imax,
          int __idigits = -1>
class _Integer_limits : public _Numeric_limits_base<_Int> 
{
public:
  static const bool is_specialized = true;

  static _Int min()  { return __imin; }
  static _Int max()  { return __imax; }

  static const int digits = 
    (__idigits < 0) ? sizeof(_Int) * 8  - (__imin == 0 ? 0 : 1) 
                    : __idigits;
  static const int digits10 = (digits * 301) / 1000; 
                                 

  static const bool is_signed = __imin != 0;
  static const bool is_integer = true;
  static const bool is_exact = true;
  static const int radix = 2;


  static const bool is_bounded = true;
  static const bool is_modulo = true;
};





template <class _Int, _Int __imin, _Int __imax, int __idigits> const  bool  _Integer_limits<_Int, __imin, __imax, __idigits>::   is_specialized  ;
template <class _Int, _Int __imin, _Int __imax, int __idigits> const  int  _Integer_limits<_Int, __imin, __imax, __idigits>::   digits  ;
template <class _Int, _Int __imin, _Int __imax, int __idigits> const  int  _Integer_limits<_Int, __imin, __imax, __idigits>::   digits10  ;
template <class _Int, _Int __imin, _Int __imax, int __idigits> const  bool  _Integer_limits<_Int, __imin, __imax, __idigits>::   is_signed  ;
template <class _Int, _Int __imin, _Int __imax, int __idigits> const  bool  _Integer_limits<_Int, __imin, __imax, __idigits>::   is_integer  ;
template <class _Int, _Int __imin, _Int __imax, int __idigits> const  bool  _Integer_limits<_Int, __imin, __imax, __idigits>::   is_exact  ;
template <class _Int, _Int __imin, _Int __imax, int __idigits> const  int  _Integer_limits<_Int, __imin, __imax, __idigits>::   radix  ;
template <class _Int, _Int __imin, _Int __imax, int __idigits> const  bool  _Integer_limits<_Int, __imin, __imax, __idigits>::   is_bounded  ;
template <class _Int, _Int __imin, _Int __imax, int __idigits> const  bool  _Integer_limits<_Int, __imin, __imax, __idigits>::   is_modulo  ;



 
template <class __number,
         int __Digits, int __Digits10,
         int __MinExp, int __MaxExp,
         int __MinExp10, int __MaxExp10,
         unsigned int __InfinityWord,
         unsigned int __QNaNWord, unsigned int __SNaNWord,
         bool __IsIEC559,
         float_round_style __RoundStyle>
class _Floating_limits : public _Numeric_limits_base<__number>
{
public:
  static const bool is_specialized = true;

  static const int digits   = __Digits;
  static const int digits10 = __Digits10;

  static const bool is_signed = true;

  static const int radix = 2;

  static const int min_exponent   = __MinExp;
  static const int max_exponent   = __MaxExp;
  static const int min_exponent10 = __MinExp10;
  static const int max_exponent10 = __MaxExp10;

  static const bool has_infinity      = true;
  static const bool has_quiet_NaN     = true;
  static const bool has_signaling_NaN = true;
  static const float_denorm_style has_denorm = denorm_indeterminate;
  static const bool has_denorm_loss   = false;

  static __number infinity()  {
    static unsigned int _S_inf[sizeof(__number) / sizeof(int)] = 
      { __InfinityWord };
    return *reinterpret_cast<__number*>(&_S_inf);
  }
  static __number quiet_NaN()  {
    static unsigned int _S_nan[sizeof(__number) / sizeof(int)] = 
      { __QNaNWord };
    return *reinterpret_cast<__number*>(&_S_nan);
  }
  static __number signaling_NaN()  {
    static unsigned int _S_nan[sizeof(__number) / sizeof(int)] = 
      { __SNaNWord };
    return *reinterpret_cast<__number*>(&_S_nan);
  }

  static const bool is_iec559       = __IsIEC559;
  static const bool is_bounded      = true;
  static const bool traps           = true;
  static const bool tinyness_before = false;

  static const float_round_style round_style = __RoundStyle;
};










template <class __Num, int __Dig, int __Dig10, int __MnX, int __MxX, int __MnX10, int __MxX10, unsigned int __Inf, unsigned int __QNaN, unsigned int __SNaN, bool __IsIEEE, float_round_style __Sty> const  bool  _Floating_limits<__Num, __Dig, __Dig10, __MnX, __MxX, __MnX10, __MxX10, __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>::   is_specialized  ;  
template <class __Num, int __Dig, int __Dig10, int __MnX, int __MxX, int __MnX10, int __MxX10, unsigned int __Inf, unsigned int __QNaN, unsigned int __SNaN, bool __IsIEEE, float_round_style __Sty> const  int  _Floating_limits<__Num, __Dig, __Dig10, __MnX, __MxX, __MnX10, __MxX10, __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>::   digits  ;  
template <class __Num, int __Dig, int __Dig10, int __MnX, int __MxX, int __MnX10, int __MxX10, unsigned int __Inf, unsigned int __QNaN, unsigned int __SNaN, bool __IsIEEE, float_round_style __Sty> const  int  _Floating_limits<__Num, __Dig, __Dig10, __MnX, __MxX, __MnX10, __MxX10, __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>::   digits10  ;  
template <class __Num, int __Dig, int __Dig10, int __MnX, int __MxX, int __MnX10, int __MxX10, unsigned int __Inf, unsigned int __QNaN, unsigned int __SNaN, bool __IsIEEE, float_round_style __Sty> const  bool  _Floating_limits<__Num, __Dig, __Dig10, __MnX, __MxX, __MnX10, __MxX10, __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>::   is_signed  ;  
template <class __Num, int __Dig, int __Dig10, int __MnX, int __MxX, int __MnX10, int __MxX10, unsigned int __Inf, unsigned int __QNaN, unsigned int __SNaN, bool __IsIEEE, float_round_style __Sty> const  int  _Floating_limits<__Num, __Dig, __Dig10, __MnX, __MxX, __MnX10, __MxX10, __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>::   radix  ;  
template <class __Num, int __Dig, int __Dig10, int __MnX, int __MxX, int __MnX10, int __MxX10, unsigned int __Inf, unsigned int __QNaN, unsigned int __SNaN, bool __IsIEEE, float_round_style __Sty> const  int  _Floating_limits<__Num, __Dig, __Dig10, __MnX, __MxX, __MnX10, __MxX10, __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>::   min_exponent  ;  
template <class __Num, int __Dig, int __Dig10, int __MnX, int __MxX, int __MnX10, int __MxX10, unsigned int __Inf, unsigned int __QNaN, unsigned int __SNaN, bool __IsIEEE, float_round_style __Sty> const  int  _Floating_limits<__Num, __Dig, __Dig10, __MnX, __MxX, __MnX10, __MxX10, __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>::   max_exponent  ;  
template <class __Num, int __Dig, int __Dig10, int __MnX, int __MxX, int __MnX10, int __MxX10, unsigned int __Inf, unsigned int __QNaN, unsigned int __SNaN, bool __IsIEEE, float_round_style __Sty> const  int  _Floating_limits<__Num, __Dig, __Dig10, __MnX, __MxX, __MnX10, __MxX10, __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>::   min_exponent10  ;  
template <class __Num, int __Dig, int __Dig10, int __MnX, int __MxX, int __MnX10, int __MxX10, unsigned int __Inf, unsigned int __QNaN, unsigned int __SNaN, bool __IsIEEE, float_round_style __Sty> const  int  _Floating_limits<__Num, __Dig, __Dig10, __MnX, __MxX, __MnX10, __MxX10, __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>::   max_exponent10  ;  
template <class __Num, int __Dig, int __Dig10, int __MnX, int __MxX, int __MnX10, int __MxX10, unsigned int __Inf, unsigned int __QNaN, unsigned int __SNaN, bool __IsIEEE, float_round_style __Sty> const  bool  _Floating_limits<__Num, __Dig, __Dig10, __MnX, __MxX, __MnX10, __MxX10, __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>::   has_infinity  ;
template <class __Num, int __Dig, int __Dig10, int __MnX, int __MxX, int __MnX10, int __MxX10, unsigned int __Inf, unsigned int __QNaN, unsigned int __SNaN, bool __IsIEEE, float_round_style __Sty> const  bool  _Floating_limits<__Num, __Dig, __Dig10, __MnX, __MxX, __MnX10, __MxX10, __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>::   has_quiet_NaN  ;
template <class __Num, int __Dig, int __Dig10, int __MnX, int __MxX, int __MnX10, int __MxX10, unsigned int __Inf, unsigned int __QNaN, unsigned int __SNaN, bool __IsIEEE, float_round_style __Sty> const  bool  _Floating_limits<__Num, __Dig, __Dig10, __MnX, __MxX, __MnX10, __MxX10, __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>::   has_signaling_NaN  ;
template <class __Num, int __Dig, int __Dig10, int __MnX, int __MxX, int __MnX10, int __MxX10, unsigned int __Inf, unsigned int __QNaN, unsigned int __SNaN, bool __IsIEEE, float_round_style __Sty> const  float_denorm_style  _Floating_limits<__Num, __Dig, __Dig10, __MnX, __MxX, __MnX10, __MxX10, __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>::   has_denorm  ;
template <class __Num, int __Dig, int __Dig10, int __MnX, int __MxX, int __MnX10, int __MxX10, unsigned int __Inf, unsigned int __QNaN, unsigned int __SNaN, bool __IsIEEE, float_round_style __Sty> const  bool  _Floating_limits<__Num, __Dig, __Dig10, __MnX, __MxX, __MnX10, __MxX10, __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>::   has_denorm_loss  ;
template <class __Num, int __Dig, int __Dig10, int __MnX, int __MxX, int __MnX10, int __MxX10, unsigned int __Inf, unsigned int __QNaN, unsigned int __SNaN, bool __IsIEEE, float_round_style __Sty> const  bool  _Floating_limits<__Num, __Dig, __Dig10, __MnX, __MxX, __MnX10, __MxX10, __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>::   is_iec559  ;
template <class __Num, int __Dig, int __Dig10, int __MnX, int __MxX, int __MnX10, int __MxX10, unsigned int __Inf, unsigned int __QNaN, unsigned int __SNaN, bool __IsIEEE, float_round_style __Sty> const  bool  _Floating_limits<__Num, __Dig, __Dig10, __MnX, __MxX, __MnX10, __MxX10, __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>::   is_bounded  ;
template <class __Num, int __Dig, int __Dig10, int __MnX, int __MxX, int __MnX10, int __MxX10, unsigned int __Inf, unsigned int __QNaN, unsigned int __SNaN, bool __IsIEEE, float_round_style __Sty> const  bool  _Floating_limits<__Num, __Dig, __Dig10, __MnX, __MxX, __MnX10, __MxX10, __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>::   traps  ;
template <class __Num, int __Dig, int __Dig10, int __MnX, int __MxX, int __MnX10, int __MxX10, unsigned int __Inf, unsigned int __QNaN, unsigned int __SNaN, bool __IsIEEE, float_round_style __Sty> const  bool  _Floating_limits<__Num, __Dig, __Dig10, __MnX, __MxX, __MnX10, __MxX10, __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>::   tinyness_before  ;
template <class __Num, int __Dig, int __Dig10, int __MnX, int __MxX, int __MnX10, int __MxX10, unsigned int __Inf, unsigned int __QNaN, unsigned int __SNaN, bool __IsIEEE, float_round_style __Sty> const  float_round_style  _Floating_limits<__Num, __Dig, __Dig10, __MnX, __MxX, __MnX10, __MxX10, __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>::   round_style  ;



 

 

template<class T> 
class numeric_limits : public _Numeric_limits_base<T> {};

 



template<>
class numeric_limits<bool>
  : public _Integer_limits<bool, false, true, 0>
{};



template<>
class numeric_limits<char>
  : public _Integer_limits<char, 0 , 255 >
{};

template<>
class numeric_limits<signed char>
  : public _Integer_limits<signed char, (-128) , 127 >
{};

template<>
class numeric_limits<unsigned char>
  : public _Integer_limits<unsigned char, 0, 255 >
{};










template<>
class numeric_limits<short>
  : public _Integer_limits<short, (-32767-1) , 32767 >
{};

template<>
class numeric_limits<unsigned short>
  : public _Integer_limits<unsigned short, 0, 65535 >
{};

template<>
class numeric_limits<int>
  : public _Integer_limits<int, (- 2147483647  -1) , 2147483647  >
{};

template<>
class numeric_limits<unsigned int>
  : public _Integer_limits<unsigned int, 0, (2147483647   * 2U + 1) >
{};

template<>
class numeric_limits<long>
  : public _Integer_limits<long, (- 2147483647L  -1) , 2147483647L  >
{};

template<>
class numeric_limits<unsigned long>
  : public _Integer_limits<unsigned long, 0, (2147483647L   * 2UL + 1) >
{};

# 343 "../blitz/limits-hack.h"


 

template<> class numeric_limits<float>
  : public _Floating_limits<float, 
                            24 ,    
                            6 ,         
                            (-125) ,     
                            128 ,     
                            (-37) ,  
                            38 ,  
                            0x7f800000u,     
                            0x7f810000u,     
                            0x7fc10000u,     
                            true,            
                            round_to_nearest>
{
public:
  static float min()  { return 1.17549435e-38F ; }
  static float denorm_min()  { return 1.17549435e-38F ; }
  static float max()  { return 3.40282347e+38F ; }
  static float epsilon()  { return 1.19209290e-07F ; }
  static float round_error()  { return 0.5f; }  
};

template<> class numeric_limits<double>
  : public _Floating_limits<double, 
                            53 ,    
                            15 ,         
                            (-1021) ,     
                            1024 ,     
                            (-307) ,  
                            308 ,  
                            0x7ff00000u,     
                            0x7ff10000u,     
                            0x7ff90000u,     
                            true,            
                            round_to_nearest>
{
public:
  static double min()  { return 2.2250738585072014e-308 ; }
  static double denorm_min()  { return 2.2250738585072014e-308 ; }
  static double max()  { return 1.7976931348623157e+308 ; }
  static double epsilon()  { return 2.2204460492503131e-16 ; }
  static double round_error()  { return 0.5; }  
};

template<> class numeric_limits<long double>
  : public _Floating_limits<long double, 
                            53 ,   
                            15 ,        
                            (-1021) ,    
                            1024 ,    
                            (-307) , 
                            308 , 
                            0x7ff00000u,     
                            0x7ff10000u,     
                            0x7ff90000u,     
                            false,           
                            round_to_nearest>
{
public:
  static long double min()  { return 2.2250738585072014e-308L ; }
  static long double denorm_min()  { return 2.2250738585072014e-308L ; }
  static long double max()  { return 1.7976931348623157e+308L ; }
  static long double epsilon()  { return 2.2204460492503131e-16L ; }
  static long double round_error()  { return 4; }  
};

} 

# 51 "../blitz/numinquire.h" 2









namespace  blitz  { 

 






template<class T_numtype>
struct _bz_OneZeroTraits {
    static inline T_numtype zero() { return 0; }
    static inline T_numtype one()  { return 1; }
};



template<>
struct _bz_OneZeroTraits<complex<float> > {
    static inline complex<float> zero() { return complex<float>(0.0f,0.0f); }
    static inline complex<float> one()  { return complex<float>(1.0f,0.0f); }
};

template<>
struct _bz_OneZeroTraits<complex<double> > {
    static inline complex<double> zero() { return complex<double>(0.0,0.0); }
    static inline complex<double> one()  { return complex<double>(1.0,0.0); }
};

template<>
struct _bz_OneZeroTraits<complex<long double> > {
    static inline complex<long double> zero() 
    { return complex<long double>(0.0,0.0); }

    static inline complex<long double> one()  
    { return complex<long double>(1.0,0.0); }
};



template<class T>
inline T zero(T)
{
    return _bz_OneZeroTraits<T>::zero();
}

template<class T>
inline T one(T)
{
    return _bz_OneZeroTraits<T>::one();
}

template<class T>
inline int digits(T)
{
    return numeric_limits<T>::digits;
}

template<class T>
inline int digits10(T)
{
    return numeric_limits<T>::digits10;
}

template<class T>
inline T epsilon(T)  
{
    return numeric_limits<T>::epsilon();
}

template<class T>
inline T huge(T)  
{
    return numeric_limits<T>::max();
}

template<class T>
inline T tiny(T)  
{
    return numeric_limits<T>::min();
}

template<class T>
inline int max_exponent(T)
{
    return numeric_limits<T>::max_exponent;
}

template<class T>
inline int min_exponent(T)
{
    return numeric_limits<T>::min_exponent;
}

template<class T>
inline int min_exponent10(T)
{
    return numeric_limits<T>::min_exponent10;
}

template<class T>
inline int max_exponent10(T)
{
    return numeric_limits<T>::max_exponent10;
}

template<class T>
inline int precision(T)
{
    return numeric_limits<T>::digits10;
}

template<class T>
inline int radix(T)
{
    return numeric_limits<T>::radix;
}

template<class T>
inline Range range(T)
{
    return Range(numeric_limits<T>::min_exponent10, 
        numeric_limits<T>::max_exponent10);
}

template<class T>
inline bool is_signed(T)
{
    return numeric_limits<T>::is_signed;
}

template<class T>
inline bool is_integer(T)
{
    return numeric_limits<T>::is_integer;
}

template<class T>
inline bool is_exact(T)
{
    return numeric_limits<T>::is_exact;
}

template<class T>
inline T round_error(T)  
{
    return numeric_limits<T>::round_error();
}

template<class T>
inline bool has_infinity(T) 
{
    return numeric_limits<T>::has_infinity;
}

template<class T>
inline bool has_quiet_NaN(T)
{
    return numeric_limits<T>::has_quiet_NaN;
}

template<class T>
inline bool has_signaling_NaN(T)
{
    return numeric_limits<T>::has_signaling_NaN;
}

 
template<class T>
inline bool has_signalling_NaN(T)
{
    return numeric_limits<T>::has_signaling_NaN;
}

template<class T>
inline bool has_denorm(T)
{
    return numeric_limits<T>::has_denorm;
}

template<class T>
inline bool has_denorm_loss(T)
{
    return numeric_limits<T>::has_denorm_loss;
}

template<class T>
inline T infinity(T)  
{
    return numeric_limits<T>::infinity();
}

template<class T>
inline T quiet_NaN(T)  
{
    return numeric_limits<T>::quiet_NaN();
}

template<class T>
inline T signaling_NaN(T)  
{
    return numeric_limits<T>::signaling_NaN();
}

template<class T>
inline T signalling_NaN(T)  
{
    return numeric_limits<T>::signaling_NaN();
}

template<class T>
inline T denorm_min(T)  
{
    return numeric_limits<T>::denorm_min();
}

template<class T>
inline bool is_iec559(T)
{
    return numeric_limits<T>::is_iec559;
}

template<class T>
inline bool is_bounded(T)
{
    return numeric_limits<T>::is_bounded;
}

template<class T>
inline bool is_modulo(T)
{
    return numeric_limits<T>::is_modulo;
}

template<class T>
inline bool traps(T)
{
    return numeric_limits<T>::traps;
}

template<class T>
inline bool tinyness_before(T)
{
    return numeric_limits<T>::tinyness_before;
}

template<class T>
inline std::float_round_style round_style(T)
{
    return numeric_limits<T>::round_style;
}

} 



# 54 "../blitz/array/expr.h" 2



 













namespace  blitz  { 

template<class T1, class T2>
class _bz_ExprPair {
public:
    _bz_ExprPair(const T1& a, const T2& b)
        : first_(a), second_(b)
    { }

    const T1& first() const
    { return first_; }

    const T2& second() const
    { return second_; }

protected:
    T1 first_;
    T2 second_;
};

template<class T1, class T2>
inline _bz_ExprPair<T1,T2> makeExprPair(const T1& a, const T2& b)
{
    return _bz_ExprPair<T1,T2>(a,b);
}

template<class P_expr>
class _bz_ArrayExpr 

    : public ETBase<_bz_ArrayExpr<P_expr> >

{

public:
    typedef P_expr T_expr;
    typedef typename  T_expr::T_numtype T_numtype;
    typedef T_expr T_ctorArg1;
    typedef int    T_ctorArg2;     

    enum { numArrayOperands = (int) P_expr::numArrayOperands  ,
        numIndexPlaceholders = (int) P_expr::numIndexPlaceholders  ,
        rank = (int) P_expr::rank   };

    _bz_ArrayExpr(const _bz_ArrayExpr<P_expr>& a)
        : iter_(a.iter_)
    { }


    template<class T>
    _bz_ArrayExpr(const T& a)
        : iter_(a)
    { }
# 132 "../blitz/array/expr.h"


    template<class T1, class T2>
    _bz_ArrayExpr(const  T1 &  a, const  T2 &  b)
        : iter_(a, b)
    { }

    template<class T1, class T2, class T3>
    _bz_ArrayExpr(const  T1 &  a, const  T2 &  b, const  T3 &  c)
        : iter_(a, b, c)
    { }

    template<class T1, class T2>
    _bz_ArrayExpr(const _bz_ExprPair<T1,T2>& pair)
        : iter_(pair.first(), pair.second())
    { }

    T_numtype operator*()
    { return *iter_; }






    template<int N_rank>
    T_numtype operator()(const TinyVector<int, N_rank>& i)
    { return iter_(i); }


    int lbound(int rank)
    { return iter_.lbound(rank); }

    int ubound(int rank)
    { return iter_.ubound(rank); }

    void push(int position)
    { iter_.push(position); }

    void pop(int position)
    { iter_.pop(position); }

    void advance()
    { iter_.advance(); }

    void advance(int n)
    { iter_.advance(n); }

    void loadStride(int rank)
    { iter_.loadStride(rank); }

    bool  isUnitStride(int rank) const
    { return iter_.isUnitStride(rank); }

    void advanceUnitStride()
    { iter_.advanceUnitStride(); }

    bool  canCollapse(int outerLoopRank, int innerLoopRank) const
    { 
         
        return iter_.canCollapse(outerLoopRank, innerLoopRank); 
    }

    T_numtype operator[](int i)
    { return iter_[i]; }

    T_numtype fastRead(int i)
    { return iter_.fastRead(i); }

    int suggestStride(int rank) const
    { return iter_.suggestStride(rank); }

    bool  isStride(int rank, int stride) const
    { return iter_.isStride(rank,stride); }

    void prettyPrint(string& str) const
    {
        prettyPrintFormat format(true );   
        iter_.prettyPrint(str, format);
    }

    void prettyPrint(string& str, prettyPrintFormat& format) const
    { iter_.prettyPrint(str, format); }

    template<class T_shape>
    bool  shapeCheck(const T_shape& shape)
    { return iter_.shapeCheck(shape); }

    template<int N_rank>
    void moveTo(const TinyVector<int,N_rank>& i)
    {
        iter_.moveTo(i);
    }

protected:
    _bz_ArrayExpr() { }

    T_expr iter_;
};

struct bounds {
    static int compute_lbound(int rank, int lbound1, int lbound2)
    {
         
         
         
         

        if (lbound1 == lbound2)
            return lbound1;
        else if (lbound1 == (- 2147483647  -1) )
            return lbound2;
        else if (lbound2 == (- 2147483647  -1) )
            return lbound1;

         ;


         ;
        return 0;
    }

    static int compute_ubound(int rank, int ubound1, int ubound2)
    {
         
         
         
         

        if (ubound1 == ubound2)
            return ubound1;
        else if (ubound1 == 2147483647  )
            return ubound2;
        else if (ubound2 == 2147483647  )
            return ubound1;

         ;


         ;
        return 0;
    }

};

template<class P_expr1, class P_expr2, class P_op>
class _bz_ArrayExprOp {
public:
    typedef P_expr1 T_expr1;
    typedef P_expr2 T_expr2;
    typedef typename  T_expr1::T_numtype T_numtype1;
    typedef typename  T_expr2::T_numtype T_numtype2;
    typedef typename  P_op::T_numtype T_numtype;
    typedef P_op T_op;
    typedef T_expr1 T_ctorArg1;
    typedef T_expr2 T_ctorArg2;

    enum { numArrayOperands = (int) P_expr1::numArrayOperands  
                            + (int) P_expr2::numArrayOperands  ,
           numIndexPlaceholders = (int) P_expr1::numIndexPlaceholders  
                            + (int) P_expr2::numIndexPlaceholders  ,
           rank = ((int) P_expr1::rank   > (int) P_expr2::rank  ) 
                ? (int) P_expr1::rank   : (int) P_expr2::rank  
    };

    _bz_ArrayExprOp(const _bz_ArrayExprOp<P_expr1, P_expr2, P_op>& a)
        : iter1_(a.iter1_), iter2_(a.iter2_)
    { }

    template<class T1, class T2>
    _bz_ArrayExprOp(const  T1 &  a, const  T2 &  b)
        : iter1_(a), iter2_(b)
    { }

 
 
 

    T_numtype operator*()
    { return T_op::apply(*iter1_, *iter2_); }






    template<int N_rank>
    T_numtype operator()(const TinyVector<int, N_rank>& i)
    { return T_op::apply(iter1_(i), iter2_(i)); }


    int lbound(int rank)
    { 
        return bounds::compute_lbound(rank, iter1_.lbound(rank),
            iter2_.lbound(rank));
    }

    int ubound(int rank)
    {
        return bounds::compute_ubound(rank, iter1_.ubound(rank),
            iter2_.ubound(rank));
    }

    void push(int position)
    { 
        iter1_.push(position); 
        iter2_.push(position);
    }

    void pop(int position)
    { 
        iter1_.pop(position); 
        iter2_.pop(position);
    }

    void advance()
    { 
        iter1_.advance(); 
        iter2_.advance();
    }

    void advance(int n)
    {
        iter1_.advance(n);
        iter2_.advance(n);
    }

    void loadStride(int rank)
    { 
        iter1_.loadStride(rank); 
        iter2_.loadStride(rank);
    }
    
    bool  isUnitStride(int rank) const
    { return iter1_.isUnitStride(rank) && iter2_.isUnitStride(rank); }

    void advanceUnitStride()
    { 
        iter1_.advanceUnitStride(); 
        iter2_.advanceUnitStride();
    }

    bool  canCollapse(int outerLoopRank, int innerLoopRank) const
    { 
         
        return iter1_.canCollapse(outerLoopRank, innerLoopRank)
            && iter2_.canCollapse(outerLoopRank, innerLoopRank);
    } 

    T_numtype operator[](int i)
    { return T_op::apply(iter1_[i], iter2_[i]); }

    T_numtype fastRead(int i)
    { return T_op::apply(iter1_.fastRead(i), iter2_.fastRead(i)); }

    int suggestStride(int rank) const
    {
        int stride1 = iter1_.suggestStride(rank);
        int stride2 = iter2_.suggestStride(rank);
        return (stride1 > stride2) ? stride1 : stride2;
    }

    bool  isStride(int rank, int stride) const
    {
        return iter1_.isStride(rank,stride) && iter2_.isStride(rank,stride);
    }

    template<int N_rank>
    void moveTo(const TinyVector<int,N_rank>& i)
    {
        iter1_.moveTo(i);
        iter2_.moveTo(i);
    }

    void prettyPrint(string& str, prettyPrintFormat& format) const
    {
        T_op::prettyPrint(str, format, iter1_, iter2_);
    }

    template<class T_shape>
    bool  shapeCheck(const T_shape& shape)
    { return iter1_.shapeCheck(shape) && iter2_.shapeCheck(shape); }

protected:
    _bz_ArrayExprOp() { }

    T_expr1 iter1_;
    T_expr2 iter2_; 
};

template<class P_expr, class P_op>
class _bz_ArrayExprUnaryOp {
public:
    typedef P_expr T_expr;
    typedef typename  P_expr::T_numtype T_numtype1;
    typedef typename  P_op::T_numtype T_numtype;
    typedef P_op T_op;
    typedef T_expr T_ctorArg1;
    typedef int    T_ctorArg2;     

    enum { numArrayOperands = (int) T_expr::numArrayOperands  ,
        numIndexPlaceholders = (int) T_expr::numIndexPlaceholders  ,
        rank = (int) T_expr::rank   };

    _bz_ArrayExprUnaryOp(const _bz_ArrayExprUnaryOp<T_expr, P_op>& a)
        : iter_(a.iter_)
    { }

    _bz_ArrayExprUnaryOp(const  T_expr &  a)
        : iter_(a)
    { }

    _bz_ArrayExprUnaryOp(typename  T_expr::T_ctorArg1 a)
        : iter_(a)
    { }








    int lbound(int rank)
    { return iter_.lbound(rank); }

    int ubound(int rank)
    { return iter_.ubound(rank); }

    T_numtype operator*()
    { return T_op::apply(*iter_); }






    template<int N_rank>
    T_numtype operator()(const TinyVector<int, N_rank>& i)
    { return T_op::apply(iter_(i)); }


    void push(int position)
    {
        iter_.push(position);
    }

    void pop(int position)
    {
        iter_.pop(position);
    }

    void advance()
    {
        iter_.advance();
    }

    void advance(int n)
    {
        iter_.advance(n);
    }

    void loadStride(int rank)
    {
        iter_.loadStride(rank);
    }

    bool  isUnitStride(int rank) const
    { return iter_.isUnitStride(rank); }

    void advanceUnitStride()
    {
        iter_.advanceUnitStride();
    }

    template<int N_rank>
    void moveTo(const TinyVector<int,N_rank>& i)
    {
        iter_.moveTo(i);
    }

    bool  canCollapse(int outerLoopRank, int innerLoopRank) const
    { 
         
        return iter_.canCollapse(outerLoopRank, innerLoopRank); 
    }

    T_numtype operator[](int i)
    { return T_op::apply(iter_[i]); }

    T_numtype fastRead(int i)
    { return T_op::apply(iter_.fastRead(i)); }

    int suggestStride(int rank) const
    { return iter_.suggestStride(rank); }

    bool  isStride(int rank, int stride) const
    { return iter_.isStride(rank,stride); }

    void prettyPrint(string& str, prettyPrintFormat& format) const
    { T_op::prettyPrint(str, format, iter_); }

    template<class T_shape>
    bool  shapeCheck(const T_shape& shape)
    { return iter_.shapeCheck(shape); }

protected:
    _bz_ArrayExprUnaryOp() { }

    T_expr iter_;
};

template<class P_numtype>
class _bz_ArrayExprConstant {
public:
    typedef P_numtype T_numtype;
    typedef T_numtype T_ctorArg1;
    typedef int       T_ctorArg2;     

    enum { numArrayOperands = 0, numIndexPlaceholders = 0, rank = 0 };

    _bz_ArrayExprConstant(const _bz_ArrayExprConstant<T_numtype>& a)
        : value_(a.value_)
    { }

    _bz_ArrayExprConstant(T_numtype value)
        : value_( value  )
    { 
    }

     
     
     
     
    int lbound(int)
    { return (- 2147483647  -1) ; }

    int ubound(int)
    { return 2147483647  ; }
     
     

    T_numtype operator*()
    { return value_; }






    template<int N_rank>
    T_numtype operator()(const TinyVector<int,N_rank>&)
    { return value_; }


    void push(int) { }
    void pop(int) { }
    void advance() { }
    void advance(int) { }
    void loadStride(int) { }

    bool  isUnitStride(int rank) const
    { return true ; }

    void advanceUnitStride()
    { }

    bool  canCollapse(int,int) const 
    { return true ; }

    T_numtype operator[](int)
    { return value_; }

    T_numtype fastRead(int)
    { return value_; }

    int suggestStride(int) const
    { return 1; }

    bool  isStride(int,int) const
    { return true ; }

    template<int N_rank>
    void moveTo(const TinyVector<int,N_rank>& i)
    {
    }

    void prettyPrint(string& str, prettyPrintFormat& format) const
    {
        if (format.tersePrintingSelected())
            str += format.nextScalarOperandSymbol();
        else
            str += typeid( T_numtype ).name() ;
    }

    template<class T_shape>
    bool  shapeCheck(const T_shape&)
    { return true ; }

protected:
    _bz_ArrayExprConstant() { }

    T_numtype value_;
};

} 

# 1 "../blitz/array/asexpr.h" 1







namespace  blitz  { 

 
 

 
template<class T>
struct asExpr {
    typedef _bz_ArrayExprConstant<T> T_expr;
};

 
template<class T>
struct asExpr<_bz_ArrayExpr<T> > {
    typedef _bz_ArrayExpr<T> T_expr;
};

 
template<class T, int N>
struct asExpr<Array<T,N> > {
    typedef FastArrayIterator<T,N> T_expr;
};

 
template<int N>
struct asExpr<IndexPlaceholder<N> > {
    typedef IndexPlaceholder<N> T_expr;
};

} 


# 639 "../blitz/array/expr.h" 2




# 2460 "../blitz/array.h" 2

# 1 "../blitz/array/methods.cc" 1
 






















namespace  blitz  { 

template<class P_numtype, int N_rank> template<class T_expr>
Array<P_numtype,N_rank>::Array(_bz_ArrayExpr<T_expr> expr)
{
     

    TinyVector<int,N_rank> lbound, extent;
    for (int i=0; i < N_rank; ++i)
    {
        lbound(i) = expr.lbound(i);
        int ubound = expr.ubound(i);
        extent(i) = ubound - lbound(i) + 1;

# 48 "../blitz/array/methods.cc"

    }

     
     

    Array<P_numtype,N_rank> A(lbound,extent);
    A = expr;
    reference(A);
}

template<class T_numtype, int N_rank>
Array<T_numtype,N_rank>::Array(const TinyVector<int, N_rank>& lbounds,
    const TinyVector<int, N_rank>& extent,
    const GeneralArrayStorage<N_rank>& storage)
    : storage_(storage)
{
    length_ = extent;
    storage_.setBase(lbounds);
    setupStorage(N_rank - 1);
}


 





template<class P_numtype, int N_rank>
inline  void Array<P_numtype, N_rank>::computeStrides()
{
    if (N_rank > 1)
    {
      int stride = 1;

       
       
      bool  allAscending = storage_.allRanksStoredAscending();

       
      int n;
      for (n=0; n < N_rank; ++n)
      {
          int strideSign = +1;

           
           
          if (!allAscending)
          {
            if (!isRankStoredAscending(ordering(n)))
                strideSign = -1;
          }

           
           
          stride_[ordering(n)] = stride * strideSign;

          stride *= length_[ordering(n)];
      }
    }
    else {
         
         
         

        if (isRankStoredAscending(0))
            stride_[0] = 1;
        else
            stride_[0] = -1;
    }

    calculateZeroOffset();
}

template<class T_numtype, int N_rank>
void Array<T_numtype, N_rank>::calculateZeroOffset()
{
     
    zeroOffset_ = 0;

     
     
    for (int n=0; n < N_rank; ++n)
    {
        if (!isRankStoredAscending(n))
            zeroOffset_ -= (length_[n] - 1 + base(n)) * stride_[n];
        else
            zeroOffset_ -= stride_[n] * base(n);
    }
}

template<class T_numtype, int N_rank>
bool  Array<T_numtype, N_rank>::isStorageContiguous() const
{
     
     
     
     

     
     

    int numStridesMissing = 0;
    bool haveUnitStride = false ;

    for (int i=0; i < N_rank; ++i)
    {
        int stride = std:: abs  (stride_[i]);
        if (stride == 1)
            haveUnitStride = true ;

        int vi = stride * length_[i];

        int j = 0;
        for (j=0; j < N_rank; ++j)
            if (std:: abs  (stride_[j]) == vi)
                break;

        if (j == N_rank)
        {
            ++numStridesMissing;
            if (numStridesMissing == 2)
                return false ;
        }
    }

    return haveUnitStride;
}

template<class P_numtype, int N_rank>
void Array<P_numtype, N_rank>::dumpStructureInformation(ostream& os) const
{
    os << "Dump of Array<" << typeid( P_numtype ).name()  
       << ", " << N_rank << ">:" << endl
       << "ordering_      = " << storage_.ordering() << endl
       << "ascendingFlag_ = " << storage_.ascendingFlag() << endl
       << "base_          = " << storage_.base() << endl
       << "length_        = " << length_ << endl
       << "stride_        = " << stride_ << endl
       << "zeroOffset_    = " << zeroOffset_ << endl
       << "numElements()  = " << numElements() << endl
       << "isStorageContiguous() = " << isStorageContiguous() << endl;
}

 


template<class P_numtype, int N_rank>
void Array<P_numtype, N_rank>::reference(const Array<P_numtype, N_rank>& array)
{
    storage_ = array.storage_;
    length_ = array.length_;
    stride_ = array.stride_;
    zeroOffset_ = array.zeroOffset_;

    MemoryBlockReference<P_numtype>::changeBlock(array.noConst(),
        array.zeroOffset_);

    data_ = const_cast<P_numtype*>(array.data_);
}

 


template<class P_numtype, int N_rank>
inline  void Array<P_numtype, N_rank>::setupStorage(int lastRankInitialized)
{
     ;

     ;

     





    for (int i=lastRankInitialized + 1; i < N_rank; ++i)
    {
        storage_.setBase(i, storage_.base(lastRankInitialized));
        length_[i] = length_[lastRankInitialized];
    }

     
    computeStrides();

     
    MemoryBlockReference<P_numtype>::newBlock(numElements());

     
     
    data_ += zeroOffset_;
}

template<class T_numtype, int N_rank>
Array<T_numtype, N_rank> Array<T_numtype, N_rank>::copy() const
{
    if (numElements())
    {
        Array<T_numtype, N_rank> z(length_, storage_);
        z = *this;
        return z;
    }
    else {
         
        return *this;
    }
}

template<class T_numtype, int N_rank>
void Array<T_numtype, N_rank>::makeUnique()
{
    if (numReferences() > 1)
    {
        T_array tmp = copy();
        reference(tmp);
    }
}

template<class T_numtype, int N_rank>
Array<T_numtype, N_rank> Array<T_numtype, N_rank>::transpose(int r0, int r1, 
    int r2, int r3, int r4, int r5, int r6, int r7, int r8, int r9, int r10)
{
    T_array B(*this);
    B.transposeSelf(r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10);
    return B;
}

template<class T_numtype, int N_rank>
void Array<T_numtype, N_rank>::transposeSelf(int r0, int r1, int r2, int r3,
    int r4, int r5, int r6, int r7, int r8, int r9, int r10)
{
     ;




     
    Array<T_numtype, N_rank> x(*this);

     
    doTranspose(0, r0, x);
    doTranspose(1, r1, x);
    doTranspose(2, r2, x);
    doTranspose(3, r3, x);
    doTranspose(4, r4, x);
    doTranspose(5, r5, x);
    doTranspose(6, r6, x);
    doTranspose(7, r7, x);
    doTranspose(8, r8, x);
    doTranspose(9, r9, x);
    doTranspose(10, r10, x);
}

template<class T_numtype, int N_rank>
void Array<T_numtype, N_rank>::doTranspose(int destRank, int sourceRank,
    Array<T_numtype, N_rank>& array)
{
     

    if (destRank >= N_rank)
        return;

    length_[destRank] = array.length_[sourceRank];
    stride_[destRank] = array.stride_[sourceRank];
    storage_.setAscendingFlag(destRank, 
        array.isRankStoredAscending(sourceRank));
    storage_.setBase(destRank, array.base(sourceRank));

     
     
     

     
    int i=0;
    for (; i < N_rank; ++i)
        if (array.storage_.ordering(i) == sourceRank)
            break;

    storage_.setOrdering(i, destRank);
}

template<class T_numtype, int N_rank>
void Array<T_numtype, N_rank>::reverseSelf(int rank)
{
     ;

    storage_.setAscendingFlag(rank, !isRankStoredAscending(rank));

    int adjustment = stride_[rank] * (lbound(rank) + ubound(rank));
    zeroOffset_ += adjustment;
    data_ += adjustment;
    stride_[rank] *= -1;
}

template<class T_numtype, int N_rank>
Array<T_numtype, N_rank> Array<T_numtype,N_rank>::reverse(int rank)
{
    T_array B(*this);
    B.reverseSelf(rank);
    return B;
}

template<class T_numtype, int N_rank> template<class T_numtype2>
Array<T_numtype2,N_rank> Array<T_numtype,N_rank>::extractComponent(T_numtype2, 
    int componentNumber, int numComponents) const
{
     ;


    TinyVector<int,N_rank> stride2;
    stride2 = stride_ * numComponents;
    const T_numtype2* dataFirst2 = 
        ((const T_numtype2*)dataFirst()) + componentNumber;
    return Array<T_numtype2,N_rank>(const_cast<T_numtype2*>(dataFirst2), 
        length_, stride2, storage_);
}

 





template<class P_numtype, int N_rank>
inline  void Array<P_numtype, N_rank>::reindexSelf(const 
    TinyVector<int, N_rank>& newBase) 
{
    data_ += dot(base() - newBase, stride_);
    storage_.setBase(newBase);
    calculateZeroOffset();
}

template<class P_numtype, int N_rank>
inline  Array<P_numtype, N_rank> 
Array<P_numtype, N_rank>::reindex(const TinyVector<int, N_rank>& newBase) 
{
    T_array B(*this);
    B.reindexSelf(newBase);
    return B;
}

} 



# 2461 "../blitz/array.h" 2

# 1 "../blitz/array/eval.cc" 1
 


















namespace  blitz  { 

 

























 


template< bool  canTryFastTraversal>
struct _bz_tryFastTraversal {
    template<class T_numtype, int N_rank, class T_expr, class T_update>
    static bool  tryFast(Array<T_numtype,N_rank>& array, 
        const  T_expr &  expr, T_update)
    {
        return false ;
    }
};

template<>
struct _bz_tryFastTraversal< true > {
    template<class T_numtype, int N_rank, class T_expr, class T_update>
    static bool  tryFast(Array<T_numtype,N_rank>& array, 
        const  T_expr &  expr, T_update)
    {
         
         
         
         
        TraversalOrderCollection<N_rank-1> traversals;
        TinyVector<int, N_rank - 1> traversalGridSize;

        for (int i=0; i < N_rank - 1; ++i)
            traversalGridSize[i] = array.length(array.ordering(i+1));






        const TraversalOrder<N_rank-1>* order =
            traversals.find(traversalGridSize);

        if (order)
        {




             
            array.evaluateWithFastTraversal(*order, expr, T_update());
            return true ;
        }

        return false ;
    }
};



template<class T_numtype, int N_rank> template<class T_expr, class T_update>
inline Array<T_numtype, N_rank>& 
Array<T_numtype, N_rank>::evaluate(T_expr expr, 
    T_update)
{
     
# 132 "../blitz/array/eval.cc"


     ;


     ;



     






    if (numElements() == 0)
        return *this;






     
     
     

# 171 "../blitz/array/eval.cc"


     
    if (T_expr::numIndexPlaceholders > 0)
    {
         
         

        if (N_rank == 1)
            return evaluateWithIndexTraversal1(expr, T_update());
        else
            return evaluateWithIndexTraversalN(expr, T_update());
    }
    else {

         
         
         
         



        enum { isStencil = (N_rank >= 3) && (T_expr::numArrayOperands > 6)
            && (T_expr::numIndexPlaceholders == 0) };

        if (_bz_tryFastTraversal<isStencil>::tryFast(*this, expr, T_update()))
            return *this;




         
         

        if ((N_rank == 2) && (T_expr::numArrayOperands >= 5))
        {
             
             
             
             
             

             
             
             
             
            
            int cacheNeeded = 3 * 3 * sizeof(T_numtype) * length(ordering(0));
            if (cacheNeeded > 8192 )
                return evaluateWithTiled2DTraversal(expr, T_update());
        }



         
         
        if (N_rank == 1)
            return evaluateWithStackTraversal1(expr, T_update());
        else
            return evaluateWithStackTraversalN(expr, T_update());
    }
}

template<class T_numtype, int N_rank> template<class T_expr, class T_update>
inline Array<T_numtype, N_rank>&
Array<T_numtype, N_rank>::evaluateWithStackTraversal1(
    T_expr expr, T_update)
{




    FastArrayIterator<T_numtype, N_rank> iter(*this);
    iter.loadStride(firstRank);
    expr.loadStride(firstRank);

    bool  useUnitStride = iter.isUnitStride(firstRank)
          && expr.isUnitStride(firstRank);


    int commonStride = expr.suggestStride(firstRank);
    if (iter.suggestStride(firstRank) > commonStride)
        commonStride = iter.suggestStride(firstRank);
    bool useCommonStride = iter.isStride(firstRank,commonStride)
        && expr.isStride(firstRank,commonStride);

 









    const T_numtype * last = iter.data() + length(firstRank) 
        * stride(firstRank);

    if (useUnitStride || useCommonStride)
    {





        int ubound = length(firstRank) * commonStride;
        T_numtype*   data = const_cast<T_numtype*>(iter.data());

        if (commonStride == 1)
        {
 
            for (int i=0; i < ubound; ++i)
                T_update::update(data[i], expr.fastRead(i));
 
# 316 "../blitz/array/eval.cc"


        }
 
        else {

  
            for (int i=0; i < ubound; i += commonStride)
                T_update::update(data[i], expr.fastRead(i));
  
# 343 "../blitz/array/eval.cc"

        }
 

# 358 "../blitz/array/eval.cc"

    }
    else {
        while (iter.data() != last)
        {
            T_update::update(*const_cast<T_numtype*>(iter.data()), *expr);
            iter.advance();
            expr.advance();
        }
    }

    return *this;
}

template<class T_numtype, int N_rank> template<class T_expr, class T_update>
inline Array<T_numtype, N_rank>&
Array<T_numtype, N_rank>::evaluateWithStackTraversalN(
    T_expr expr, T_update)
{
     






















     












    const int maxRank = ordering(0);
    const int secondLastRank = ordering(1);

     
    FastArrayIterator<T_numtype, N_rank> iter(*this);

     
     

    int i;
    for (i=1; i < N_rank; ++i)
    {
        iter.push(i);
        expr.push(i);
    }

     
    iter.loadStride(maxRank);
    expr.loadStride(maxRank);

     




    bool  useUnitStride = iter.isUnitStride(maxRank)
                          && expr.isUnitStride(maxRank);

     





    int commonStride = expr.suggestStride(maxRank);
    if (iter.suggestStride(maxRank) > commonStride)
        commonStride = iter.suggestStride(maxRank);
    bool useCommonStride = iter.isStride(maxRank,commonStride)
        && expr.isStride(maxRank,commonStride);












     



    const T_numtype* last[N_rank];

     
    for (i=1; i < N_rank; ++i)
        last[i] = iter.data() + length(ordering(i)) * stride(ordering(i));

    int lastLength = length(maxRank);
    int firstNoncollapsedLoop = 1;



     










     
    for (i=1; i < N_rank; ++i)
    {
         
        int outerLoopRank = ordering(i);
        int innerLoopRank = ordering(i-1);

         





        if (canCollapse(outerLoopRank,innerLoopRank) 
          && expr.canCollapse(outerLoopRank,innerLoopRank))
        {




            lastLength *= length(outerLoopRank);
            firstNoncollapsedLoop = i+1;
        }
 
 
    }


     







    while (true) {

         





        if ((useUnitStride) || (useCommonStride))
        {
            T_numtype *   end = const_cast<T_numtype*>(iter.data()) 
                + lastLength;



             






             
            int ubound = lastLength * commonStride;

             







            T_numtype*   data = const_cast<T_numtype*>(iter.data());

             


            if (commonStride == 1)
            {
                for (int i=0; i < ubound; ++i)
                    T_update::update(data[i], expr.fastRead(i));
            }

            else {
                for (int i=0; i < ubound; i += commonStride)
                    T_update::update(data[i], expr.fastRead(i));
            }

             




            iter.advance(lastLength * commonStride);
            expr.advance(lastLength * commonStride);
# 593 "../blitz/array/eval.cc"

        }
        else {
             




            T_numtype *   end = const_cast<T_numtype*>(iter.data())
                + lastLength * stride(maxRank);

            while (iter.data() != end)
            {
                T_update::update(*const_cast<T_numtype*>(iter.data()), *expr);
                iter.advance();
                expr.advance();
            }
        }


         


 
        int j = firstNoncollapsedLoop;
        for (; j < N_rank; ++j)
        {
             
            int r = ordering(j);

             
             
            iter.pop(j);
            expr.pop(j);

             
             
            iter.loadStride(r);
            expr.loadStride(r);
            iter.advance();
            expr.advance();

             
            if (iter.data() != last[j])
                break;
        }

         
        if (j == N_rank)
            break;

         
        for (; j >= firstNoncollapsedLoop; --j)
        {
            int r2 = ordering(j-1);
            iter.push(j);
            expr.push(j);
            last[j-1] = iter.data() + length(r2) * stride(r2);
        }

         
        iter.loadStride(maxRank);
        expr.loadStride(maxRank);
    }

    return *this;
}

template<class T_numtype, int N_rank> template<class T_expr, class T_update>
inline Array<T_numtype, N_rank>&
Array<T_numtype, N_rank>::evaluateWithIndexTraversal1(
    T_expr expr, T_update)
{
    TinyVector<int,N_rank> index;

    if (stride(firstRank) == 1)
    {
        T_numtype *   iter = data_;
        int last = ubound(firstRank);

        for (index[0] = lbound(firstRank); index[0] <= last;
            ++index[0])
        {
            iter[index[0]] = T_numtype(expr(index));
        }
    }
    else {
        FastArrayIterator<T_numtype, N_rank> iter(*this);
        iter.loadStride(0);
        int last = ubound(firstRank);

        for (index[0] = lbound(firstRank); index[0] <= last;
            ++index[0])
        {
            T_update::update(*const_cast<T_numtype*>(iter.data()), 
                expr(index));
            iter.advance();
        }
    }

    return *this;
}

template<class T_numtype, int N_rank> template<class T_expr, class T_update>
inline Array<T_numtype, N_rank>&
Array<T_numtype, N_rank>::evaluateWithIndexTraversalN(
    T_expr expr, T_update)
{
     
     
   
    const int maxRank = ordering(0);
    const int secondLastRank = ordering(1);








    FastArrayIterator<T_numtype, N_rank> iter(*this);
    for (int i=1; i < N_rank; ++i)
        iter.push(ordering(i));

    iter.loadStride(maxRank);

    TinyVector<int,N_rank> index, last;

    index = storage_.base();
    last = storage_.base() + length_;

    int lastLength = length(maxRank);

    while (true) {

        for (index[maxRank] = base(maxRank); 
             index[maxRank] < last[maxRank]; 
             ++index[maxRank])
        {







            T_update::update(*const_cast<T_numtype*>(iter.data()), expr(index));
            iter.advance();
        }

        int j = 1;
        for (; j < N_rank; ++j)
        {
            iter.pop(ordering(j));
            iter.loadStride(ordering(j));
            iter.advance();

            index[ordering(j-1)] = base(ordering(j-1));
            ++index[ordering(j)];
            if (index[ordering(j)] != last[ordering(j)])
                break;
        }

        if (j == N_rank)
            break;

        for (; j > 0; --j)
        {
            iter.push(ordering(j));
        }
        iter.loadStride(maxRank);
    }

    return *this; 
}

 



template<class T_numtype, int N_rank> template<class T_expr, class T_update>
inline Array<T_numtype, N_rank>&
Array<T_numtype, N_rank>::evaluateWithFastTraversal(
    const TraversalOrder<N_rank - 1>& order, 
    T_expr expr,
    T_update)
{
    const int maxRank = ordering(0);
    const int secondLastRank = ordering(1);






    FastArrayIterator<T_numtype, N_rank> iter(*this);
    iter.push(0);
    expr.push(0);

    bool  useUnitStride = iter.isUnitStride(maxRank) 
                          && expr.isUnitStride(maxRank);


    int commonStride = expr.suggestStride(maxRank);
    if (iter.suggestStride(maxRank) > commonStride)
        commonStride = iter.suggestStride(maxRank);
    bool useCommonStride = iter.isStride(maxRank,commonStride)
        && expr.isStride(maxRank,commonStride);





    int lastLength = length(maxRank);

    for (int i=0; i < order.length(); ++i)
    {
        iter.pop(0);
        expr.pop(0);




         
        for (int j=1; j < N_rank; ++j)
        {
            iter.loadStride(ordering(j));
            expr.loadStride(ordering(j));

            int offset = order[i][j-1];
            iter.advance(offset);
            expr.advance(offset);
        }

        iter.loadStride(maxRank);
        expr.loadStride(maxRank);

         

        if ((useUnitStride) || (useCommonStride))
        {
            T_numtype*   last = const_cast<T_numtype*>(iter.data()) 
                + lastLength * commonStride;


            int ubound = lastLength * commonStride;
            T_numtype*   data = const_cast<T_numtype*>(iter.data());

            if (commonStride == 1)
            {            
 
                for (int i=0; i < ubound; ++i)
                    T_update::update(data[i], expr.fastRead(i));
 
# 860 "../blitz/array/eval.cc"

            }
 
            else {
                for (int i=0; i < ubound; i += commonStride)
                    T_update::update(data[i], expr.fastRead(i));
            }
 

            iter.advance(lastLength * commonStride);
            expr.advance(lastLength * commonStride);









        }
        else {
             

            T_numtype*   last = const_cast<T_numtype*>(iter.data()) 
                + lastLength * stride(maxRank);

            while (iter.data() != last)
            {
                T_update::update(*const_cast<T_numtype*>(iter.data()), *expr);
                iter.advance();
                expr.advance();
            }
        }
    }

    return *this;
}


# 1095 "../blitz/array/eval.cc"








template<class T_numtype, int N_rank> template<class T_expr, class T_update>
inline Array<T_numtype, N_rank>& 
Array<T_numtype, N_rank>::evaluateWithTiled2DTraversal(
    T_expr expr, T_update)
{
    const int minorRank = ordering(0);
    const int majorRank = ordering(1);

    const int blockSize = 16;
    
    FastArrayIterator<T_numtype, N_rank> iter(*this);
    iter.push(0);
    expr.push(0);

    bool  useUnitStride = iter.isUnitStride(minorRank)
                          && expr.isUnitStride(minorRank);


    int commonStride = expr.suggestStride(minorRank);
    if (iter.suggestStride(minorRank) > commonStride)
        commonStride = iter.suggestStride(minorRank);
    bool useCommonStride = iter.isStride(minorRank,commonStride)
        && expr.isStride(minorRank,commonStride);





    int maxi = length(majorRank);
    int maxj = length(minorRank);

    int bi, bj;
    for (bi=0; bi < maxi; bi += blockSize)
    {
        int ni = bi + blockSize;
        if (ni > maxi)
            ni = maxi;

        for (bj=0; bj < maxj; bj += blockSize)
        {
            int nj = bj + blockSize;
            if (nj > maxj)
                nj = maxj;

             
            iter.pop(0);
            expr.pop(0);

             
            iter.loadStride(majorRank);
            iter.advance(bi);
            iter.loadStride(minorRank);
            iter.advance(bj);

            expr.loadStride(majorRank);
            expr.advance(bi);
            expr.loadStride(minorRank);
            expr.advance(bj);

             
            for (int i=bi; i < ni; ++i)
            {
                 
                iter.push(1);
                expr.push(1);

                 
                iter.loadStride(minorRank);
                expr.loadStride(minorRank);

                if (useUnitStride)
                {
                    T_numtype*   data = const_cast<T_numtype*>
                        (iter.data());

                    int ubound = (nj-bj);
                    for (int j=0; j < ubound; ++j)
                        T_update::update(data[j], expr.fastRead(j));
                }

                else if (useCommonStride)
                {
                    int ubound = (nj-bj) * commonStride;
                    T_numtype*   data = const_cast<T_numtype*>
                        (iter.data());

                    for (int j=0; j < ubound; j += commonStride)
                        T_update::update(data[j], expr.fastRead(j));
                }

                else {
                    for (int j=bj; j < nj; ++j)
                    {
                         
                        T_update::update(*const_cast<T_numtype*>(iter.data()), 
                            *expr);
                        iter.advance();
                        expr.advance();
                    }
                }

                 
                 
                iter.pop(1);
                iter.loadStride(majorRank);
                iter.advance(1);

                expr.pop(1);
                expr.loadStride(majorRank);
                expr.advance(1);
            }
        }
    }

    return *this;
}



} 



# 2462 "../blitz/array.h" 2

# 1 "../blitz/array/ops.cc" 1











namespace  blitz  { 

 



template<class T_numtype, int N_rank>
inline Array<T_numtype, N_rank>& Array<T_numtype,N_rank>::initialize(
    T_numtype x)
{
    (*this) = _bz_ArrayExpr<_bz_ArrayExprConstant<T_numtype> >(x);
    return *this;
}



template<class T_numtype, int N_rank> template<class T_expr>
inline Array<T_numtype,N_rank>&
Array<T_numtype,N_rank>::operator=(const ETBase<T_expr>& expr)
{
    evaluate(static_cast<const T_expr&>(expr), 
        _bz_update<T_numtype, typename  T_expr::T_numtype>());
    return *this;
}

template<class T_numtype, int N_rank>
inline Array<T_numtype, N_rank>&
Array<T_numtype, N_rank>::operator=(const Array<T_numtype,N_rank>& x)
{
    (*this) = _bz_ArrayExpr<FastArrayIterator<T_numtype, N_rank> >
        (x.beginFast());
    return *this;
}


# 56 "../blitz/array/ops.cc"

template<class T_numtype, int N_rank> template<class T> inline Array<T_numtype,N_rank>& Array<T_numtype,N_rank>::operator  += (const T& expr) { evaluate(typename  asExpr<T>::T_expr(expr),   _bz_plus_update <T_numtype, typename  asExpr<T>::T_expr::T_numtype>()); return *this; } 
template<class T_numtype, int N_rank> template<class T> inline Array<T_numtype,N_rank>& Array<T_numtype,N_rank>::operator  -= (const T& expr) { evaluate(typename  asExpr<T>::T_expr(expr),   _bz_minus_update <T_numtype, typename  asExpr<T>::T_expr::T_numtype>()); return *this; } 
template<class T_numtype, int N_rank> template<class T> inline Array<T_numtype,N_rank>& Array<T_numtype,N_rank>::operator  *= (const T& expr) { evaluate(typename  asExpr<T>::T_expr(expr),   _bz_multiply_update <T_numtype, typename  asExpr<T>::T_expr::T_numtype>()); return *this; } 
template<class T_numtype, int N_rank> template<class T> inline Array<T_numtype,N_rank>& Array<T_numtype,N_rank>::operator  /= (const T& expr) { evaluate(typename  asExpr<T>::T_expr(expr),   _bz_divide_update <T_numtype, typename  asExpr<T>::T_expr::T_numtype>()); return *this; } 
template<class T_numtype, int N_rank> template<class T> inline Array<T_numtype,N_rank>& Array<T_numtype,N_rank>::operator  %= (const T& expr) { evaluate(typename  asExpr<T>::T_expr(expr),   _bz_mod_update <T_numtype, typename  asExpr<T>::T_expr::T_numtype>()); return *this; } 
template<class T_numtype, int N_rank> template<class T> inline Array<T_numtype,N_rank>& Array<T_numtype,N_rank>::operator  ^= (const T& expr) { evaluate(typename  asExpr<T>::T_expr(expr),   _bz_xor_update <T_numtype, typename  asExpr<T>::T_expr::T_numtype>()); return *this; } 
template<class T_numtype, int N_rank> template<class T> inline Array<T_numtype,N_rank>& Array<T_numtype,N_rank>::operator  &= (const T& expr) { evaluate(typename  asExpr<T>::T_expr(expr),   _bz_bitand_update <T_numtype, typename  asExpr<T>::T_expr::T_numtype>()); return *this; } 
template<class T_numtype, int N_rank> template<class T> inline Array<T_numtype,N_rank>& Array<T_numtype,N_rank>::operator  |= (const T& expr) { evaluate(typename  asExpr<T>::T_expr(expr),   _bz_bitor_update <T_numtype, typename  asExpr<T>::T_expr::T_numtype>()); return *this; } 
template<class T_numtype, int N_rank> template<class T> inline Array<T_numtype,N_rank>& Array<T_numtype,N_rank>::operator  <<= (const T& expr) { evaluate(typename  asExpr<T>::T_expr(expr),   _bz_shiftl_update <T_numtype, typename  asExpr<T>::T_expr::T_numtype>()); return *this; } 
template<class T_numtype, int N_rank> template<class T> inline Array<T_numtype,N_rank>& Array<T_numtype,N_rank>::operator  >>= (const T& expr) { evaluate(typename  asExpr<T>::T_expr(expr),   _bz_shiftr_update <T_numtype, typename  asExpr<T>::T_expr::T_numtype>()); return *this; } 

# 351 "../blitz/array/ops.cc"


} 


# 2463 "../blitz/array.h" 2

# 1 "../blitz/array/io.cc" 1







namespace  blitz  { 

template<class T_numtype>
ostream& operator<<(ostream& os, const Array<T_numtype,1>& x)
{
    os << x.extent(firstRank) << endl;
    os << " [ ";
    for (int i=x.lbound(firstRank); i <= x.ubound(firstRank); ++i)
    {
        os << setw(9) << x(i) << " ";
        if (!((i+1-x.lbound(firstRank))%7))
            os << endl << "  ";
    }
    os << " ]";
    return os;
}

template<class T_numtype>
ostream& operator<<(ostream& os, const Array<T_numtype,2>& x)
{
    os << x.rows() << " x " << x.columns() << endl;
    os << "[ ";
    for (int i=x.lbound(firstRank); i <= x.ubound(firstRank); ++i)
    {
        for (int j=x.lbound(secondRank); j <= x.ubound(secondRank); ++j)
        {
            os << setw(9) << x(i,j) << " ";
            if (!((j+1-x.lbound(secondRank)) % 7))
                os << endl << "  ";
        }

        if (i != x.ubound(firstRank))
           os << endl << "  ";
    }

    os << "]" << endl;

    return os;
}

template<class T_numtype, int N_rank>
ostream& operator<<(ostream& os, const Array<T_numtype,N_rank>& x)
{
    for (int i=0; i < N_rank; ++i)
    {
        os << x.extent(i);
        if (i != N_rank - 1)
            os << " x ";
    }

    os << endl << "[ ";
    
    Array<T_numtype, N_rank>::const_iterator iter = x.begin(), end = x.end();
    int p = 0;

    while (iter != end) {
        os << setw(9) << (*iter) << " ";
        ++iter;

         
        ++p;
        if (!(p % 7))
            os << endl << "  ";
    }

    os << "]" << endl;
    return os;
}

 



template<class T_numtype, int N_rank>
istream& operator>>(istream& is, Array<T_numtype,N_rank>& x)
{
    TinyVector<int,N_rank> extent;
    char sep;
 
     
     

    for (int i=0; i < N_rank; ++i)
    {
        is >> extent(i);

         ;

        if (i != N_rank - 1)
        {
            is >> sep;
             ;

        }
    }

    is >> sep;
     ;


    x.resize(extent);

    Array<T_numtype,N_rank>::iterator iter = x.begin(), end = x.end();

    while (iter != end) {
         ;

        is >> (*iter);
        ++iter;
    }

    is >> sep;
     ;


    return is;
}

} 


# 2464 "../blitz/array.h" 2



 
# 1 "../blitz/array/et.h" 1

















namespace  blitz  { 

 







# 108 "../blitz/array/et.h"

 
 
 

template<class T_numtype1, int N_rank1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,    Add <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator+  (const Array<T_numtype1,N_rank1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,    Add <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > > (d1.beginFast(),d2); } template<class T_expr1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,    Add < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator+ (const _bz_ArrayExpr<T_expr1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,    Add < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Add < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator+ (const ETBase<T1>& d1, const T2& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Add < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (static_cast<const T1&>(d1), d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Add < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator+ (const T1& d1, const ETBase<T2>& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Add < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (d1, static_cast<const T2&>(d2)); } template<int N1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,    Add <int, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator+ (IndexPlaceholder<N1> d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,    Add <int, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } 
template<class T_numtype1, int N_rank1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,    Subtract <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator-  (const Array<T_numtype1,N_rank1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,    Subtract <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > > (d1.beginFast(),d2); } template<class T_expr1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,    Subtract < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator- (const _bz_ArrayExpr<T_expr1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,    Subtract < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Subtract < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator- (const ETBase<T1>& d1, const T2& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Subtract < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (static_cast<const T1&>(d1), d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Subtract < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator- (const T1& d1, const ETBase<T2>& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Subtract < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (d1, static_cast<const T2&>(d2)); } template<int N1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,    Subtract <int, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator- (IndexPlaceholder<N1> d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,    Subtract <int, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } 
template<class T_numtype1, int N_rank1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,    Multiply <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator*  (const Array<T_numtype1,N_rank1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,    Multiply <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > > (d1.beginFast(),d2); } template<class T_expr1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,    Multiply < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator* (const _bz_ArrayExpr<T_expr1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,    Multiply < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Multiply < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator* (const ETBase<T1>& d1, const T2& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Multiply < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (static_cast<const T1&>(d1), d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Multiply < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator* (const T1& d1, const ETBase<T2>& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Multiply < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (d1, static_cast<const T2&>(d2)); } template<int N1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,    Multiply <int, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator* (IndexPlaceholder<N1> d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,    Multiply <int, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } 
template<class T_numtype1, int N_rank1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,    Divide <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator/  (const Array<T_numtype1,N_rank1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,    Divide <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > > (d1.beginFast(),d2); } template<class T_expr1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,    Divide < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator/ (const _bz_ArrayExpr<T_expr1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,    Divide < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Divide < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator/ (const ETBase<T1>& d1, const T2& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Divide < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (static_cast<const T1&>(d1), d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Divide < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator/ (const T1& d1, const ETBase<T2>& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Divide < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (d1, static_cast<const T2&>(d2)); } template<int N1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,    Divide <int, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator/ (IndexPlaceholder<N1> d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,    Divide <int, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } 
template<class T_numtype1, int N_rank1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,    Modulo <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator%  (const Array<T_numtype1,N_rank1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,    Modulo <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > > (d1.beginFast(),d2); } template<class T_expr1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,    Modulo < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator% (const _bz_ArrayExpr<T_expr1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,    Modulo < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Modulo < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator% (const ETBase<T1>& d1, const T2& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Modulo < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (static_cast<const T1&>(d1), d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Modulo < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator% (const T1& d1, const ETBase<T2>& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Modulo < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (d1, static_cast<const T2&>(d2)); } template<int N1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,    Modulo <int, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator% (IndexPlaceholder<N1> d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,    Modulo <int, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } 
template<class T_numtype1, int N_rank1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,    BitwiseXor <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator^  (const Array<T_numtype1,N_rank1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,    BitwiseXor <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > > (d1.beginFast(),d2); } template<class T_expr1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,    BitwiseXor < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator^ (const _bz_ArrayExpr<T_expr1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,    BitwiseXor < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    BitwiseXor < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator^ (const ETBase<T1>& d1, const T2& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    BitwiseXor < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (static_cast<const T1&>(d1), d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    BitwiseXor < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator^ (const T1& d1, const ETBase<T2>& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    BitwiseXor < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (d1, static_cast<const T2&>(d2)); } template<int N1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,    BitwiseXor <int, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator^ (IndexPlaceholder<N1> d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,    BitwiseXor <int, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } 
template<class T_numtype1, int N_rank1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,    BitwiseAnd <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator&  (const Array<T_numtype1,N_rank1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,    BitwiseAnd <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > > (d1.beginFast(),d2); } template<class T_expr1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,    BitwiseAnd < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator& (const _bz_ArrayExpr<T_expr1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,    BitwiseAnd < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    BitwiseAnd < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator& (const ETBase<T1>& d1, const T2& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    BitwiseAnd < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (static_cast<const T1&>(d1), d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    BitwiseAnd < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator& (const T1& d1, const ETBase<T2>& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    BitwiseAnd < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (d1, static_cast<const T2&>(d2)); } template<int N1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,    BitwiseAnd <int, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator& (IndexPlaceholder<N1> d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,    BitwiseAnd <int, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } 
template<class T_numtype1, int N_rank1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,    BitwiseOr <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator|  (const Array<T_numtype1,N_rank1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,    BitwiseOr <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > > (d1.beginFast(),d2); } template<class T_expr1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,    BitwiseOr < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator| (const _bz_ArrayExpr<T_expr1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,    BitwiseOr < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    BitwiseOr < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator| (const ETBase<T1>& d1, const T2& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    BitwiseOr < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (static_cast<const T1&>(d1), d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    BitwiseOr < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator| (const T1& d1, const ETBase<T2>& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    BitwiseOr < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (d1, static_cast<const T2&>(d2)); } template<int N1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,    BitwiseOr <int, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator| (IndexPlaceholder<N1> d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,    BitwiseOr <int, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } 
 
 
template<class T_numtype1, int N_rank1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,    Greater <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator>  (const Array<T_numtype1,N_rank1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,    Greater <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > > (d1.beginFast(),d2); } template<class T_expr1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,    Greater < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator> (const _bz_ArrayExpr<T_expr1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,    Greater < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Greater < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator> (const ETBase<T1>& d1, const T2& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Greater < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (static_cast<const T1&>(d1), d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Greater < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator> (const T1& d1, const ETBase<T2>& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Greater < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (d1, static_cast<const T2&>(d2)); } template<int N1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,    Greater <int, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator> (IndexPlaceholder<N1> d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,    Greater <int, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } 
template<class T_numtype1, int N_rank1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,    Less <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator<  (const Array<T_numtype1,N_rank1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,    Less <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > > (d1.beginFast(),d2); } template<class T_expr1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,    Less < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator< (const _bz_ArrayExpr<T_expr1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,    Less < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Less < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator< (const ETBase<T1>& d1, const T2& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Less < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (static_cast<const T1&>(d1), d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Less < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator< (const T1& d1, const ETBase<T2>& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,    Less < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (d1, static_cast<const T2&>(d2)); } template<int N1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,    Less <int, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator< (IndexPlaceholder<N1> d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,    Less <int, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } 
template<class T_numtype1, int N_rank1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,   GreaterOrEqual <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator>=  (const Array<T_numtype1,N_rank1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,   GreaterOrEqual <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > > (d1.beginFast(),d2); } template<class T_expr1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,   GreaterOrEqual < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator>= (const _bz_ArrayExpr<T_expr1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,   GreaterOrEqual < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   GreaterOrEqual < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator>= (const ETBase<T1>& d1, const T2& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   GreaterOrEqual < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (static_cast<const T1&>(d1), d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   GreaterOrEqual < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator>= (const T1& d1, const ETBase<T2>& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   GreaterOrEqual < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (d1, static_cast<const T2&>(d2)); } template<int N1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,   GreaterOrEqual <int, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator>= (IndexPlaceholder<N1> d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,   GreaterOrEqual <int, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } 
template<class T_numtype1, int N_rank1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,   LessOrEqual <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator<=  (const Array<T_numtype1,N_rank1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,   LessOrEqual <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > > (d1.beginFast(),d2); } template<class T_expr1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,   LessOrEqual < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator<= (const _bz_ArrayExpr<T_expr1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,   LessOrEqual < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   LessOrEqual < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator<= (const ETBase<T1>& d1, const T2& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   LessOrEqual < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (static_cast<const T1&>(d1), d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   LessOrEqual < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator<= (const T1& d1, const ETBase<T2>& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   LessOrEqual < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (d1, static_cast<const T2&>(d2)); } template<int N1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,   LessOrEqual <int, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator<= (IndexPlaceholder<N1> d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,   LessOrEqual <int, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } 
template<class T_numtype1, int N_rank1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,   Equal <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator==  (const Array<T_numtype1,N_rank1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,   Equal <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > > (d1.beginFast(),d2); } template<class T_expr1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,   Equal < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator== (const _bz_ArrayExpr<T_expr1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,   Equal < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   Equal < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator== (const ETBase<T1>& d1, const T2& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   Equal < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (static_cast<const T1&>(d1), d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   Equal < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator== (const T1& d1, const ETBase<T2>& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   Equal < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (d1, static_cast<const T2&>(d2)); } template<int N1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,   Equal <int, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator== (IndexPlaceholder<N1> d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,   Equal <int, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } 
template<class T_numtype1, int N_rank1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,   NotEqual <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator!=  (const Array<T_numtype1,N_rank1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,   NotEqual <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > > (d1.beginFast(),d2); } template<class T_expr1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,   NotEqual < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator!= (const _bz_ArrayExpr<T_expr1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,   NotEqual < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   NotEqual < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator!= (const ETBase<T1>& d1, const T2& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   NotEqual < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (static_cast<const T1&>(d1), d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   NotEqual < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator!= (const T1& d1, const ETBase<T2>& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   NotEqual < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (d1, static_cast<const T2&>(d2)); } template<int N1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,   NotEqual <int, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator!= (IndexPlaceholder<N1> d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,   NotEqual <int, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } 
template<class T_numtype1, int N_rank1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,   LogicalAnd <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator&&  (const Array<T_numtype1,N_rank1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,   LogicalAnd <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > > (d1.beginFast(),d2); } template<class T_expr1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,   LogicalAnd < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator&& (const _bz_ArrayExpr<T_expr1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,   LogicalAnd < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   LogicalAnd < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator&& (const ETBase<T1>& d1, const T2& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   LogicalAnd < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (static_cast<const T1&>(d1), d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   LogicalAnd < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator&& (const T1& d1, const ETBase<T2>& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   LogicalAnd < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (d1, static_cast<const T2&>(d2)); } template<int N1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,   LogicalAnd <int, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator&& (IndexPlaceholder<N1> d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,   LogicalAnd <int, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } 
template<class T_numtype1, int N_rank1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,   LogicalOr <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator||  (const Array<T_numtype1,N_rank1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,   LogicalOr <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > > (d1.beginFast(),d2); } template<class T_expr1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,   LogicalOr < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator|| (const _bz_ArrayExpr<T_expr1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,   LogicalOr < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   LogicalOr < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator|| (const ETBase<T1>& d1, const T2& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   LogicalOr < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (static_cast<const T1&>(d1), d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   LogicalOr < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  operator|| (const T1& d1, const ETBase<T2>& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,   LogicalOr < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (d1, static_cast<const T2&>(d2)); } template<int N1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,   LogicalOr <int, typename  asExpr<T_other>::T_expr::T_numtype> > >  operator|| (IndexPlaceholder<N1> d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,   LogicalOr <int, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } 

template<class T_numtype1, int N_rank1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,        _bz_atan2 <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > >  atan2  (const Array<T_numtype1,N_rank1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,        _bz_atan2 <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > > (d1.beginFast(),d2); } template<class T_expr1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,        _bz_atan2 < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >  atan2 (const _bz_ArrayExpr<T_expr1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,        _bz_atan2 < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,        _bz_atan2 < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  atan2 (const ETBase<T1>& d1, const T2& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,        _bz_atan2 < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (static_cast<const T1&>(d1), d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,        _bz_atan2 < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  atan2 (const T1& d1, const ETBase<T2>& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,        _bz_atan2 < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (d1, static_cast<const T2&>(d2)); } template<int N1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,        _bz_atan2 <int, typename  asExpr<T_other>::T_expr::T_numtype> > >  atan2 (IndexPlaceholder<N1> d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,        _bz_atan2 <int, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } 
template<class T_numtype1, int N_rank1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,          _bz_pow <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > >  pow  (const Array<T_numtype1,N_rank1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<FastArrayIterator<T_numtype1, N_rank1>, typename  asExpr<T_other>::T_expr,          _bz_pow <T_numtype1, typename  asExpr<T_other>::T_expr::T_numtype> > > (d1.beginFast(),d2); } template<class T_expr1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,          _bz_pow < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >  pow (const _bz_ArrayExpr<T_expr1>& d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<_bz_ArrayExpr<T_expr1>, typename  asExpr<T_other>::T_expr,          _bz_pow < typename  T_expr1::T_numtype, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,          _bz_pow < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  pow (const ETBase<T1>& d1, const T2& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,          _bz_pow < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (static_cast<const T1&>(d1), d2); } template<class T1, class T2>   _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,          _bz_pow < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > >  pow (const T1& d1, const ETBase<T2>& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, typename  asExpr<T2>::T_expr,          _bz_pow < typename  asExpr<T1>::T_expr::T_numtype, typename  asExpr<T2>::T_expr::T_numtype> > > (d1, static_cast<const T2&>(d2)); } template<int N1, class T_other>   _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,          _bz_pow <int, typename  asExpr<T_other>::T_expr::T_numtype> > >  pow (IndexPlaceholder<N1> d1, const T_other& d2) { return _bz_ArrayExpr<_bz_ArrayExprOp<IndexPlaceholder<N1>, typename  asExpr<T_other>::T_expr,          _bz_pow <int, typename  asExpr<T_other>::T_expr::T_numtype> > >(d1,d2); } 





# 148 "../blitz/array/et.h"


 




# 167 "../blitz/array/et.h"

template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,   _bz_negate < typename  asExpr<T1>::T_expr::T_numtype> > >  operator- (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,   _bz_negate < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 

 

template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,     _bz_abs < typename  asExpr<T1>::T_expr::T_numtype> > >  abs (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,     _bz_abs < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_acos < typename  asExpr<T1>::T_expr::T_numtype> > >  acos (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_acos < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_asin < typename  asExpr<T1>::T_expr::T_numtype> > >  asin (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_asin < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_atan < typename  asExpr<T1>::T_expr::T_numtype> > >  atan (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_atan < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_ceil < typename  asExpr<T1>::T_expr::T_numtype> > >  ceil (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_ceil < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_cexp < typename  asExpr<T1>::T_expr::T_numtype> > >  cexp (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_cexp < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,     _bz_cos < typename  asExpr<T1>::T_expr::T_numtype> > >  cos (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,     _bz_cos < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_cosh < typename  asExpr<T1>::T_expr::T_numtype> > >  cosh (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_cosh < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,   _bz_csqrt < typename  asExpr<T1>::T_expr::T_numtype> > >  csqrt (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,   _bz_csqrt < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,     _bz_exp < typename  asExpr<T1>::T_expr::T_numtype> > >  exp (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,     _bz_exp < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_abs < typename  asExpr<T1>::T_expr::T_numtype> > >  fabs (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_abs < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,   _bz_floor < typename  asExpr<T1>::T_expr::T_numtype> > >  floor (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,   _bz_floor < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,     _bz_log < typename  asExpr<T1>::T_expr::T_numtype> > >  log (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,     _bz_log < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,   _bz_log10 < typename  asExpr<T1>::T_expr::T_numtype> > >  log10 (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,   _bz_log10 < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_pow2 < typename  asExpr<T1>::T_expr::T_numtype> > >  pow2 (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_pow2 < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_pow3 < typename  asExpr<T1>::T_expr::T_numtype> > >  pow3 (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_pow3 < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_pow4 < typename  asExpr<T1>::T_expr::T_numtype> > >  pow4 (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_pow4 < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_pow5 < typename  asExpr<T1>::T_expr::T_numtype> > >  pow5 (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_pow5 < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_pow6 < typename  asExpr<T1>::T_expr::T_numtype> > >  pow6 (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_pow6 < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_pow7 < typename  asExpr<T1>::T_expr::T_numtype> > >  pow7 (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_pow7 < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_pow8 < typename  asExpr<T1>::T_expr::T_numtype> > >  pow8 (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_pow8 < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,     _bz_sin < typename  asExpr<T1>::T_expr::T_numtype> > >  sin (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,     _bz_sin < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_sinh < typename  asExpr<T1>::T_expr::T_numtype> > >  sinh (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_sinh < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,     _bz_sqr < typename  asExpr<T1>::T_expr::T_numtype> > >  sqr (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,     _bz_sqr < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_sqrt < typename  asExpr<T1>::T_expr::T_numtype> > >  sqrt (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_sqrt < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,     _bz_tan < typename  asExpr<T1>::T_expr::T_numtype> > >  tan (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,     _bz_tan < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_tanh < typename  asExpr<T1>::T_expr::T_numtype> > >  tanh (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_tanh < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 

















 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_acosh < typename  asExpr<T1>::T_expr::T_numtype> > >  acosh (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_acosh < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_asinh < typename  asExpr<T1>::T_expr::T_numtype> > >  asinh (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_asinh < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_atanh < typename  asExpr<T1>::T_expr::T_numtype> > >  atanh (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_atanh < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,     _bz_cbrt < typename  asExpr<T1>::T_expr::T_numtype> > >  cbrt (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,     _bz_cbrt < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_expm1 < typename  asExpr<T1>::T_expr::T_numtype> > >  expm1 (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_expm1 < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,      _bz_erf < typename  asExpr<T1>::T_expr::T_numtype> > >  erf (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,      _bz_erf < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,     _bz_erfc < typename  asExpr<T1>::T_expr::T_numtype> > >  erfc (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,     _bz_erfc < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_isnan < typename  asExpr<T1>::T_expr::T_numtype> > >  isnan (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_isnan < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,       _bz_j0 < typename  asExpr<T1>::T_expr::T_numtype> > >  j0 (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,       _bz_j0 < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,       _bz_j1 < typename  asExpr<T1>::T_expr::T_numtype> > >  j1 (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,       _bz_j1 < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,   _bz_lgamma < typename  asExpr<T1>::T_expr::T_numtype> > >  lgamma (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,   _bz_lgamma < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,     _bz_logb < typename  asExpr<T1>::T_expr::T_numtype> > >  logb (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,     _bz_logb < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_log1p < typename  asExpr<T1>::T_expr::T_numtype> > >  log1p (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,    _bz_log1p < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,     _bz_rint < typename  asExpr<T1>::T_expr::T_numtype> > >  rint (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,     _bz_rint < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,       _bz_y0 < typename  asExpr<T1>::T_expr::T_numtype> > >  y0 (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,       _bz_y0 < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 
template<class T1>   _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,       _bz_y1 < typename  asExpr<T1>::T_expr::T_numtype> > >  y1 (const ETBase<T1>& d1) { return _bz_ArrayExpr<_bz_ArrayExprUnaryOp< typename  asExpr<T1>::T_expr,       _bz_y1 < typename  asExpr<T1>::T_expr::T_numtype> > > (static_cast<const T1&>(d1)); } 



 




# 262 "../blitz/array/et.h"


# 283 "../blitz/array/et.h"



# 308 "../blitz/array/et.h"


# 331 "../blitz/array/et.h"

} 


# 2467 "../blitz/array.h" 2






# 1 "../blitz/array/misc.cc" 1







namespace  blitz  { 


# 30 "../blitz/array/misc.cc"
                                                                       
template<class T_numtype, int N_rank> inline _bz_ArrayExpr<_bz_ArrayExprUnaryOp<FastArrayIterator<T_numtype,N_rank>,   LogicalNot <T_numtype> > >  operator! (const Array<T_numtype,N_rank>& array) { return _bz_ArrayExprUnaryOp<FastArrayIterator<T_numtype,N_rank>,   LogicalNot <T_numtype> >(array.beginFast()); } template<class T_expr> inline _bz_ArrayExpr<_bz_ArrayExprUnaryOp<_bz_ArrayExpr<T_expr>,   LogicalNot < typename  T_expr::T_numtype> > >  operator! (const  _bz_ArrayExpr<T_expr> &  expr) { return _bz_ArrayExprUnaryOp<_bz_ArrayExpr<T_expr>,   LogicalNot < typename  T_expr::T_numtype> >(expr); } 
template<class T_numtype, int N_rank> inline _bz_ArrayExpr<_bz_ArrayExprUnaryOp<FastArrayIterator<T_numtype,N_rank>,   BitwiseNot <T_numtype> > >  operator~ (const Array<T_numtype,N_rank>& array) { return _bz_ArrayExprUnaryOp<FastArrayIterator<T_numtype,N_rank>,   BitwiseNot <T_numtype> >(array.beginFast()); } template<class T_expr> inline _bz_ArrayExpr<_bz_ArrayExprUnaryOp<_bz_ArrayExpr<T_expr>,   BitwiseNot < typename  T_expr::T_numtype> > >  operator~ (const  _bz_ArrayExpr<T_expr> &  expr) { return _bz_ArrayExprUnaryOp<_bz_ArrayExpr<T_expr>,   BitwiseNot < typename  T_expr::T_numtype> >(expr); } 
template<class T_numtype, int N_rank> inline _bz_ArrayExpr<_bz_ArrayExprUnaryOp<FastArrayIterator<T_numtype,N_rank>,   Negate <T_numtype> > >  operator- (const Array<T_numtype,N_rank>& array) { return _bz_ArrayExprUnaryOp<FastArrayIterator<T_numtype,N_rank>,   Negate <T_numtype> >(array.beginFast()); } template<class T_expr> inline _bz_ArrayExpr<_bz_ArrayExprUnaryOp<_bz_ArrayExpr<T_expr>,   Negate < typename  T_expr::T_numtype> > >  operator- (const  _bz_ArrayExpr<T_expr> &  expr) { return _bz_ArrayExprUnaryOp<_bz_ArrayExpr<T_expr>,   Negate < typename  T_expr::T_numtype> >(expr); } 

 



template<class T_numtype, int N_rank, class T_cast>
inline                                                                 
_bz_ArrayExpr<_bz_ArrayExprUnaryOp<FastArrayIterator<T_numtype,N_rank>,   
    Cast<T_numtype, T_cast> > >
cast(const Array<T_numtype,N_rank>& array, T_cast)
{                                                                      
    return _bz_ArrayExprUnaryOp<FastArrayIterator<T_numtype,N_rank>,      
        Cast<T_numtype,T_cast> >(array.beginFast());                            
}                                                                      
                                                                       
template<class T_expr, class T_cast>
inline                                                                 
_bz_ArrayExpr<_bz_ArrayExprUnaryOp<_bz_ArrayExpr<T_expr>,              
    Cast< typename  T_expr::T_numtype,T_cast> > >                          
cast(const  _bz_ArrayExpr<T_expr> &  expr, T_cast)
{                                                                      
    return _bz_ArrayExprUnaryOp<_bz_ArrayExpr<T_expr>,                 
        Cast< typename  T_expr::T_numtype,T_cast> >(expr);                 
}                                                                      
                                                                       
} 



# 2473 "../blitz/array.h" 2

# 1 "../blitz/array/reduce.h" 1
 










































 
# 1 "../blitz/reduce.h" 1
 
















































namespace  blitz  { 

template<class P_sourcetype, class P_resulttype = typename  NumericTypeTraits< P_sourcetype >::T_sumtype >
class ReduceSum {

public:
    typedef P_sourcetype T_sourcetype;
    typedef P_resulttype T_resulttype;
    typedef T_resulttype T_numtype;

    enum { needIndex = 0, canProvideInitialValue = 1 };

    ReduceSum()
    { reset(); }

    ReduceSum(T_resulttype initialValue)
    { sum_ = initialValue; }

    bool operator()(T_sourcetype x)
    { 
        sum_ += x; 
        return true;
    }

    bool operator()(T_sourcetype x, int)
    { 
        sum_ += x; 
        return true;
    }

    T_resulttype result(int)
    { return sum_; }

    void reset()
    { sum_ = zero(T_resulttype()); }

    void reset(T_resulttype initialValue)
    { sum_ = initialValue; }
 
    static const char* name()
    { return "sum"; }
 
protected:
    T_resulttype sum_;
};

template<class P_sourcetype, class P_resulttype = typename  NumericTypeTraits< P_sourcetype >::T_floattype >
class ReduceMean {

public:
    typedef P_sourcetype T_sourcetype;
    typedef P_resulttype T_resulttype;
    typedef T_resulttype T_numtype;

    enum { needIndex = 0, canProvideInitialValue = 0 };

    ReduceMean()
    { reset(); }

    ReduceMean(T_resulttype)
    { 
         ;
        reset();
    }

    bool operator()(T_sourcetype x)
    { 
        sum_ += x; 
        return true;
    }

    bool operator()(T_sourcetype x, int)
    { 
        sum_ += x; 
        return true;
    }

    T_resulttype result(int count)
    { return sum_ / count; }

    void reset()
    { sum_ = zero(T_resulttype()); }

    void reset(T_resulttype)
    { 
         ;
        reset();
    }

    static const char* name() 
    { return "mean"; }

protected:
    T_resulttype sum_;
};

template<class P_sourcetype>
class ReduceMin {

public:
    typedef P_sourcetype T_sourcetype;
    typedef P_sourcetype T_resulttype;
    typedef T_resulttype T_numtype;

    enum { needIndex = 0, canProvideInitialValue = 1 };

    ReduceMin()
    { reset(); }

    ReduceMin(T_resulttype min)
    {
        min_ = min;
    }

    bool operator()(T_sourcetype x)
    { 
        if (x < min_)
            min_ = x;
        return true;
    }

    bool operator()(T_sourcetype x, int)
    {
        if (x < min_)
            min_ = x;
        return true;
    }

    T_resulttype result(int)
    { return min_; }

    void reset()
    { min_ = huge(P_sourcetype()); }

    void reset(T_resulttype initialValue)
    { min_ = initialValue; }

    static const char* name()
    { return "min"; }

protected:
    T_resulttype min_;
};

template<class P_sourcetype>
class ReduceMax {

public:
    typedef P_sourcetype T_sourcetype;
    typedef P_sourcetype T_resulttype;
    typedef T_resulttype T_numtype;

    enum { needIndex = 0, canProvideInitialValue = 1 };

    ReduceMax()
    { reset(); }

    ReduceMax(T_resulttype max)
    {
        max_ = max;
    }

    bool operator()(T_sourcetype x)
    {
        if (x > max_)
            max_ = x;
        return true;
    }

    bool operator()(T_sourcetype x, int)
    {
        if (x > max_)
            max_ = x;
        return true;
    }

    T_resulttype result(int)
    { return max_; }

    void reset()
    { max_ = tiny(P_sourcetype()); }

    void reset(T_resulttype initialValue)
    { max_ = initialValue; }

    static const char* name()
    { return "max"; }

protected:
    T_resulttype max_;
};

template<class P_sourcetype>
class ReduceMinIndex {

public:
    typedef P_sourcetype T_sourcetype;
    typedef int          T_resulttype;
    typedef T_resulttype T_numtype;

    enum { needIndex = 1, canProvideInitialValue = 0 };

    ReduceMinIndex()
    { reset(); }

    ReduceMinIndex(T_resulttype min)
    {
        reset(min);
    }

    bool operator()(T_sourcetype x)
    {
         ;
        return false;
    }

    bool operator()(T_sourcetype x, int index)
    {
        if (x < min_)
        {
            min_ = x;
            index_ = index;
        }
        return true;
    }

    T_resulttype result(int)
    { return index_; }

    void reset()
    { 
        min_ = huge(T_sourcetype());
        index_ = tiny(int());        
    }

    void reset(T_resulttype)
    { 
         ;
        reset();
    }

    static const char* name()
    { return "minIndex"; }

protected:
    T_sourcetype min_;
    int index_;
};

template<class P_sourcetype, int N>
class ReduceMinIndexVector {

public:
    typedef P_sourcetype T_sourcetype;
    typedef TinyVector<int,N> T_resulttype;
    typedef T_resulttype T_numtype;

    enum { canProvideInitialValue = 0 };

    ReduceMinIndexVector()
    { reset(); }

    ReduceMinIndexVector(T_resulttype min)
    {
        reset(min);
    }

    bool operator()(T_sourcetype x)
    {
         ;
        return false;
    }

    bool operator()(T_sourcetype, int)
    {
         ;
        return false;
    }
   
    bool operator()(T_sourcetype x, const TinyVector<int,N>& index)
    {
        if (x < min_)
        {
            min_ = x;
            index_ = index;
        }
        return true;
    }

    T_resulttype result(int)
    { return index_; }

    void reset()
    {
        min_ = huge(T_sourcetype());
        index_ = tiny(int());
    }

    void reset(T_resulttype)
    {
         ;
        reset();
    }

    static const char* name()
    { return "minIndex"; }

protected:
    T_sourcetype min_;
    TinyVector<int,N> index_;
};

template<class P_sourcetype>
class ReduceMaxIndex {

public:
    typedef P_sourcetype T_sourcetype;
    typedef int          T_resulttype;
    typedef T_resulttype T_numtype;

    enum { needIndex = 1, canProvideInitialValue = 0 };

    ReduceMaxIndex()
    { reset(); }

    ReduceMaxIndex(T_resulttype max)
    {
        reset(max);
    }

    bool operator()(T_sourcetype x)
    {
         ;
        return false;
    }

    bool operator()(T_sourcetype x, int index)
    {
        if (x > max_)
        {
            max_ = x;
            index_ = index;
        }
        return true;
    }

    T_resulttype result(int)
    { return index_; }

    void reset()
    {
        max_ = tiny(T_sourcetype());
        index_ = tiny(int());
    }

    void reset(T_resulttype)
    {
         ;
        reset();
    }

    static const char* name()
    { return "maxIndex"; }

protected:
    T_sourcetype max_;
    int index_;
};

template<class P_sourcetype, int N_rank>
class ReduceMaxIndexVector {

public:
    typedef P_sourcetype T_sourcetype;
    typedef TinyVector<int,N_rank> T_resulttype;
    typedef T_resulttype T_numtype;

    enum { canProvideInitialValue = 0 };

    ReduceMaxIndexVector()
    { reset(); }

    ReduceMaxIndexVector(T_resulttype max)
    {
        reset(max);
    }

    bool operator()(T_sourcetype x)
    {
         ;
        return false;
    }

    bool operator()(T_sourcetype x, const TinyVector<int,N_rank>& index)
    {
        if (x > max_)
        {
            max_ = x;
            index_ = index;
        }
        return true;
    }

    T_resulttype result(int)
    { return index_; }

    void reset()
    {
        max_ = tiny(T_sourcetype());
        index_ = tiny(int());
    }

    void reset(T_resulttype)
    {
         ;
        reset();
    }

    static const char* name()
    { return "maxIndex"; }

protected:
    T_sourcetype max_;
    TinyVector<int,N_rank> index_;
};

template<class P_sourcetype>
class ReduceFirst {

public:
    typedef P_sourcetype T_sourcetype;
    typedef int          T_resulttype;
    typedef T_resulttype T_numtype;

    enum { needIndex = 1, canProvideInitialValue = 0 };

    ReduceFirst()
    { reset(); }

    ReduceFirst(T_resulttype)
    {
         ;
    }

    bool operator()(T_sourcetype x)
    {
         ;
        return false;
    }

    bool operator()(T_sourcetype x, int index)
    {
        if (x)
        {
            index_ = index;
            return false;
        }
        else
            return true;
    }

    T_resulttype result(int)
    { return index_; }

    void reset()
    {
        index_ = tiny(int());
    }

    void reset(T_resulttype)
    {
         ;
        reset();
    }

    static const char* name()
    { return "first"; }

protected:
    int index_;
};

template<class P_sourcetype>
class ReduceLast {

public:
    typedef P_sourcetype T_sourcetype;
    typedef int          T_resulttype;
    typedef T_resulttype T_numtype;

    enum { needIndex = 1, canProvideInitialValue = 0 };

    ReduceLast()
    { reset(); }

    ReduceLast(T_resulttype)
    {
         ;
    }

    bool operator()(T_sourcetype x)
    {
         ;
        return false;
    }

    bool operator()(T_sourcetype x, int index)
    {
        if (x)
        {
            index_ = index;
            return true;
        }
        else
            return true;
    }

    T_resulttype result(int)
    { return index_; }

    void reset()
    {
        index_ = huge(int());
    }

    void reset(T_resulttype)
    {
         ;
        reset();
    }

    static const char* name()
    { return "last"; }

protected:
    int index_;
};

template<class P_sourcetype, class P_resulttype = typename  NumericTypeTraits< P_sourcetype >::T_sumtype >
class ReduceProduct {

public:
    typedef P_sourcetype T_sourcetype;
    typedef P_resulttype T_resulttype;
    typedef T_resulttype T_numtype;

    enum { needIndex = 0, canProvideInitialValue = 1 };

    ReduceProduct()
    { product_ = one(T_resulttype()); }

    ReduceProduct(T_resulttype initialValue)
    { product_ = initialValue; }

    bool operator()(T_sourcetype x)
    { 
        product_ *= x; 
        return true;
    }

    bool operator()(T_sourcetype x, int)
    { 
        product_ *= x; 
        return true;
    }

    T_resulttype result(int)
    { return product_; }

    void reset()
    { product_ = one(T_resulttype()); }

    void reset(T_resulttype initialValue)
    { product_ = initialValue; }

    static const char* name()
    { return "product"; }

protected:
    T_resulttype product_;
};

template<class P_sourcetype>
class ReduceCount {

public:
    typedef P_sourcetype T_sourcetype;
    typedef int          T_resulttype;
    typedef T_resulttype T_numtype;

    enum { needIndex = 0, canProvideInitialValue = 1 };

    ReduceCount()
    { reset(); }

    ReduceCount(T_resulttype count)
    {
        count_ = count;
    }

    bool operator()(T_sourcetype x)
    {
        if (x)
            ++count_;
        return true;
    }

    bool operator()(T_sourcetype x, int)
    {
        if (x)
            ++count_;
        return true;
    }

    T_resulttype result(int)
    { return count_; }

    void reset()
    { count_ = zero(T_resulttype()); }

    void reset(T_resulttype initialValue)
    { count_ = initialValue; }

    static const char* name()
    { return "count"; }

protected:
    T_resulttype count_;
};

template<class P_sourcetype>
class ReduceAny {

public:
    typedef P_sourcetype T_sourcetype;
    typedef bool      T_resulttype;
    typedef T_resulttype T_numtype;

    enum { needIndex = 0, canProvideInitialValue = 0 };

    ReduceAny()
    { reset(); }

    ReduceAny(T_resulttype initialValue)
    {
        reset(initialValue);
    }

    bool operator()(T_sourcetype x)
    {
        if (x)
        {
            any_ = true ;
            return false;
        }

        return true;
    }

    bool operator()(T_sourcetype x, int)
    {
        if (x)
        {
            any_ = true ;
            return false;
        }

        return true;
    }

    T_resulttype result(int)
    { return any_; }

    void reset()
    { any_ = false ; }

    void reset(T_resulttype)
    { 
         ;
        reset();
    }

    static const char* name()
    { return "any"; }

protected:
    T_resulttype any_;
};

template<class P_sourcetype>
class ReduceAll {

public:
    typedef P_sourcetype T_sourcetype;
    typedef bool      T_resulttype;
    typedef T_resulttype T_numtype;

    enum { needIndex = 0, canProvideInitialValue = 0 };

    ReduceAll()
    { reset(); }

    ReduceAll(T_resulttype initialValue)
    {
        reset(initialValue);
    }

    bool operator()(T_sourcetype x)
    {
        if (! bool (x))
        {
            all_ = false ;
            return false;
        }
        else
            return true;
    }

    bool operator()(T_sourcetype x, int)
    {
        if (! bool (x))
        {
            all_ = false ;
            return false;
        }
        else
            return true;
    }

    T_resulttype result(int)
    { return all_; }

    void reset()
    { all_ = true ; }

    void reset(T_resulttype)
    {
         ;
        reset();
    }

    static const char* name()
    { return "all"; }

protected:
    T_resulttype all_;
}; 

} 


# 44 "../blitz/array/reduce.h" 2



namespace  blitz  { 

template<class T_expr, int N_index, class T_reduction>
class _bz_ArrayExprReduce {

public:   
    typedef typename  T_reduction::T_numtype T_numtype;
    typedef T_expr      T_ctorArg1;
    typedef T_reduction T_ctorArg2;

    enum { numArrayOperands = (int) T_expr::numArrayOperands  ,
        numIndexPlaceholders = (int) T_expr::numIndexPlaceholders   + 1,
        rank = (int) T_expr::rank   - 1 };

    _bz_ArrayExprReduce(const _bz_ArrayExprReduce<T_expr,N_index,T_reduction>&
        reduce)
        : reduce_(reduce.reduce_), iter_(reduce.iter_)
    {
    }

    _bz_ArrayExprReduce(T_expr expr)
        : iter_(expr)
    { }

    _bz_ArrayExprReduce(T_expr expr, T_reduction reduce)
        : iter_(expr), reduce_(reduce)
    { }

    int lbound(int rank)
    { return iter_.lbound(rank); }

    int ubound(int rank)
    { return iter_.ubound(rank); }

    template<int N_destRank>
    T_numtype operator()(const TinyVector<int, N_destRank>& destIndex)
    {
         ;




        TinyVector<int, N_destRank + 1> index;

         
        _bz_meta_vecAssign<N_index, 0>::assign(index, destIndex, 
            _bz_update<int,int>());

        int lbound = iter_.lbound(N_index);
        int ubound = iter_.ubound(N_index);

         
         
         ;





        reduce_.reset();

        for (index[N_index] = iter_.lbound(N_index);
            index[N_index] <= ubound; ++index[N_index])
        {
            if (!reduce_(iter_(index), index[N_index]))
                break;
        }

        return reduce_.result(ubound-lbound+1);
    }

     
     
     
     
    int operator*()
    {
         ;
        return 0;
    }

     
    void push(int)
    {
         ;
    }

     
    void pop(int)
    {
         ;
    }

     
    void advance()
    {
         ;
    }

     
    void advance(int)
    {
         ;
    }

     
    void loadStride(int)
    {
         ;
    }

    bool  isUnitStride(int rank) const
    {
         ;
        return false;
    }

    void advanceUnitStride()
    {
         ;
    }

    bool  canCollapse(int,int) const
    {    ; return false ; }

    T_numtype operator[](int)
    {
         ;
        return T_numtype();
    }

    T_numtype fastRead(int)
    {
         ;
        return T_numtype();
    }

    int suggestStride(int) const
    {
         ;
        return 0;
    }

    bool  isStride(int,int) const
    {
         ;
        return true ;
    }

    template<int N_rank>
    void moveTo(const TinyVector<int,N_rank>& i)
    {
         ;
        return;
    }

    void prettyPrint(std::string& str, prettyPrintFormat& format) const
    {
         
        str += "reduce[NEEDS_WORK](";
        iter_.prettyPrint(str,format);
        str += ")";
    }

    template<class T_shape>
    bool  shapeCheck(const T_shape& shape) const
    { 
         
        return true ; 
    }

private: 
    _bz_ArrayExprReduce() { }

    T_reduction reduce_;
    T_expr iter_;
};


# 246 "../blitz/array/reduce.h"

template<class T_expr, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,        ReduceSum < typename  T_expr::T_numtype> > >  sum (_bz_ArrayExpr<T_expr> expr, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,        ReduceSum < typename  T_expr::T_numtype> >(expr); } template<class T_numtype, int N_rank, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,        ReduceSum <T_numtype> > >  sum (const Array<T_numtype, N_rank>& array, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,        ReduceSum <T_numtype> > (array.beginFast()); } 
template<class T_expr, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,       ReduceMean < typename  T_expr::T_numtype> > >  mean (_bz_ArrayExpr<T_expr> expr, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,       ReduceMean < typename  T_expr::T_numtype> >(expr); } template<class T_numtype, int N_rank, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,       ReduceMean <T_numtype> > >  mean (const Array<T_numtype, N_rank>& array, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,       ReduceMean <T_numtype> > (array.beginFast()); } 
template<class T_expr, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,        ReduceMin < typename  T_expr::T_numtype> > >  min (_bz_ArrayExpr<T_expr> expr, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,        ReduceMin < typename  T_expr::T_numtype> >(expr); } template<class T_numtype, int N_rank, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,        ReduceMin <T_numtype> > >  min (const Array<T_numtype, N_rank>& array, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,        ReduceMin <T_numtype> > (array.beginFast()); } 
template<class T_expr, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,   ReduceMinIndex < typename  T_expr::T_numtype> > >  minIndex (_bz_ArrayExpr<T_expr> expr, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,   ReduceMinIndex < typename  T_expr::T_numtype> >(expr); } template<class T_numtype, int N_rank, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,   ReduceMinIndex <T_numtype> > >  minIndex (const Array<T_numtype, N_rank>& array, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,   ReduceMinIndex <T_numtype> > (array.beginFast()); } 
template<class T_expr, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,        ReduceMax < typename  T_expr::T_numtype> > >  max (_bz_ArrayExpr<T_expr> expr, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,        ReduceMax < typename  T_expr::T_numtype> >(expr); } template<class T_numtype, int N_rank, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,        ReduceMax <T_numtype> > >  max (const Array<T_numtype, N_rank>& array, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,        ReduceMax <T_numtype> > (array.beginFast()); } 
template<class T_expr, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,   ReduceMaxIndex < typename  T_expr::T_numtype> > >  maxIndex (_bz_ArrayExpr<T_expr> expr, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,   ReduceMaxIndex < typename  T_expr::T_numtype> >(expr); } template<class T_numtype, int N_rank, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,   ReduceMaxIndex <T_numtype> > >  maxIndex (const Array<T_numtype, N_rank>& array, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,   ReduceMaxIndex <T_numtype> > (array.beginFast()); } 
template<class T_expr, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,    ReduceProduct < typename  T_expr::T_numtype> > >  product (_bz_ArrayExpr<T_expr> expr, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,    ReduceProduct < typename  T_expr::T_numtype> >(expr); } template<class T_numtype, int N_rank, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,    ReduceProduct <T_numtype> > >  product (const Array<T_numtype, N_rank>& array, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,    ReduceProduct <T_numtype> > (array.beginFast()); } 
template<class T_expr, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,      ReduceCount < typename  T_expr::T_numtype> > >  count (_bz_ArrayExpr<T_expr> expr, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,      ReduceCount < typename  T_expr::T_numtype> >(expr); } template<class T_numtype, int N_rank, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,      ReduceCount <T_numtype> > >  count (const Array<T_numtype, N_rank>& array, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,      ReduceCount <T_numtype> > (array.beginFast()); } 
template<class T_expr, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,        ReduceAny < typename  T_expr::T_numtype> > >  any (_bz_ArrayExpr<T_expr> expr, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,        ReduceAny < typename  T_expr::T_numtype> >(expr); } template<class T_numtype, int N_rank, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,        ReduceAny <T_numtype> > >  any (const Array<T_numtype, N_rank>& array, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,        ReduceAny <T_numtype> > (array.beginFast()); } 
template<class T_expr, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,        ReduceAll < typename  T_expr::T_numtype> > >  all (_bz_ArrayExpr<T_expr> expr, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,        ReduceAll < typename  T_expr::T_numtype> >(expr); } template<class T_numtype, int N_rank, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,        ReduceAll <T_numtype> > >  all (const Array<T_numtype, N_rank>& array, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,        ReduceAll <T_numtype> > (array.beginFast()); } 
template<class T_expr, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,      ReduceFirst < typename  T_expr::T_numtype> > >  first (_bz_ArrayExpr<T_expr> expr, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,      ReduceFirst < typename  T_expr::T_numtype> >(expr); } template<class T_numtype, int N_rank, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,      ReduceFirst <T_numtype> > >  first (const Array<T_numtype, N_rank>& array, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,      ReduceFirst <T_numtype> > (array.beginFast()); } 
template<class T_expr, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,       ReduceLast < typename  T_expr::T_numtype> > >  last (_bz_ArrayExpr<T_expr> expr, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<_bz_ArrayExpr<T_expr>, N_index,       ReduceLast < typename  T_expr::T_numtype> >(expr); } template<class T_numtype, int N_rank, int N_index> inline _bz_ArrayExpr<_bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,       ReduceLast <T_numtype> > >  last (const Array<T_numtype, N_rank>& array, const IndexPlaceholder<N_index>&) { return _bz_ArrayExprReduce<FastArrayIterator<T_numtype,N_rank>, N_index,       ReduceLast <T_numtype> > (array.beginFast()); } 

 



 
template<class T_expr, class T_reduction>
typename  T_reduction::T_resulttype
_bz_ArrayExprFullReduce(T_expr expr, T_reduction reduction);


# 287 "../blitz/array/reduce.h"

template<class T_expr> inline typename         ReduceSum < typename  T_expr::T_numtype>::T_resulttype  sum (_bz_ArrayExpr<T_expr> expr) { return _bz_ArrayExprFullReduce(expr,        ReduceSum < typename  T_expr::T_numtype>()); } template<class T_numtype, int N_rank> inline typename         ReduceSum <T_numtype>::T_resulttype  sum (const Array<T_numtype, N_rank>& array) { return _bz_ArrayExprFullReduce(array.beginFast(),        ReduceSum <T_numtype>()); } 
template<class T_expr> inline typename        ReduceMean < typename  T_expr::T_numtype>::T_resulttype  mean (_bz_ArrayExpr<T_expr> expr) { return _bz_ArrayExprFullReduce(expr,       ReduceMean < typename  T_expr::T_numtype>()); } template<class T_numtype, int N_rank> inline typename        ReduceMean <T_numtype>::T_resulttype  mean (const Array<T_numtype, N_rank>& array) { return _bz_ArrayExprFullReduce(array.beginFast(),       ReduceMean <T_numtype>()); } 
template<class T_expr> inline typename         ReduceMin < typename  T_expr::T_numtype>::T_resulttype  min (_bz_ArrayExpr<T_expr> expr) { return _bz_ArrayExprFullReduce(expr,        ReduceMin < typename  T_expr::T_numtype>()); } template<class T_numtype, int N_rank> inline typename         ReduceMin <T_numtype>::T_resulttype  min (const Array<T_numtype, N_rank>& array) { return _bz_ArrayExprFullReduce(array.beginFast(),        ReduceMin <T_numtype>()); } 
template<class T_expr> inline typename         ReduceMax < typename  T_expr::T_numtype>::T_resulttype  max (_bz_ArrayExpr<T_expr> expr) { return _bz_ArrayExprFullReduce(expr,        ReduceMax < typename  T_expr::T_numtype>()); } template<class T_numtype, int N_rank> inline typename         ReduceMax <T_numtype>::T_resulttype  max (const Array<T_numtype, N_rank>& array) { return _bz_ArrayExprFullReduce(array.beginFast(),        ReduceMax <T_numtype>()); } 
template<class T_expr> inline typename     ReduceProduct < typename  T_expr::T_numtype>::T_resulttype  product (_bz_ArrayExpr<T_expr> expr) { return _bz_ArrayExprFullReduce(expr,    ReduceProduct < typename  T_expr::T_numtype>()); } template<class T_numtype, int N_rank> inline typename     ReduceProduct <T_numtype>::T_resulttype  product (const Array<T_numtype, N_rank>& array) { return _bz_ArrayExprFullReduce(array.beginFast(),    ReduceProduct <T_numtype>()); } 
template<class T_expr> inline typename       ReduceCount < typename  T_expr::T_numtype>::T_resulttype  count (_bz_ArrayExpr<T_expr> expr) { return _bz_ArrayExprFullReduce(expr,      ReduceCount < typename  T_expr::T_numtype>()); } template<class T_numtype, int N_rank> inline typename       ReduceCount <T_numtype>::T_resulttype  count (const Array<T_numtype, N_rank>& array) { return _bz_ArrayExprFullReduce(array.beginFast(),      ReduceCount <T_numtype>()); } 
template<class T_expr> inline typename         ReduceAny < typename  T_expr::T_numtype>::T_resulttype  any (_bz_ArrayExpr<T_expr> expr) { return _bz_ArrayExprFullReduce(expr,        ReduceAny < typename  T_expr::T_numtype>()); } template<class T_numtype, int N_rank> inline typename         ReduceAny <T_numtype>::T_resulttype  any (const Array<T_numtype, N_rank>& array) { return _bz_ArrayExprFullReduce(array.beginFast(),        ReduceAny <T_numtype>()); } 
template<class T_expr> inline typename         ReduceAll < typename  T_expr::T_numtype>::T_resulttype  all (_bz_ArrayExpr<T_expr> expr) { return _bz_ArrayExprFullReduce(expr,        ReduceAll < typename  T_expr::T_numtype>()); } template<class T_numtype, int N_rank> inline typename         ReduceAll <T_numtype>::T_resulttype  all (const Array<T_numtype, N_rank>& array) { return _bz_ArrayExprFullReduce(array.beginFast(),        ReduceAll <T_numtype>()); } 
template<class T_expr> inline typename       ReduceFirst < typename  T_expr::T_numtype>::T_resulttype  first (_bz_ArrayExpr<T_expr> expr) { return _bz_ArrayExprFullReduce(expr,      ReduceFirst < typename  T_expr::T_numtype>()); } template<class T_numtype, int N_rank> inline typename       ReduceFirst <T_numtype>::T_resulttype  first (const Array<T_numtype, N_rank>& array) { return _bz_ArrayExprFullReduce(array.beginFast(),      ReduceFirst <T_numtype>()); } 
template<class T_expr> inline typename        ReduceLast < typename  T_expr::T_numtype>::T_resulttype  last (_bz_ArrayExpr<T_expr> expr) { return _bz_ArrayExprFullReduce(expr,       ReduceLast < typename  T_expr::T_numtype>()); } template<class T_numtype, int N_rank> inline typename        ReduceLast <T_numtype>::T_resulttype  last (const Array<T_numtype, N_rank>& array) { return _bz_ArrayExprFullReduce(array.beginFast(),       ReduceLast <T_numtype>()); } 

 
 


# 321 "../blitz/array/reduce.h"

template<class T_expr> inline typename    ReduceMinIndexVector < typename  T_expr::T_numtype, T_expr::rank>::T_resulttype  minIndex (_bz_ArrayExpr<T_expr> expr) { return _bz_reduceWithIndexVectorTraversal(expr,   ReduceMinIndexVector < typename  T_expr::T_numtype, T_expr::rank>()); } template<class T_numtype, int N_rank> inline typename    ReduceMinIndexVector <T_numtype,N_rank>::T_resulttype  minIndex (const Array<T_numtype, N_rank>& array) { return _bz_reduceWithIndexVectorTraversal( array.beginFast(),   ReduceMinIndexVector <T_numtype,N_rank>()); } 
template<class T_expr> inline typename    ReduceMaxIndexVector < typename  T_expr::T_numtype, T_expr::rank>::T_resulttype  maxIndex (_bz_ArrayExpr<T_expr> expr) { return _bz_reduceWithIndexVectorTraversal(expr,   ReduceMaxIndexVector < typename  T_expr::T_numtype, T_expr::rank>()); } template<class T_numtype, int N_rank> inline typename    ReduceMaxIndexVector <T_numtype,N_rank>::T_resulttype  maxIndex (const Array<T_numtype, N_rank>& array) { return _bz_reduceWithIndexVectorTraversal( array.beginFast(),   ReduceMaxIndexVector <T_numtype,N_rank>()); } 

} 

# 1 "../blitz/array/reduce.cc" 1




namespace  blitz  { 

template<class T_expr, class T_reduction>
typename  T_reduction::T_resulttype
_bz_reduceWithIndexTraversal(T_expr expr, T_reduction reduction);

template<class T_expr, class T_reduction>
typename  T_reduction::T_resulttype
_bz_reduceWithStackTraversal(T_expr expr, T_reduction reduction);

template<class T_expr, class T_reduction>
typename  T_reduction::T_resulttype
_bz_ArrayExprFullReduce(T_expr expr, T_reduction reduction)
{
# 32 "../blitz/array/reduce.cc"


    return _bz_reduceWithIndexTraversal(expr, reduction);

# 47 "../blitz/array/reduce.cc"

}

template<class T_expr, class T_reduction>
typename  T_reduction::T_resulttype
_bz_reduceWithIndexTraversal(T_expr expr, T_reduction reduction)
{
     

    reduction.reset();

    const int rank = T_expr::rank;

    TinyVector<int,rank> index, first, last;

    unsigned long count = 1;

    for (int i=0; i < rank; ++i)
    {
        index(i) = expr.lbound(i);
        first(i) = index(i);
        last(i) = expr.ubound(i) + 1;
        count *= last(i) - first(i);
    }

    const int maxRank = rank - 1;
    int lastlbound = expr.lbound(maxRank);
    int lastubound = expr.ubound(maxRank);

    int lastIndex = lastubound + 1;

    bool  loopFlag = true ;

    while(loopFlag) {
        for (index[maxRank] = lastlbound; index[maxRank] < lastIndex;
            ++index[maxRank])
        {
            if (!reduction(expr(index), index[maxRank]))
            {
                loopFlag = false ;
                break;
            }
        }

        int j = rank-2;
        for (; j >= 0; --j)
        {
            index(j+1) = first(j+1);
            ++index(j);
            if (index(j) != last(j))
                break;
        }

        if (j < 0)
            break;
    }

    return reduction.result(count);
}


template<class T_expr, class T_reduction>
typename  T_reduction::T_resulttype
_bz_reduceWithIndexVectorTraversal(T_expr expr, T_reduction reduction)
{
     
     

    reduction.reset();

    const int rank = T_expr::rank;

    TinyVector<int,rank> index, first, last;

    unsigned long count = 1;

    for (int i=0; i < rank; ++i)
    {
        index(i) = expr.lbound(i);
        first(i) = index(i);
        last(i) = expr.ubound(i) + 1;
        count *= last(i) - first(i);
    }

    const int maxRank = rank - 1;
    int lastlbound = expr.lbound(maxRank);
    int lastubound = expr.ubound(maxRank);

    int lastIndex = lastubound + 1;

    bool  loopFlag = true ;

    while(loopFlag) {
        for (index[maxRank] = lastlbound; index[maxRank] < lastIndex;
            ++index[maxRank])
        {
            if (!reduction(expr(index), index))
            {
                loopFlag = false ;
                break;
            }
        }

        int j = rank-2;
        for (; j >= 0; --j)
        {
            index(j+1) = first(j+1);
            ++index(j);
            if (index(j) != last(j))
                break;
        }

        if (j < 0)
            break;
    }

    return reduction.result(count);
}

} 

# 327 "../blitz/array/reduce.h" 2



# 2474 "../blitz/array.h" 2

# 1 "../blitz/array/interlace.cc" 1
 



































 
# 1 "../blitz/array/shape.h" 1
 




































namespace  blitz  { 

 










inline TinyVector<int,1> shape(int n1)
{ return TinyVector<int,1>(n1); }

inline TinyVector<int,2> shape(int n1, int n2)
{ return TinyVector<int,2>(n1,n2); }

inline TinyVector<int,3> shape(int n1, int n2, int n3)
{ return TinyVector<int,3>(n1,n2,n3); }

inline TinyVector<int,4> shape(int n1, int n2, int n3, int n4)
{ return TinyVector<int,4>(n1,n2,n3,n4); }

inline TinyVector<int,5> shape(int n1, int n2, int n3, int n4,
    int n5)
{ return TinyVector<int,5>(n1,n2,n3,n4,n5); }

inline TinyVector<int,6> shape(int n1, int n2, int n3, int n4,
    int n5, int n6)
{ return TinyVector<int,6>(n1,n2,n3,n4,n5,n6); }

inline TinyVector<int,7> shape(int n1, int n2, int n3, int n4,
    int n5, int n6, int n7)
{ return TinyVector<int,7>(n1,n2,n3,n4,n5,n6,n7); }

inline TinyVector<int,8> shape(int n1, int n2, int n3, int n4,
    int n5, int n6, int n7, int n8)
{ return TinyVector<int,8>(n1,n2,n3,n4,n5,n6,n7,n8); }

inline TinyVector<int,9> shape(int n1, int n2, int n3, int n4,
    int n5, int n6, int n7, int n8, int n9)
{ return TinyVector<int,9>(n1,n2,n3,n4,n5,n6,n7,n8,n9); }

inline TinyVector<int,10> shape(int n1, int n2, int n3, int n4,
    int n5, int n6, int n7, int n8, int n9, int n10)
{ return TinyVector<int,10>(n1,n2,n3,n4,n5,n6,n7,n8,n9,n10); }

inline TinyVector<int,11> shape(int n1, int n2, int n3, int n4,
    int n5, int n6, int n7, int n8, int n9, int n10, int n11)
{ return TinyVector<int,11>(n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11); }

} 



# 37 "../blitz/array/interlace.cc" 2



namespace  blitz  { 

 




















 
 
 

 
 
 
 
 

template<class T_numtype>
void makeInterlacedArray(Array<T_numtype,2>& mainArray,
    Array<T_numtype,1>& subarray, int slice)
{
    Array<T_numtype,1> tmp = mainArray(Range::all(), slice);
    subarray.reference(tmp);
}

template<class T_numtype>
void makeInterlacedArray(Array<T_numtype,3>& mainArray,
    Array<T_numtype,2>& subarray, int slice)
{
    Array<T_numtype,2> tmp = mainArray(Range::all(), Range::all(), 
        slice);
    subarray.reference(tmp);
}

template<class T_numtype>
void makeInterlacedArray(Array<T_numtype,4>& mainArray,
    Array<T_numtype,3>& subarray, int slice)
{
    Array<T_numtype,3> tmp = mainArray(Range::all(), Range::all(), 
        Range::all(), slice);
    subarray.reference(tmp);
}

 
template<class T_numtype, int N_rank>
void interlaceArrays(const TinyVector<int,N_rank>& shape,
    Array<T_numtype,N_rank>& a1, Array<T_numtype,N_rank>& a2)
{
    GeneralArrayStorage<N_rank+1> storage;
    Array<T_numtype, N_rank+1> array(shape, 2, storage);
    makeInterlacedArray(array, a1, 0);
    makeInterlacedArray(array, a2, 1);
}

template<class T_numtype, int N_rank>
void interlaceArrays(const TinyVector<int,N_rank>& shape,
    Array<T_numtype,N_rank>& a1, Array<T_numtype,N_rank>& a2,
    Array<T_numtype,N_rank>& a3)
{
    GeneralArrayStorage<N_rank+1> storage;
    Array<T_numtype, N_rank+1> array(shape, 3, storage);
    makeInterlacedArray(array, a1, 0);
    makeInterlacedArray(array, a2, 1);
    makeInterlacedArray(array, a3, 2);
}

template<class T_numtype, int N_rank>
void interlaceArrays(const TinyVector<int,N_rank>& shape,
    Array<T_numtype,N_rank>& a1, Array<T_numtype,N_rank>& a2,
    Array<T_numtype,N_rank>& a3, Array<T_numtype,N_rank>& a4)
{
    GeneralArrayStorage<N_rank+1> storage;
    Array<T_numtype, N_rank+1> array(shape, 4, storage);
    makeInterlacedArray(array, a1, 0);
    makeInterlacedArray(array, a2, 1);
    makeInterlacedArray(array, a3, 2);
    makeInterlacedArray(array, a4, 3);
}

template<class T_numtype, int N_rank>
void interlaceArrays(const TinyVector<int,N_rank>& shape,
    Array<T_numtype,N_rank>& a1, Array<T_numtype,N_rank>& a2,
    Array<T_numtype,N_rank>& a3, Array<T_numtype,N_rank>& a4,
    Array<T_numtype,N_rank>& a5)
{
    GeneralArrayStorage<N_rank+1> storage;
    Array<T_numtype, N_rank+1> array(shape, 5, storage);
    makeInterlacedArray(array, a1, 0);
    makeInterlacedArray(array, a2, 1);
    makeInterlacedArray(array, a3, 2);
    makeInterlacedArray(array, a4, 3);
    makeInterlacedArray(array, a5, 4);
}

template<class T_numtype, int N_rank>
void interlaceArrays(const TinyVector<int,N_rank>& shape,
    Array<T_numtype,N_rank>& a1, Array<T_numtype,N_rank>& a2,
    Array<T_numtype,N_rank>& a3, Array<T_numtype,N_rank>& a4,
    Array<T_numtype,N_rank>& a5, Array<T_numtype,N_rank>& a6)
{
    GeneralArrayStorage<N_rank+1> storage;
    Array<T_numtype, N_rank+1> array(shape, 6, storage);
    makeInterlacedArray(array, a1, 0);
    makeInterlacedArray(array, a2, 1);
    makeInterlacedArray(array, a3, 2);
    makeInterlacedArray(array, a4, 3);
    makeInterlacedArray(array, a5, 4);
    makeInterlacedArray(array, a6, 5);
}

template<class T_numtype, int N_rank>
void interlaceArrays(const TinyVector<int,N_rank>& shape,
    Array<T_numtype,N_rank>& a1, Array<T_numtype,N_rank>& a2,
    Array<T_numtype,N_rank>& a3, Array<T_numtype,N_rank>& a4,
    Array<T_numtype,N_rank>& a5, Array<T_numtype,N_rank>& a6,
    Array<T_numtype,N_rank>& a7)
{
    GeneralArrayStorage<N_rank+1> storage;
    Array<T_numtype, N_rank+1> array(shape, 7, storage);
    makeInterlacedArray(array, a1, 0);
    makeInterlacedArray(array, a2, 1);
    makeInterlacedArray(array, a3, 2);
    makeInterlacedArray(array, a4, 3);
    makeInterlacedArray(array, a5, 4);
    makeInterlacedArray(array, a6, 5);
    makeInterlacedArray(array, a7, 6);
}

template<class T_numtype, int N_rank>
void interlaceArrays(const TinyVector<int,N_rank>& shape,
    Array<T_numtype,N_rank>& a1, Array<T_numtype,N_rank>& a2,
    Array<T_numtype,N_rank>& a3, Array<T_numtype,N_rank>& a4,
    Array<T_numtype,N_rank>& a5, Array<T_numtype,N_rank>& a6,
    Array<T_numtype,N_rank>& a7, Array<T_numtype,N_rank>& a8)
{
    GeneralArrayStorage<N_rank+1> storage;
    Array<T_numtype, N_rank+1> array(shape, 8, storage);
    makeInterlacedArray(array, a1, 0);
    makeInterlacedArray(array, a2, 1);
    makeInterlacedArray(array, a3, 2);
    makeInterlacedArray(array, a4, 3);
    makeInterlacedArray(array, a5, 4);
    makeInterlacedArray(array, a6, 5);
    makeInterlacedArray(array, a7, 6);
    makeInterlacedArray(array, a8, 7);
}

template<class T_numtype, int N_rank>
void interlaceArrays(const TinyVector<int,N_rank>& shape,
    Array<T_numtype,N_rank>& a1, Array<T_numtype,N_rank>& a2,
    Array<T_numtype,N_rank>& a3, Array<T_numtype,N_rank>& a4,
    Array<T_numtype,N_rank>& a5, Array<T_numtype,N_rank>& a6,
    Array<T_numtype,N_rank>& a7, Array<T_numtype,N_rank>& a8,
    Array<T_numtype,N_rank>& a9)
{
    GeneralArrayStorage<N_rank+1> storage;
    Array<T_numtype, N_rank+1> array(shape, 9, storage);
    makeInterlacedArray(array, a1, 0);
    makeInterlacedArray(array, a2, 1);
    makeInterlacedArray(array, a3, 2);
    makeInterlacedArray(array, a4, 3);
    makeInterlacedArray(array, a5, 4);
    makeInterlacedArray(array, a6, 5);
    makeInterlacedArray(array, a7, 6);
    makeInterlacedArray(array, a8, 7);
    makeInterlacedArray(array, a9, 8);
}

template<class T_numtype, int N_rank>
void interlaceArrays(const TinyVector<int,N_rank>& shape,
    Array<T_numtype,N_rank>& a1, Array<T_numtype,N_rank>& a2,
    Array<T_numtype,N_rank>& a3, Array<T_numtype,N_rank>& a4,
    Array<T_numtype,N_rank>& a5, Array<T_numtype,N_rank>& a6,
    Array<T_numtype,N_rank>& a7, Array<T_numtype,N_rank>& a8,
    Array<T_numtype,N_rank>& a9, Array<T_numtype,N_rank>& a10)
{
    GeneralArrayStorage<N_rank+1> storage;
    Array<T_numtype, N_rank+1> array(shape, 10, storage);
    makeInterlacedArray(array, a1, 0);
    makeInterlacedArray(array, a2, 1);
    makeInterlacedArray(array, a3, 2);
    makeInterlacedArray(array, a4, 3);
    makeInterlacedArray(array, a5, 4);
    makeInterlacedArray(array, a6, 5);
    makeInterlacedArray(array, a7, 6);
    makeInterlacedArray(array, a8, 7);
    makeInterlacedArray(array, a9, 8);
    makeInterlacedArray(array, a10, 9);
}

template<class T_numtype, int N_rank>
void interlaceArrays(const TinyVector<int,N_rank>& shape,
    Array<T_numtype,N_rank>& a1, Array<T_numtype,N_rank>& a2,
    Array<T_numtype,N_rank>& a3, Array<T_numtype,N_rank>& a4,
    Array<T_numtype,N_rank>& a5, Array<T_numtype,N_rank>& a6,
    Array<T_numtype,N_rank>& a7, Array<T_numtype,N_rank>& a8,
    Array<T_numtype,N_rank>& a9, Array<T_numtype,N_rank>& a10,
    Array<T_numtype,N_rank>& a11)
{
    GeneralArrayStorage<N_rank+1> storage;
    Array<T_numtype, N_rank+1> array(shape, 11, storage);
    makeInterlacedArray(array, a1, 0);
    makeInterlacedArray(array, a2, 1);
    makeInterlacedArray(array, a3, 2);
    makeInterlacedArray(array, a4, 3);
    makeInterlacedArray(array, a5, 4);
    makeInterlacedArray(array, a6, 5);
    makeInterlacedArray(array, a7, 6);
    makeInterlacedArray(array, a8, 7);
    makeInterlacedArray(array, a9, 8);
    makeInterlacedArray(array, a10, 9);
    makeInterlacedArray(array, a11, 10);
}

 
 
 

 
 

template<class T_numtype, int N_rank>
void allocateArrays(const TinyVector<int,N_rank>& shape,
    Array<T_numtype,N_rank>& a1, Array<T_numtype,N_rank>& a2)
{



    a1.resize(shape);
    a2.resize(shape);

}

template<class T_numtype, int N_rank>
void allocateArrays(const TinyVector<int,N_rank>& shape,
    Array<T_numtype,N_rank>& a1, Array<T_numtype,N_rank>& a2,
    Array<T_numtype,N_rank>& a3)
{



    a1.resize(shape);
    a2.resize(shape);
    a3.resize(shape);

}

template<class T_numtype, int N_rank>
void allocateArrays(const TinyVector<int,N_rank>& shape,
    Array<T_numtype,N_rank>& a1, Array<T_numtype,N_rank>& a2,
    Array<T_numtype,N_rank>& a3, Array<T_numtype,N_rank>& a4)
{



    a1.resize(shape);
    a2.resize(shape);
    a3.resize(shape);
    a4.resize(shape);

}

template<class T_numtype, int N_rank>
void allocateArrays(const TinyVector<int,N_rank>& shape,
    Array<T_numtype,N_rank>& a1, Array<T_numtype,N_rank>& a2,
    Array<T_numtype,N_rank>& a3, Array<T_numtype,N_rank>& a4,
    Array<T_numtype,N_rank>& a5)
{



    a1.resize(shape);
    a2.resize(shape);
    a3.resize(shape);
    a4.resize(shape);
    a5.resize(shape);

}

template<class T_numtype, int N_rank>
void allocateArrays(const TinyVector<int,N_rank>& shape,
    Array<T_numtype,N_rank>& a1, Array<T_numtype,N_rank>& a2,
    Array<T_numtype,N_rank>& a3, Array<T_numtype,N_rank>& a4,
    Array<T_numtype,N_rank>& a5, Array<T_numtype,N_rank>& a6)
{



    a1.resize(shape);
    a2.resize(shape);
    a3.resize(shape);
    a4.resize(shape);
    a5.resize(shape);
    a6.resize(shape);

}

template<class T_numtype, int N_rank>
void allocateArrays(const TinyVector<int,N_rank>& shape,
    Array<T_numtype,N_rank>& a1, Array<T_numtype,N_rank>& a2,
    Array<T_numtype,N_rank>& a3, Array<T_numtype,N_rank>& a4,
    Array<T_numtype,N_rank>& a5, Array<T_numtype,N_rank>& a6,
    Array<T_numtype,N_rank>& a7)
{



    a1.resize(shape);
    a2.resize(shape);
    a3.resize(shape);
    a4.resize(shape);
    a5.resize(shape);
    a6.resize(shape);
    a7.resize(shape);

}

template<class T_numtype, int N_rank>
void allocateArrays(const TinyVector<int,N_rank>& shape,
    Array<T_numtype,N_rank>& a1, Array<T_numtype,N_rank>& a2,
    Array<T_numtype,N_rank>& a3, Array<T_numtype,N_rank>& a4,
    Array<T_numtype,N_rank>& a5, Array<T_numtype,N_rank>& a6,
    Array<T_numtype,N_rank>& a7, Array<T_numtype,N_rank>& a8)
{



    a1.resize(shape);
    a2.resize(shape);
    a3.resize(shape);
    a4.resize(shape);
    a5.resize(shape);
    a6.resize(shape);
    a7.resize(shape);
    a8.resize(shape);

}

template<class T_numtype, int N_rank>
void allocateArrays(const TinyVector<int,N_rank>& shape,
    Array<T_numtype,N_rank>& a1, Array<T_numtype,N_rank>& a2,
    Array<T_numtype,N_rank>& a3, Array<T_numtype,N_rank>& a4,
    Array<T_numtype,N_rank>& a5, Array<T_numtype,N_rank>& a6,
    Array<T_numtype,N_rank>& a7, Array<T_numtype,N_rank>& a8,
    Array<T_numtype,N_rank>& a9)
{



    a1.resize(shape);
    a2.resize(shape);
    a3.resize(shape);
    a4.resize(shape);
    a5.resize(shape);
    a6.resize(shape);
    a7.resize(shape);
    a8.resize(shape);
    a9.resize(shape);

}

template<class T_numtype, int N_rank>
void allocateArrays(const TinyVector<int,N_rank>& shape,
    Array<T_numtype,N_rank>& a1, Array<T_numtype,N_rank>& a2,
    Array<T_numtype,N_rank>& a3, Array<T_numtype,N_rank>& a4,
    Array<T_numtype,N_rank>& a5, Array<T_numtype,N_rank>& a6,
    Array<T_numtype,N_rank>& a7, Array<T_numtype,N_rank>& a8,
    Array<T_numtype,N_rank>& a9, Array<T_numtype,N_rank>& a10)
{



    a1.resize(shape);
    a2.resize(shape);
    a3.resize(shape);
    a4.resize(shape);
    a5.resize(shape);
    a6.resize(shape);
    a7.resize(shape);
    a8.resize(shape);
    a9.resize(shape);
    a10.resize(shape);

}

template<class T_numtype, int N_rank>
void allocateArrays(const TinyVector<int,N_rank>& shape,
    Array<T_numtype,N_rank>& a1, Array<T_numtype,N_rank>& a2,
    Array<T_numtype,N_rank>& a3, Array<T_numtype,N_rank>& a4,
    Array<T_numtype,N_rank>& a5, Array<T_numtype,N_rank>& a6,
    Array<T_numtype,N_rank>& a7, Array<T_numtype,N_rank>& a8,
    Array<T_numtype,N_rank>& a9, Array<T_numtype,N_rank>& a10,
    Array<T_numtype,N_rank>& a11)
{



    a1.resize(shape);
    a2.resize(shape);
    a3.resize(shape);
    a4.resize(shape);
    a5.resize(shape);
    a6.resize(shape);
    a7.resize(shape);
    a8.resize(shape);
    a9.resize(shape);
    a10.resize(shape);
    a11.resize(shape);

}

 

 
template<class T_numtype, int N_rank>
Array<T_numtype,N_rank>::Array(const TinyVector<int,N_rank-1>& shape,
    int lastExtent, const GeneralArrayStorage<N_rank>& storage)
    : storage_(storage)
{
     
     
     

    if (ordering(0) == 0)
    {
         
        length_[0] = lastExtent;
        storage_.setBase(0,0);
        for (int i=1; i < N_rank; ++i)
            length_[i] = shape[i-1];
    }
    else if (ordering(0) == N_rank-1)
    {
         
        for (int i=0; i < N_rank-1; ++i)
            length_[i] = shape[i];
        length_[N_rank-1] = lastExtent;
        storage_.setBase(N_rank-1, 0);
    }
    else {
         ;
    }

    setupStorage(N_rank-1);
}

 
# 544 "../blitz/array/interlace.cc"


} 



# 2475 "../blitz/array.h" 2

# 1 "../blitz/array/resize.cc" 1







# 1 "../blitz/minmax.h" 1





namespace  blitz  { 

 




namespace  minmax  { 

template<class T1, class T2>
typename  promote_trait< T1 , T2 >::T_promote  min(const T1& a, const T2& b)
{
    typedef typename  promote_trait< T1 , T2 >::T_promote  T_promote;

    if (a <= b)
        return T_promote(a);
    else
        return T_promote(b);
}

template<class T1, class T2>
typename  promote_trait< T1 , T2 >::T_promote  max(const T1& a, const T2& b)
{
    typedef typename  promote_trait< T1 , T2 >::T_promote  T_promote;

    if (a >= b)
        return T_promote(a);
    else
        return T_promote(b);
}

} 

} 


# 8 "../blitz/array/resize.cc" 2


namespace  blitz  { 

template<class T_numtype, int N_rank>
void Array<T_numtype, N_rank>::resize(int length0)
{
     ;
     ;

    if (length0 != length_[firstRank])
    {
        length_[firstRank] = length0;
        setupStorage(0);
    }
}

template<class T_numtype, int N_rank>
void Array<T_numtype, N_rank>::resize(int extent0, int extent1)
{
     ;
     ;

    if ((extent0 != length_[0]) || (extent1 != length_[1]))
    {
        length_[0] = extent0;
        length_[1] = extent1;
        setupStorage(1);
    }
}

template<class T_numtype, int N_rank>
void Array<T_numtype, N_rank>::resize(int extent0, int extent1,
    int extent2)
{
     ;
     ;

    if ((extent0 != length_[0]) || (extent1 != length_[1])
        || (extent2 != length_[2]))
    {
        length_[0] = extent0;
        length_[1] = extent1;
        length_[2] = extent2;
        setupStorage(2);
    }
}


template<class T_numtype, int N_rank>
void Array<T_numtype, N_rank>::resize(int extent0, int extent1,
    int extent2, int extent3)
{
     ;

     ;

    if ((extent0 != length_[0]) || (extent1 != length_[1])
        || (extent2 != length_[2]) || (extent3 != length_[3]))
    {
        length_[0] = extent0;
        length_[1] = extent1;
        length_[2] = extent2;
        length_[3] = extent3;
        setupStorage(3);
    }
}

template<class T_numtype, int N_rank>
void Array<T_numtype, N_rank>::resize(int extent0, int extent1,
    int extent2, int extent3, int extent4)
{
     ;

     ;

    if ((extent0 != length_[0]) || (extent1 != length_[1])
        || (extent2 != length_[2]) || (extent3 != length_[3])
        || (extent4 != length_[4]))
    {
        length_[0] = extent0;
        length_[1] = extent1;
        length_[2] = extent2;
        length_[3] = extent3;
        length_[4] = extent4;
        setupStorage(4);
    }
}

template<class T_numtype, int N_rank>
void Array<T_numtype, N_rank>::resize(int extent0, int extent1,
    int extent2, int extent3, int extent4, int extent5)
{
     ;

     ;

    if ((extent0 != length_[0]) || (extent1 != length_[1])
        || (extent2 != length_[2]) || (extent3 != length_[3])
        || (extent4 != length_[4]) || (extent5 != length_[5]))
    {
        length_[0] = extent0;
        length_[1] = extent1;
        length_[2] = extent2;
        length_[3] = extent3;
        length_[4] = extent4;
        length_[5] = extent5;
        setupStorage(5);
    }
}

template<class T_numtype, int N_rank>
void Array<T_numtype, N_rank>::resize(int extent0, int extent1,
    int extent2, int extent3, int extent4, int extent5,
    int extent6)
{
     ;


     ;

    if ((extent0 != length_[0]) || (extent1 != length_[1])
        || (extent2 != length_[2]) || (extent3 != length_[3])
        || (extent4 != length_[4]) || (extent5 != length_[5])
        || (extent6 != length_[6]))
    {
        length_[0] = extent0;
        length_[1] = extent1;
        length_[2] = extent2;
        length_[3] = extent3;
        length_[4] = extent4;
        length_[5] = extent5;
        length_[6] = extent6;
        setupStorage(6);
    }
}

template<class T_numtype, int N_rank>
void Array<T_numtype, N_rank>::resize(int extent0, int extent1,
    int extent2, int extent3, int extent4, int extent5,
    int extent6, int extent7)
{
     ;


     ;

    if ((extent0 != length_[0]) || (extent1 != length_[1])
        || (extent2 != length_[2]) || (extent3 != length_[3])
        || (extent4 != length_[4]) || (extent5 != length_[5])
        || (extent6 != length_[6]) || (extent7 != length_[7]))
    {
        length_[0] = extent0;
        length_[1] = extent1;
        length_[2] = extent2;
        length_[3] = extent3;
        length_[4] = extent4;
        length_[5] = extent5;
        length_[6] = extent6;
        length_[7] = extent7;
        setupStorage(7);
    }
}

template<class T_numtype, int N_rank>
void Array<T_numtype, N_rank>::resize(int extent0, int extent1,
    int extent2, int extent3, int extent4, int extent5,
    int extent6, int extent7, int extent8)
{
     ;


     ;

    if ((extent0 != length_[0]) || (extent1 != length_[1])
        || (extent2 != length_[2]) || (extent3 != length_[3])
        || (extent4 != length_[4]) || (extent5 != length_[5])
        || (extent6 != length_[6]) || (extent7 != length_[7])
        || (extent8 != length_[8]))
    {
        length_[0] = extent0;
        length_[1] = extent1;
        length_[2] = extent2;
        length_[3] = extent3;
        length_[4] = extent4;
        length_[5] = extent5;
        length_[6] = extent6;
        length_[7] = extent7;
        length_[8] = extent8;
        setupStorage(8);
    }
}


template<class T_numtype, int N_rank>
void Array<T_numtype, N_rank>::resize(int extent0, int extent1,
    int extent2, int extent3, int extent4, int extent5,
    int extent6, int extent7, int extent8, int extent9)
{
     ;



     ;

    if ((extent0 != length_[0]) || (extent1 != length_[1])
        || (extent2 != length_[2]) || (extent3 != length_[3])
        || (extent4 != length_[4]) || (extent5 != length_[5])
        || (extent6 != length_[6]) || (extent7 != length_[7])
        || (extent8 != length_[8]) || (extent9 != length_[9]))
    {
        length_[0] = extent0;
        length_[1] = extent1;
        length_[2] = extent2;
        length_[3] = extent3;
        length_[4] = extent4;
        length_[5] = extent5;
        length_[6] = extent6;
        length_[7] = extent7;
        length_[8] = extent8;
        length_[9] = extent9;
        setupStorage(9);
    }
}

template<class T_numtype, int N_rank>
void Array<T_numtype, N_rank>::resize(int extent0, int extent1,
    int extent2, int extent3, int extent4, int extent5,
    int extent6, int extent7, int extent8, int extent9,
    int extent10)
{
     ;



     ;

    if ((extent0 != length_[0]) || (extent1 != length_[1])
        || (extent2 != length_[2]) || (extent3 != length_[3])
        || (extent4 != length_[4]) || (extent5 != length_[5])
        || (extent6 != length_[6]) || (extent7 != length_[7])
        || (extent8 != length_[8]) || (extent9 != length_[9])
        || (extent10 != length_[10]))
    {
        length_[0] = extent0;
        length_[1] = extent1;
        length_[2] = extent2;
        length_[3] = extent3;
        length_[4] = extent4;
        length_[5] = extent5;
        length_[6] = extent6;
        length_[7] = extent7;
        length_[8] = extent8;
        length_[9] = extent9;
        length_[10] = extent10;
        setupStorage(10);
    }
}

template<class T_numtype, int N_rank>
void Array<T_numtype, N_rank>::resizeAndPreserve(int length0)
{
     ;
     ;

    if (length0 != length_[firstRank])
    {
# 291 "../blitz/array/resize.cc"

        T_array B(base(), blitz:: shape  (length0), storage_);   

        if (numElements())
        {
            Range overlap0 = Range(fromStart, minmax::min(B.ubound(0), 
              ubound(0)));
            B(overlap0) = (*this)(overlap0);
        }
        reference(B);
    }
}

template<class T_numtype, int N_rank>
void Array<T_numtype, N_rank>::resizeAndPreserve(int length0, int length1)
{
     ;
     ;

    if ((length0 != length_[0]) || (length1 != length_[1]))
    {
        T_array B(base(), blitz:: shape  (length0, length1), storage_);

        if (numElements())
        {
            Range overlap0 = Range(fromStart, minmax::min(B.ubound(0), 
                ubound(0)));
            Range overlap1 = Range(fromStart, minmax::min(B.ubound(1), 
                ubound(1)));
            B(overlap0, overlap1) = (*this)(overlap0, overlap1);
        }
        reference(B);
    }
}

template<class T_numtype, int N_rank>
void Array<T_numtype, N_rank>::resizeAndPreserve(int length0, int length1,
    int length2)
{
     ;
     ;

    if ((length0 != length_[0]) || (length1 != length_[1])
        || (length2 != length_[2]))
    {
        T_array B(base(), blitz:: shape  (length0, length1, length2), 
            storage_);
        if (numElements())
        {
            Range overlap0 = Range(fromStart, minmax::min(B.ubound(0), 
                ubound(0)));
            Range overlap1 = Range(fromStart, minmax::min(B.ubound(1), 
                ubound(1)));
            Range overlap2 = Range(fromStart, minmax::min(B.ubound(2), 
                ubound(2)));
            B(overlap0, overlap1, overlap2) = (*this)(overlap0, overlap1, 
                overlap2);
        }
        reference(B);
    }
}

template<class T_numtype, int N_rank>
void Array<T_numtype, N_rank>::resizeAndPreserve(int length0, int length1,
    int length2, int length3)
{
     ;

     ;

    if ((length0 != length_[0]) || (length1 != length_[1])
        || (length2 != length_[2]) || (length3 != length_[3]))
    {
        T_array B(base(), blitz:: shape  (length0, length1,
            length2, length3), storage_);

        if (numElements())
        {
            Range overlap0 = Range(fromStart, minmax::min(B.ubound(0), ubound(0)));
            Range overlap1 = Range(fromStart, minmax::min(B.ubound(1), ubound(1)));
            Range overlap2 = Range(fromStart, minmax::min(B.ubound(2), ubound(2)));
            Range overlap3 = Range(fromStart, minmax::min(B.ubound(3), ubound(3)));
            B(overlap0, overlap1, overlap2, overlap3) = (*this)(overlap0,
                overlap1, overlap2, overlap3);
        }
        reference(B);
    }
}

template<class T_numtype, int N_rank>
void Array<T_numtype, N_rank>::resizeAndPreserve(int length0, int length1,
    int length2, int length3, int length4)
{
     ;

     ;

    if ((length0 != length_[0]) || (length1 != length_[1])
        || (length2 != length_[2]) || (length3 != length_[3])
        || (length4 != length_[4]))
    {
        T_array B(base(), blitz:: shape  (length0, length1, 
            length2, length3, length4), storage_);

        if (numElements())
        {
            Range overlap0 = Range(fromStart, minmax::min(B.ubound(0), ubound(0)));
            Range overlap1 = Range(fromStart, minmax::min(B.ubound(1), ubound(1)));
            Range overlap2 = Range(fromStart, minmax::min(B.ubound(2), ubound(2)));
            Range overlap3 = Range(fromStart, minmax::min(B.ubound(3), ubound(3)));
            Range overlap4 = Range(fromStart, minmax::min(B.ubound(4), ubound(4)));
            B(overlap0, overlap1, overlap2, overlap3, overlap4) = (*this)
                (overlap0, overlap1, overlap2, overlap3, overlap4);
        }
        reference(B);
    }
}

template<class T_numtype, int N_rank>
void Array<T_numtype, N_rank>::resizeAndPreserve(int length0, int length1,
    int length2, int length3, int length4, int length5)
{
     ;

     ;

    if ((length0 != length_[0]) || (length1 != length_[1])
        || (length2 != length_[2]) || (length3 != length_[3])
        || (length4 != length_[4]) || (length5 != length_[5]))
    {
        T_array B(base(), blitz:: shape  (length0, length1, length2, 
            length3, length4, length5), storage_);

        if (numElements())
        {
            Range overlap0 = Range(fromStart, minmax::min(B.ubound(0), ubound(0)));
            Range overlap1 = Range(fromStart, minmax::min(B.ubound(1), ubound(1)));
            Range overlap2 = Range(fromStart, minmax::min(B.ubound(2), ubound(2)));
            Range overlap3 = Range(fromStart, minmax::min(B.ubound(3), ubound(3)));
            Range overlap4 = Range(fromStart, minmax::min(B.ubound(4), ubound(4)));
            Range overlap5 = Range(fromStart, minmax::min(B.ubound(5), ubound(5)));
            B(overlap0, overlap1, overlap2, overlap3, overlap4, overlap5)
                = (*this)(overlap0, overlap1, overlap2, overlap3, overlap4,
                overlap5);
        }
        reference(B);
    }
}


 

template<class T_numtype, int N_rank>
void Array<T_numtype, N_rank>::resize(const TinyVector<int,N_rank>& extent)
{
 
 
 
 
        length_ = extent;
        setupStorage(N_rank);
 
}

} 


# 2476 "../blitz/array.h" 2

# 1 "../blitz/array/slicing.cc" 1







namespace  blitz  { 

 




template<class P_numtype, int N_rank>
void Array<P_numtype, N_rank>::constructSubarray(
    Array<T_numtype, N_rank>& array, const RectDomain<N_rank>& subdomain)
{
    reference(array);
    for (int i=0; i < N_rank; ++i)
        slice(i, subdomain[i]);
}

template<class P_numtype, int N_rank>
void Array<P_numtype, N_rank>::constructSubarray(
    Array<T_numtype, N_rank>& array, Range r0)
{
    reference(array);
    slice(0, r0);
}

template<class P_numtype, int N_rank>
void Array<P_numtype, N_rank>::constructSubarray(
    Array<T_numtype, N_rank>& array, Range r0, Range r1)
{
    reference(array);
    slice(0, r0);
    slice(1, r1);
}

template<class P_numtype, int N_rank>
void Array<P_numtype, N_rank>::constructSubarray(
    Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2)
{
    reference(array);
    slice(0, r0);
    slice(1, r1);
    slice(2, r2);
}

template<class P_numtype, int N_rank>
void Array<P_numtype, N_rank>::constructSubarray(
    Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2, Range r3)
{
    reference(array);
    slice(0, r0);
    slice(1, r1);
    slice(2, r2);
    slice(3, r3);
}

template<class P_numtype, int N_rank>
void Array<P_numtype, N_rank>::constructSubarray(
    Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2, Range r3,
    Range r4)
{
    reference(array);
    slice(0, r0);
    slice(1, r1);
    slice(2, r2);
    slice(3, r3);
    slice(4, r4);
}

template<class P_numtype, int N_rank>
void Array<P_numtype, N_rank>::constructSubarray(
    Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2, Range r3,
    Range r4, Range r5)
{
    reference(array);
    slice(0, r0);
    slice(1, r1);
    slice(2, r2);
    slice(3, r3);
    slice(4, r4);
    slice(5, r5);
}

template<class P_numtype, int N_rank>
void Array<P_numtype, N_rank>::constructSubarray(
    Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2, Range r3,
    Range r4, Range r5, Range r6)
{
    reference(array);
    slice(0, r0);
    slice(1, r1);
    slice(2, r2);
    slice(3, r3);
    slice(4, r4);
    slice(5, r5);
    slice(6, r6);
}

template<class P_numtype, int N_rank>
void Array<P_numtype, N_rank>::constructSubarray(
    Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2, Range r3,
    Range r4, Range r5, Range r6, Range r7)
{
    reference(array);
    slice(0, r0);
    slice(1, r1);
    slice(2, r2);
    slice(3, r3);
    slice(4, r4);
    slice(5, r5);
    slice(6, r6);
    slice(7, r7);
}

template<class P_numtype, int N_rank>
void Array<P_numtype, N_rank>::constructSubarray(
    Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2, Range r3,
    Range r4, Range r5, Range r6, Range r7, Range r8)
{
    reference(array);
    slice(0, r0);
    slice(1, r1);
    slice(2, r2);
    slice(3, r3);
    slice(4, r4);
    slice(5, r5);
    slice(6, r6);
    slice(7, r7);
    slice(8, r8);
}

template<class P_numtype, int N_rank>
void Array<P_numtype, N_rank>::constructSubarray(
    Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2, Range r3,
    Range r4, Range r5, Range r6, Range r7, Range r8, Range r9)
{
    reference(array);
    slice(0, r0);
    slice(1, r1);
    slice(2, r2);
    slice(3, r3);
    slice(4, r4);
    slice(5, r5);
    slice(6, r6);
    slice(7, r7);
    slice(8, r8);
    slice(9, r9);
}

template<class P_numtype, int N_rank>
void Array<P_numtype, N_rank>::constructSubarray(
    Array<T_numtype, N_rank>& array, Range r0, Range r1, Range r2, Range r3,
    Range r4, Range r5, Range r6, Range r7, Range r8, Range r9, Range r10)
{
    reference(array);
    slice(0, r0);
    slice(1, r1);
    slice(2, r2);
    slice(3, r3);
    slice(4, r4);
    slice(5, r5);
    slice(6, r6);
    slice(7, r7);
    slice(8, r8);
    slice(9, r9);
    slice(10, r10);
}

 




template<class P_numtype, int N_rank> template<int N_rank2, class R0,
    class R1, class R2, class R3, class R4, class R5, class R6, class R7,
    class R8, class R9, class R10>
void Array<P_numtype, N_rank>::constructSlice(Array<T_numtype, N_rank2>& array,
    R0 r0, R1 r1, R2 r2, R3 r3, R4 r4, R5 r5, R6 r6, R7 r7, R8 r8, R9 r9,
    R10 r10)
{
    MemoryBlockReference<P_numtype>::changeBlock(array, array.zeroOffset());
    data_ = array.dataZero();

    int setRank = 0;

    TinyVector<int, N_rank2> rankMap;

    slice(setRank, r0, array, rankMap, 0);
    slice(setRank, r1, array, rankMap, 1);
    slice(setRank, r2, array, rankMap, 2);
    slice(setRank, r3, array, rankMap, 3);
    slice(setRank, r4, array, rankMap, 4);
    slice(setRank, r5, array, rankMap, 5);
    slice(setRank, r6, array, rankMap, 6);
    slice(setRank, r7, array, rankMap, 7);
    slice(setRank, r8, array, rankMap, 8);
    slice(setRank, r9, array, rankMap, 9);
    slice(setRank, r10, array, rankMap, 10);

     
     
    int j = 0;
    for (int i=0; i < N_rank2; ++i)
    {
        if (rankMap[array.ordering(i)] != -1)
            storage_.setOrdering(j++, rankMap[array.ordering(i)]);
    }

    calculateZeroOffset();
}

 





template<class T_numtype, int N_rank> template<int N_rank2>
void Array<T_numtype, N_rank>::slice(int& setRank, Range r,
    Array<T_numtype,N_rank2>& array, TinyVector<int,N_rank2>& rankMap,
    int sourceRank)
{
     
     







    rankMap[sourceRank] = setRank;
    length_[setRank] = array.length(sourceRank);
    stride_[setRank] = array.stride(sourceRank);
    storage_.setAscendingFlag(setRank, array.isRankStoredAscending(sourceRank));
    storage_.setBase(setRank, array.base(sourceRank));
    slice(setRank, r);
    ++setRank;
}

 





template<class T_numtype, int N_rank> template<int N_rank2>
void Array<T_numtype, N_rank>::slice(int& setRank, int i,
    Array<T_numtype,N_rank2>& array, TinyVector<int,N_rank2>& rankMap,
    int sourceRank)
{






     ;




    rankMap[sourceRank] = -1;
    data_ += i * array.stride(sourceRank);



}

 






template<class P_numtype, int N_rank>
void Array<P_numtype, N_rank>::slice(int rank, Range r)
{
     ;

    int first = r.first(lbound(rank));
    int last  = r.last(ubound(rank));
    int stride = r.stride();







     ;








     
     
     
     

    length_[rank] = (last - first) / stride + 1;

    int offset = (first - base(rank)) * stride_[rank];
    data_ += offset;
    zeroOffset_ -= offset;

    stride_[rank] *= stride;
}

} 


# 2477 "../blitz/array.h" 2

# 1 "../blitz/array/cycle.cc" 1







namespace  blitz  { 

template<class T_numtype, int N_rank>
void cycleArrays(Array<T_numtype, N_rank>& a, Array<T_numtype, N_rank>& b)
{
    Array<T_numtype, N_rank> tmp(a);
    a.reference(b);
    b.reference(tmp);
}

template<class T_numtype, int N_rank>
void cycleArrays(Array<T_numtype, N_rank>& a, Array<T_numtype, N_rank>& b,
    Array<T_numtype, N_rank>& c)
{
    Array<T_numtype, N_rank> tmp(a);
    a.reference(b);
    b.reference(c);
    c.reference(tmp);
}

template<class T_numtype, int N_rank>
void cycleArrays(Array<T_numtype, N_rank>& a, Array<T_numtype, N_rank>& b,
    Array<T_numtype, N_rank>& c, Array<T_numtype, N_rank>& d)
{
    Array<T_numtype, N_rank> tmp(a);
    a.reference(b);
    b.reference(c);
    c.reference(d);
    d.reference(tmp);
}

template<class T_numtype, int N_rank>
void cycleArrays(Array<T_numtype, N_rank>& a, Array<T_numtype, N_rank>& b,
    Array<T_numtype, N_rank>& c, Array<T_numtype, N_rank>& d,
    Array<T_numtype, N_rank>& e)
{
    Array<T_numtype, N_rank> tmp(a);
    a.reference(b);
    b.reference(c);
    c.reference(d);
    d.reference(e);
    e.reference(tmp);
}

} 


# 2478 "../blitz/array.h" 2

# 1 "../blitz/array/complex.cc" 1
 








namespace  blitz  { 



template<class T_numtype, int N_rank>
inline Array<T_numtype, N_rank> real(const Array<complex<T_numtype>,N_rank>& A)
{
    return A.extractComponent(T_numtype(), 0, 2);
}

template<class T_numtype, int N_rank>
inline Array<T_numtype, N_rank> imag(const Array<complex<T_numtype>,N_rank>& A)
{
    return A.extractComponent(T_numtype(), 1, 2);
}




} 



# 2479 "../blitz/array.h" 2

# 1 "../blitz/array/zip.h" 1







namespace  blitz  { 

template<class P_component, class T1, class T2>
struct Zip2 {
    typedef P_component T_numtype;

    static inline T_numtype apply(T1 a, T2 b)
    { return T_numtype(a,b); }

    template<class T_left, class T_right>
    static inline void prettyPrint(string& str,
        prettyPrintFormat& format, const T_left& t1,
        const T_right& t2)
    {
        str += "zip(";
        t1.prettyPrint(str, format);
        str += ",";
        t2.prettyPrint(str, format);
        str += ")";
    }
};

template<class T_component, class T1, class T2>
inline _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr, 
    typename  asExpr<T2>::T_expr, Zip2<T_component, 
    typename  asExpr<T1>::T_expr::T_numtype,
    typename  asExpr<T2>::T_expr::T_numtype> > >
zip(const T1& a, const T2& b, T_component)
{
    return _bz_ArrayExpr<_bz_ArrayExprOp< typename  asExpr<T1>::T_expr,
        typename  asExpr<T2>::T_expr, Zip2<T_component, 
        typename  asExpr<T1>::T_expr::T_numtype,
        typename  asExpr<T2>::T_expr::T_numtype> > >(a,b);
}

} 



# 2480 "../blitz/array.h" 2

# 1 "../blitz/array/where.h" 1







namespace  blitz  { 

template<class P_expr1, class P_expr2, class P_expr3>
class _bz_ArrayWhere {

public:
    typedef P_expr1 T_expr1;
    typedef P_expr2 T_expr2;
    typedef P_expr3 T_expr3;
    typedef typename  T_expr2::T_numtype T_numtype2;
    typedef typename  T_expr3::T_numtype T_numtype3;
    typedef typename  promote_trait< T_numtype2 ,  T_numtype3 >::T_promote  T_numtype;
    typedef T_expr1 T_ctorArg1;
    typedef T_expr2 T_ctorArg2;
    typedef T_expr3 T_ctorArg3;

    enum { numArrayOperands = (int) P_expr1::numArrayOperands  
                            + (int) P_expr2::numArrayOperands  
                            + (int) P_expr3::numArrayOperands  ,
           numIndexPlaceholders = (int) P_expr1::numIndexPlaceholders  
                            + (int) P_expr2::numIndexPlaceholders  
                            + (int) P_expr3::numIndexPlaceholders  ,
           rank = _bz_meta_max<_bz_meta_max<P_expr1::rank,P_expr2::rank>::max,
                            P_expr3::rank>::max
    };

    _bz_ArrayWhere(const _bz_ArrayWhere<T_expr1,T_expr2,T_expr3>& a)
      : iter1_(a.iter1_), iter2_(a.iter2_), iter3_(a.iter3_)
    { }

    template<class T1, class T2, class T3>
    _bz_ArrayWhere(const  T1 &  a, const  T2 &  b, const  T3 &  c)
      : iter1_(a), iter2_(b), iter3_(c)
    { }

    T_numtype operator*()
    { return (*iter1_) ? (*iter2_) : (*iter3_); }

    template<int N_rank>
    T_numtype operator()(const TinyVector<int, N_rank>& i)
    { return iter1_(i) ? iter2_(i) : iter3_(i); }

    int lbound(int rank)
    {
        return bounds::compute_lbound(rank, bounds::compute_lbound(
          rank, iter1_.lbound(rank), iter2_.lbound(rank)), 
          iter3_.lbound(rank));
    }
   
    int ubound(int rank)
    {
        return bounds::compute_ubound(rank, bounds::compute_ubound(
          rank, iter1_.ubound(rank), iter2_.ubound(rank)), 
          iter3_.ubound(rank));
    } 

    void push(int position)
    {
        iter1_.push(position);
        iter2_.push(position);
        iter3_.push(position);
    }

    void pop(int position)
    {
        iter1_.pop(position);
        iter2_.pop(position);
        iter3_.pop(position);
    }

    void advance()
    {
        iter1_.advance();
        iter2_.advance();
        iter3_.advance();
    }

    void advance(int n)
    {
        iter1_.advance(n);
        iter2_.advance(n);
        iter3_.advance(n);
    }

    void loadStride(int rank)
    {
        iter1_.loadStride(rank);
        iter2_.loadStride(rank);
        iter3_.loadStride(rank);
    }

    bool  isUnitStride(int rank) const
    { 
        return iter1_.isUnitStride(rank) 
            && iter2_.isUnitStride(rank) 
            && iter3_.isUnitStride(rank);
    }

    void advanceUnitStride()
    {
        iter1_.advanceUnitStride();
        iter2_.advanceUnitStride();
        iter3_.advanceUnitStride();
    }

    bool  canCollapse(int outerLoopRank, int innerLoopRank) const
    {
         
        return iter1_.canCollapse(outerLoopRank, innerLoopRank)
            && iter2_.canCollapse(outerLoopRank, innerLoopRank)
            && iter3_.canCollapse(outerLoopRank, innerLoopRank);
    }

    template<int N_rank>
    void moveTo(const TinyVector<int,N_rank>& i)
    {
        iter1_.moveTo(i);
        iter2_.moveTo(i);
        iter3_.moveTo(i);
    }

    T_numtype operator[](int i)
    { return iter1_[i] ? iter2_[i] : iter3_[i]; }

    T_numtype fastRead(int i)
    { return iter1_.fastRead(i) ? iter2_.fastRead(i) : iter3_.fastRead(i); }

    int suggestStride(int rank) const
    {
        int stride1 = iter1_.suggestStride(rank);
        int stride2 = iter2_.suggestStride(rank);
        int stride3 = iter3_.suggestStride(rank);
        return minmax::max(minmax::max(stride1,stride2),stride3);
    }

    bool  isStride(int rank, int stride) const
    {
        return iter1_.isStride(rank,stride) 
            && iter2_.isStride(rank,stride)
            && iter3_.isStride(rank,stride);
    }

    void prettyPrint(string& str, prettyPrintFormat& format) const
    {
        str += "where(";
        iter1_.prettyPrint(str,format);
        str += ",";
        iter2_.prettyPrint(str,format);
        str += ",";
        iter3_.prettyPrint(str,format);
        str += ")";
    }

    template<class T_shape>
    bool  shapeCheck(const T_shape& shape)
    { 
        int t1 = iter1_.shapeCheck(shape);
        int t2 = iter2_.shapeCheck(shape);
        int t3 = iter3_.shapeCheck(shape);

        return t1 && t2 && t3;
    }

private:
    _bz_ArrayWhere() { }

    T_expr1 iter1_;
    T_expr2 iter2_;
    T_expr3 iter3_;
};

template<class T1, class T2, class T3>
inline
_bz_ArrayExpr<_bz_ArrayWhere< typename  asExpr<T1>::T_expr,
    typename  asExpr<T2>::T_expr, typename  asExpr<T3>::T_expr> >
where(const T1& a, const T2& b, const T3& c)
{
    return _bz_ArrayExpr<_bz_ArrayWhere< typename  asExpr<T1>::T_expr,
       typename  asExpr<T2>::T_expr, 
       typename  asExpr<T3>::T_expr> >(a,b,c);
}

} 



# 2481 "../blitz/array.h" 2

# 1 "../blitz/array/stencil.h" 1







# 1 "../blitz/array/stencilops.h" 1



 
 






 
# 1 "../blitz/array/geometry.h" 1







namespace  blitz  { 

typedef double T_defaultSpatialCoordinate;

template<int N_dim, class T = T_defaultSpatialCoordinate>
class UniformOrthoGeometry {
public:
};

template<int N_dim, class T = T_defaultSpatialCoordinate>
class UniformCubicGeometry {
    T h_;
    T recip_h_;
    T recip2_h_;
    T recip3_h_;
    TinyVector<T,N_dim> zero_;

public:
    typedef T T_coord;

    UniformCubicGeometry()
    {
        h_ = 0.0;
        recip_h_ = 0.0;
        recip2_h_ = 0.0;
        recip3_h_ = 0.0;
        zero_ = 0.0;
    }

    UniformCubicGeometry(T spatialStep)
    {
        h_ = spatialStep;
        zero_ = T(0);
        setup();
    }

    UniformCubicGeometry(T spatialStep, TinyVector<T,N_dim> zeroCoordinates)
    {   
        h_ = spatialStep;
        zero_ = zeroCoordinates;
        setup();
    }    

    TinyVector<T,N_dim> toSpatial(TinyVector<int,N_dim> logicalCoord) const
    {
        return zero_ + h_ * logicalCoord;
    }

    T spatialStep() const
    { return h_; }

    T recipSpatialStep() const
    { return recip_h_; }

    T recipSpatialStepPow2() const
    { return recip2_h_; }

private:
    void setup()
    {
        recip_h_ = 1.0 / h_;
        recip2_h_ = 1.0 / pow2(h_);
        recip3_h_ = 1.0 / pow3(h_);
    }
};

template<int N_dim, class T = T_defaultSpatialCoordinate>
class TensorProductGeometry {
public:
};

} 


# 12 "../blitz/array/stencilops.h" 2




 
# 1 "../blitz/tinymat.h" 1
 















































# 1 "../blitz/tinymatexpr.h" 1
 







































namespace  blitz  { 

template<class T_expr>
class _bz_tinyMatExpr {
public:
    typedef typename  T_expr::T_numtype T_numtype;

    enum {
        rows = T_expr::rows,
        columns = T_expr::columns
    };

    _bz_tinyMatExpr(T_expr expr)
        : expr_(expr)
    { }

    _bz_tinyMatExpr(const _bz_tinyMatExpr<T_expr>& x)
        : expr_(x.expr_)
    { }

    T_numtype operator()(int i, int j) const
    { return expr_(i,j); }

protected:
    T_expr expr_;
};

} 



# 49 "../blitz/tinymat.h" 2

# 1 "../blitz/meta/matassign.h" 1
 




































namespace  blitz  { 

template<int N_rows, int N_columns, int I, int J>
class _bz_meta_matAssign2 {
public:
    enum { go = (J < N_columns - 1) ? 1 : 0 };

    template<class T_matrix, class T_expr, class T_updater>
    static inline void f(T_matrix& mat, T_expr expr, T_updater u)
    {
        u.update(mat(I,J), expr(I,J));
        _bz_meta_matAssign2<N_rows * go, N_columns * go, I * go, (J+1) * go>
            ::f(mat, expr, u);
    }
};

template<>
class _bz_meta_matAssign2<0,0,0,0> {
public:
    template<class T_matrix, class T_expr, class T_updater>
    static inline void f(T_matrix& mat, T_expr expr, T_updater u)
    { }
};

template<int N_rows, int N_columns, int I> 
class _bz_meta_matAssign {
public:
    enum { go = (I < N_rows-1) ? 1 : 0 };

    template<class T_matrix, class T_expr, class T_updater>
    static inline void f(T_matrix& mat, T_expr expr, T_updater u)
    {
        _bz_meta_matAssign2<N_rows, N_columns, I, 0>::f(mat, expr, u);
        _bz_meta_matAssign<N_rows * go, N_columns * go, (I+1) * go>
            ::f(mat, expr, u);
    }
};

template<>
class _bz_meta_matAssign<0,0,0> {
public:
    template<class T_matrix, class T_expr, class T_updater>
    static inline void f(T_matrix& mat, T_expr expr, T_updater u)
    { }
};


} 


# 50 "../blitz/tinymat.h" 2


namespace  blitz  { 

 
template<class T_expr>
class _bz_tinyMatExpr;

template<class T_numtype, int N_rows, int N_columns, int N_rowStride,
    int N_colStride>
class _bz_tinyMatrixRef {

public:
    _bz_tinyMatrixRef(T_numtype*   const data)
        : data_(data)
    { }

    T_numtype *   data()
    { return (T_numtype *  )data_; }

    T_numtype&   operator()(int i, int j)
    { return data_[i * N_rowStride + j * N_colStride]; }

    T_numtype operator()(int i, int j) const
    { return data_[i * N_rowStride + j * N_colStride]; }

protected:
    T_numtype *   const data_;
};

template<class P_numtype, int N_rows, int N_columns>
class TinyMatrix {

public:
    typedef P_numtype T_numtype;
    typedef _bz_tinyMatrixRef<T_numtype, N_rows, N_columns, N_columns, 1> 
        T_reference;
    typedef TinyMatrix<T_numtype, N_rows, N_columns> T_matrix;

    TinyMatrix() { }

    T_numtype*   data()
    { return data_; }

    const T_numtype*   data() const
    { return data_; }

    T_numtype*   dataFirst()
    { return data_; }

    const T_numtype*   dataFirst() const
    { return data_; }

     
    T_numtype&   operator()(int i, int j)
    { return data_[i*N_columns + j]; }

    T_numtype operator()(int i, int j) const
    { return data_[i*N_columns + j]; }

    T_reference getRef()
    { return T_reference((T_numtype*)data_); }

    const T_reference getRef() const
    { return T_reference((T_numtype*)data_); }

     
    ListInitializationSwitch<T_matrix>
    operator=(T_numtype x)
    {
        return ListInitializationSwitch<T_matrix>(*this, x);
    }

    template<class T_expr>
    TinyMatrix<T_numtype, N_rows, N_columns>&
    operator=(_bz_tinyMatExpr<T_expr> expr)
    {
        _bz_meta_matAssign<N_rows, N_columns, 0>::f(*this, expr,
            _bz_update<T_numtype, typename  T_expr::T_numtype>());
        return *this;
    }

    void initialize(T_numtype x)
    { 
        for (int i=0; i < N_rows; ++i)
          for (int j=0; j < N_columns; ++j)
            (*this)(i,j) = x;
    }

    T_numtype*   getInitializationIterator()
    { return dataFirst(); }

protected:
    T_numtype data_[N_rows * N_columns];
};

} 

# 1 "../blitz/meta/matvec.h" 1
 















































 


namespace  blitz  { 

 
template<int N_rows, int N_columns, int N_rowStride, int N_colStride,
    int N_vecStride, int J>
class _bz_meta_matrixVectorProduct2;


template<class T_numtype1, class T_numtype2, int N_rows, int N_columns, 
    int N_rowStride, int N_colStride, int N_vecStride>
class _bz_tinyMatrixVectorProduct {
public:
    typedef typename  promote_trait< T_numtype1 ,  T_numtype2 >::T_promote  T_numtype;
    
    _bz_tinyMatrixVectorProduct(const _bz_tinyMatrixVectorProduct<T_numtype1,
        T_numtype2, N_rows, N_columns, N_rowStride, N_colStride, 
        N_vecStride>& z)
            : matrix_(z.matrix_), vector_(z.vector_)
    { }

    _bz_tinyMatrixVectorProduct(const T_numtype1* matrix, 
        const T_numtype2* vector)
        : matrix_(matrix), vector_(vector)
    { }

    T_numtype operator[](unsigned i) const
    {
        return _bz_meta_matrixVectorProduct2<N_rows, N_columns, N_rowStride,
            N_colStride, N_vecStride, 0>::f(matrix_, vector_, i);
    }

    T_numtype operator()(unsigned i) const
    {
        return _bz_meta_matrixVectorProduct2<N_rows, N_columns, N_rowStride,
            N_colStride, N_vecStride, 0>::f(matrix_, vector_, i);
    }

    enum {
        _bz_staticLengthCount = 1,
        _bz_dynamicLengthCount = 0,
        _bz_staticLength = N_rows







    };

    unsigned _bz_suggestLength() const
    {
        return N_rows;
    }

    bool  _bz_hasFastAccess() const
    { return true ; }

    T_numtype _bz_fastAccess(unsigned i) const
    {
        return _bz_meta_matrixVectorProduct2<N_rows, N_columns, N_rowStride,
            N_colStride, N_vecStride, 0>::f(matrix_, vector_, i);
    }

    unsigned length(unsigned recommendedLength) const
    { return N_rows; }

    const T_numtype1* matrix() const
    { return matrix_; }

    const T_numtype2* vector() const
    { return vector_; }

protected:
    const T_numtype1* matrix_;
    const T_numtype2* vector_;
};

template<class T_numtype1, class T_numtype2, int N_rows, int N_columns>
inline _bz_VecExpr<_bz_tinyMatrixVectorProduct<T_numtype1, T_numtype2, 
    N_rows, N_columns, N_columns, 1, 1> >
product(const TinyMatrix<T_numtype1, N_rows, N_columns>& matrix,
    const TinyVector<T_numtype2, N_columns>& vector)
{
    typedef _bz_tinyMatrixVectorProduct<T_numtype1, T_numtype2, N_rows, 
        N_columns, N_columns, 1, 1> T_expr;
    return _bz_VecExpr<T_expr>(T_expr(matrix.data(), vector.data()));
}

 

template<int N_rows, int N_columns, int N_rowStride, int N_colStride,
    int N_vecStride, int J>
class _bz_meta_matrixVectorProduct2 {

public:
    enum { go = J < (N_columns-1) };
   
    template<class T_numtype1, class T_numtype2> 
    static inline typename  promote_trait< T_numtype1 ,  T_numtype2 >::T_promote 
    f(const T_numtype1* matrix, const T_numtype2* vector, int i)
    {
        return matrix[i * N_rowStride + J * N_colStride]
            * vector[J * N_vecStride]

            + _bz_meta_matrixVectorProduct2<N_rows * go, N_columns * go,
                N_rowStride * go, N_colStride * go, N_vecStride * go, (J+1)*go>
                ::f(matrix, vector, i);
    }
    
};

template<>
class _bz_meta_matrixVectorProduct2<0,0,0,0,0,0> {
public:
    static inline _bz_meta_nullOperand f(const void*, const void*, int)
    { return _bz_meta_nullOperand(); }
};

template<int N_rows, int N_columns, int N_rowStride, int N_colStride,
    int N_vecStride, int I>
class _bz_meta_matrixVectorProduct {
public:
    enum { go = I < (N_rows - 1) };

    template<class T_numtype1, class T_numtype2, class T_numtype3>
    static inline void f(TinyVector<T_numtype3, N_rows>& result,
        const T_numtype1* matrix, const T_numtype2* vector)
    {
        result[I] = _bz_meta_matrixVectorProduct2<N_rows, N_columns,
            N_rowStride, N_colStride, N_vecStride, 0>::f(matrix,vector, I);

        _bz_meta_matrixVectorProduct<N_rows * go, N_columns * go,
            N_rowStride * go, N_colStride * go, N_vecStride * go, (I+1)*go>
              ::f(result, matrix, vector);
    }
};

template<>
class _bz_meta_matrixVectorProduct<0,0,0,0,0,0> {
public:
    static inline void f(const _bz_tinyBase&, const void*, const void*)
    { }
};

} 



# 148 "../blitz/tinymat.h" 2

# 1 "../blitz/meta/matmat.h" 1
 













































namespace  blitz  { 

 
template<int N_rows1, int N_columns, int N_columns2, int N_rowStride1,
    int N_colStride1, int N_rowStride2, int N_colStride2, int K>
class _bz_meta_matrixMatrixProduct {
public:
    enum { go = (K != N_columns - 1) };

    template<class T_numtype1, class T_numtype2>
    static inline typename  promote_trait< T_numtype1 ,  T_numtype2 >::T_promote 
    f(const T_numtype1* matrix1, const T_numtype2* matrix2, int i, int j)
    {
        return matrix1[i * N_rowStride1 + K * N_colStride1]
            * matrix2[K * N_rowStride2 + j * N_colStride2]
            + _bz_meta_matrixMatrixProduct<N_rows1 * go, N_columns * go,
                N_columns2 * go, N_rowStride1 * go, N_colStride1 * go,
                N_rowStride2 * go, N_colStride2 * go, (K+1) * go>
              ::f(matrix1, matrix2, i, j);
    }
};

template<>
class _bz_meta_matrixMatrixProduct<0,0,0,0,0,0,0,0> {
public:
    static inline _bz_meta_nullOperand f(const void*, const void*, int, int)
    { return _bz_meta_nullOperand(); }
};




template<class T_numtype1, class T_numtype2, int N_rows1, int N_columns,
    int N_columns2, int N_rowStride1, int N_colStride1,
    int N_rowStride2, int N_colStride2>
class _bz_tinyMatrixMatrixProduct {
public:
    typedef typename  promote_trait< T_numtype1 ,  T_numtype2 >::T_promote  T_numtype;

    enum { rows = N_rows1, columns = N_columns2 };

    _bz_tinyMatrixMatrixProduct(const T_numtype1* matrix1,
        const T_numtype2* matrix2)
        : matrix1_(matrix1), matrix2_(matrix2)
    { }

    _bz_tinyMatrixMatrixProduct(const _bz_tinyMatrixMatrixProduct<T_numtype1,
        T_numtype2, N_rows1, N_columns, N_columns2, N_rowStride1, N_colStride1,
        N_rowStride2, N_colStride2>& x)
        : matrix1_(x.matrix1_), matrix2_(x.matrix2_)
    { }

    const T_numtype1* matrix1() const
    { return matrix1_; }

    const T_numtype2* matrix2() const
    { return matrix2_; }

    T_numtype operator()(int i, int j) const
    {
        return _bz_meta_matrixMatrixProduct<N_rows1, N_columns,
            N_columns2, N_rowStride1, N_colStride1, N_rowStride2,
            N_colStride2, 0>::f(matrix1_, matrix2_, i, j);
    }

protected:
    const T_numtype1* matrix1_;
    const T_numtype2* matrix2_;    
};

template<class T_numtype1, class T_numtype2, int N_rows1, int N_columns1,
    int N_columns2>
inline
_bz_tinyMatExpr<_bz_tinyMatrixMatrixProduct<T_numtype1, T_numtype2, N_rows1, 
    N_columns1, N_columns2, N_columns1, 1, N_columns2, 1> >
product(const TinyMatrix<T_numtype1, N_rows1, N_columns1>& a,
    const TinyMatrix<T_numtype2, N_columns1, N_columns2>& b)
{
    typedef _bz_tinyMatrixMatrixProduct<T_numtype1, T_numtype2,
        N_rows1, N_columns1, N_columns2, N_columns1, 1, N_columns2, 1> T_expr;
    return _bz_tinyMatExpr<T_expr>(T_expr(a.data(), b.data()));
}

} 



# 149 "../blitz/tinymat.h" 2




# 16 "../blitz/array/stencilops.h" 2



namespace  blitz  { 


















 
const double recip_2 = .500000000000000000000000000000000000000000000;
const double recip_4 = .250000000000000000000000000000000000000000000;
const double recip_6 = .166666666666666666666666666666666666666666667;
const double recip_8 = .125000000000000000000000000000000000000000000;
const double recip_12 = .0833333333333333333333333333333333333333333333;
const double recip_144 = .00694444444444444444444444444444444444444444444;

 



template<class T> inline typename  T::T_numtype  Laplacian2D (T&   A ) { 
    return -4.0 * A + A.shift(-1,0) + A.shift(1,0) + A.shift(-1,1)
      + A.shift(1,1);
} 

template<class T> inline typename  T::T_numtype  Laplacian3D (T&   A ) { 
    return -6.0 * A 
      + A.shift(-1,0) + A.shift(1,0) 
      + A.shift(-1,1) + A.shift(1,1)
      + A.shift(-1,2) + A.shift(1,2);
} 

template<class T> inline typename  T::T_numtype  Laplacian2D4 (T&   A ) { 
    return -60. * A 
      + 16.*(A.shift(-1,0) + A.shift(1,0) + A.shift(-1,1) + A.shift(1,1))
      -     (A.shift(-2,0) + A.shift(2,0) + A.shift(-2,1) + A.shift(2,1));
} 

template<class T> inline typename  T::T_numtype  Laplacian2D4n (T&   A ) { 
    return Laplacian2D4(A) * recip_12;
} 

template<class T> inline typename  T::T_numtype  Laplacian3D4 (T&   A ) { 
    return -90. * A 
      + 16.*(A.shift(-1,0) + A.shift(1,0) + A.shift(-1,1) + A.shift(1,1)
           + A.shift(-1,2) + A.shift(1,2))
      -     (A.shift(-2,0) + A.shift(2,0) + A.shift(-2,1) + A.shift(2,1)
           + A.shift(-2,2) + A.shift(2,2));
} 

template<class T> inline typename  T::T_numtype  Laplacian3D4n (T&   A ) { 
    return Laplacian3D4(A) * recip_12;
} 

 












 



template<class T> inline typename  T::T_numtype  central12 (T& A, int dim = firstDim)  {
  return A.shift(1,dim) - A.shift(-1,dim);
}

template<class T> inline typename  T::T_numtype  central22 (T& A, int dim = firstDim)  {
  return A.shift(-1,dim) - 2. * A + A.shift(+1,dim);
}

template<class T> inline typename  T::T_numtype  central32 (T& A, int dim = firstDim)  {
  return -A.shift(-2,dim) + 2.*(A.shift(-1,dim) - A.shift(+1,dim))
    + A.shift(+2,dim);
}

template<class T> inline typename  T::T_numtype  central42 (T& A, int dim = firstDim)  {
  return A.shift(-2,dim) + A.shift(2,dim) -4.*(A.shift(-1,dim)+A.shift(+1,dim)) 
    +6.*A.shift(0,dim);
}

 



template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  central12 (T& A, int comp, int dim)  {
  return A.shift(1,dim)[comp] - A.shift(-1,dim)[comp];
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  central22 (T& A, int comp, int dim)  {
  return A.shift(-1,dim)[comp] - 2. * (*A)[comp] + A.shift(+1,dim)[comp];
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  central32 (T& A, int comp, int dim)  {
  return -A.shift(-2,dim)[comp] + 2.*A.shift(-1,dim)[comp] 
    -2.*A.shift(+1,dim)[comp] + A.shift(+2,dim)[comp];
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  central42 (T& A, int comp, int dim)  {
  return A.shift(-2,dim)[comp] -4.*A.shift(-1,dim)[comp] 
    +6.*A.shift(0,dim)[comp] -4.*A.shift(1,dim)[comp] +A.shift(2,dim)[comp];
}

 



template<class T> inline typename  T::T_numtype  central12n (T& A, int dim = firstDim)  {
  return central12(A,dim) * recip_2;
}

template<class T> inline typename  T::T_numtype  central22n (T& A, int dim = firstDim)  {
  return central22(A,dim);
}

template<class T> inline typename  T::T_numtype  central32n (T& A, int dim = firstDim)  {
  return central32(A,dim) * recip_2;
}

template<class T> inline typename  T::T_numtype  central42n (T& A, int dim = firstDim)  {
  return central42(A,dim);
}

 



template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  central12n (T& A, int comp, int dim)  {
  return central12(A,comp,dim) * recip_2;
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  central22n (T& A, int comp, int dim)  {
  return central22(A,comp,dim);
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  central32n (T& A, int comp, int dim)  {
  return central32(A,comp,dim) * recip_2;
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  central42n (T& A, int comp, int dim)  {
  return central42(A,comp,dim);
}

 



template<class T> inline typename  T::T_numtype  central14 (T& A, int dim = firstDim)  {
  return (A.shift(-2,dim) - A.shift(2,dim)) 
     + 8.*(A.shift(1,dim)-A.shift(-1,dim));
}

template<class T> inline typename  T::T_numtype  central24 (T& A, int dim = firstDim)  {
  return -30.*A + 16.*(A.shift(-1,dim)+A.shift(1,dim))
    - (A.shift(-2,dim)+A.shift(2,dim));
}

template<class T> inline typename  T::T_numtype  central34 (T& A, int dim = firstDim)  {
  return A.shift(-3,dim) - 8.*A.shift(-2,dim) +13.*A.shift(-1,dim) 
     -13.*A.shift(1,dim)+8.*A.shift(2,dim)-A.shift(3,dim);
}

template<class T> inline typename  T::T_numtype  central44 (T& A, int dim = firstDim)  {
  return -1.*A.shift(-3,dim)+12.*A.shift(-2,dim)-39.*A.shift(-1,dim)
    +56.*A-39.*A.shift(1,dim)+12.*A.shift(2,dim)-A.shift(3,dim);
}

 



template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  central14 (T& A, int comp, int dim)  {
  return A.shift(-2,dim)[comp] - 8. * A.shift(-1,dim)[comp] 
    + 8. * A.shift(1,dim)[comp] - A.shift(2,dim)[comp];
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  central24 (T& A, int comp, int dim)  {
  return - A.shift(-2,dim)[comp] + 16.*A.shift(-1,dim)[comp] - 30.*(*A)[comp]
    + 16.*A.shift(1,dim)[comp] - A.shift(2,dim)[comp];
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  central34 (T& A, int comp, int dim)  {
  return A.shift(-3,dim)[comp] - 8.*A.shift(-2,dim)[comp] 
    +13.*A.shift(-1,dim)[comp] - 13.*A.shift(1,dim)[comp] 
    + 8.*A.shift(2,dim)[comp] - A.shift(3,dim)[comp];
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  central44 (T& A, int comp, int dim)  {
  return -1.*A.shift(-3,dim)[comp]+12.*A.shift(-2,dim)[comp]
    -39.*A.shift(-1,dim)[comp] +56.*(*A)[comp]-39.*A.shift(1,dim)[comp]
    +12.*A.shift(2,dim)[comp]-A.shift(3,dim)[comp];
}

 



template<class T> inline typename  T::T_numtype  central14n (T& A, int dim = firstDim)  {
  return central14(A,dim) * recip_12;
}

template<class T> inline typename  T::T_numtype  central24n (T& A, int dim = firstDim)  {
  return central24(A,dim) * recip_12;
}

template<class T> inline typename  T::T_numtype  central34n (T& A, int dim = firstDim)  {
  return central34(A,dim) * recip_8;
}

template<class T> inline typename  T::T_numtype  central44n (T& A, int dim = firstDim)  {
  return central44(A,dim) * recip_6;
}

 



template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  central14n (T& A, int comp, int dim)  {
  return central14(A,comp,dim) * recip_12;
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  central24n (T& A, int comp, int dim)  {
  return central24(A,comp,dim) * recip_12;
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  central34n (T& A, int comp, int dim)  {
  return central34(A,comp,dim) * recip_8;
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  central44n (T& A, int comp, int dim)  {
  return central44(A,comp,dim) * recip_6;
}

 



template<class T> inline typename  T::T_numtype  backward11 (T& A, int dim = firstDim)  {
  return A - A.shift(-1,dim);
}

template<class T> inline typename  T::T_numtype  backward21 (T& A, int dim = firstDim)  {
  return A -2.*A.shift(-1,dim) + A.shift(-2,dim);
}

template<class T> inline typename  T::T_numtype  backward31 (T& A, int dim = firstDim)  {
  return A -3.*A.shift(-1,dim) + 3.*A.shift(-2,dim)-A.shift(-3,dim);
}

template<class T> inline typename  T::T_numtype  backward41 (T& A, int dim = firstDim)  {
  return A - 4.*A.shift(-1,dim) + 6.*A.shift(-2,dim) -4.*A.shift(-3,dim) 
    + A.shift(-4,dim);
}

 



template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  backward11 (T& A, int comp, int dim)  {
  return (*A)[comp] - A.shift(-1,dim)[comp];
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  backward21 (T& A, int comp, int dim)  {
  return (*A)[comp] -2.*A.shift(-1,dim)[comp] + A.shift(-2,dim)[comp];
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  backward31 (T& A, int comp, int dim)  {
  return (*A)[comp] -3.*A.shift(-1,dim)[comp] + 3.*A.shift(-2,dim)[comp]
    -A.shift(-3,dim)[comp];
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  backward41 (T& A, int comp, int dim)  {
  return (*A)[comp] - 4.*A.shift(-1,dim)[comp] + 6.*A.shift(-2,dim)[comp]
    -4.*A.shift(-3,dim)[comp] + A.shift(-4,dim)[comp];
}

 



template<class T> inline typename  T::T_numtype  backward11n (T& A, int dim = firstDim)  { return backward11(A,dim); }
template<class T> inline typename  T::T_numtype  backward21n (T& A, int dim = firstDim)  { return backward21(A,dim); }
template<class T> inline typename  T::T_numtype  backward31n (T& A, int dim = firstDim)  { return backward31(A,dim); }
template<class T> inline typename  T::T_numtype  backward41n (T& A, int dim = firstDim)  { return backward41(A,dim); }

 



template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  backward11n (T& A, int comp, int dim)  { return backward11(A,comp,dim); }
template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  backward21n (T& A, int comp, int dim)  { return backward21(A,comp,dim); }
template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  backward31n (T& A, int comp, int dim)  { return backward31(A,comp,dim); }
template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  backward41n (T& A, int comp, int dim)  { return backward41(A,comp,dim); }

 



template<class T> inline typename  T::T_numtype  backward12 (T& A, int dim = firstDim)  {
  return 3.*A -4.*A.shift(-1,dim) + A.shift(-2,dim);
}

template<class T> inline typename  T::T_numtype  backward22 (T& A, int dim = firstDim)  {
  return 2.*A -5.*A.shift(-1,dim) + 4.*A.shift(-2,dim) -A.shift(-3,dim);
}

template<class T> inline typename  T::T_numtype  backward32 (T& A, int dim = firstDim)  {
  return 5.*A - 18.*A.shift(-1,dim) + 24.*A.shift(-2,dim) -14.*A.shift(-3,dim) 
    + 3.*A.shift(-4,dim);
}

template<class T> inline typename  T::T_numtype  backward42 (T& A, int dim = firstDim)  {
  return 3.*A -14.*A.shift(-1,dim) + 26.*A.shift(-2,dim) -24.*A.shift(-3,dim) 
    + 11.*A.shift(-4,dim) -2.*A.shift(-5,dim);
}

 



template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  backward12 (T& A, int comp, int dim)  {
  return 3.*(*A)[comp] -4.*A.shift(-1,dim)[comp] + A.shift(-2,dim)[comp];
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  backward22 (T& A, int comp, int dim)  {
  return 2.*(*A)[comp] -5.*A.shift(-1,dim)[comp] + 4.*A.shift(-2,dim)[comp]
     -A.shift(-3,dim)[comp];
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  backward32 (T& A, int comp, int dim)  {
  return 5.*(*A)[comp] - 18.*A.shift(-1,dim)[comp] + 24.*A.shift(-2,dim)[comp]
     -14.*A.shift(-3,dim)[comp] + 3.*A.shift(-4,dim)[comp];
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  backward42 (T& A, int comp, int dim)  {
  return 3.*(*A)[comp] -14.*A.shift(-1,dim)[comp] + 26.*A.shift(-2,dim)[comp]
    -24.*A.shift(-3,dim)[comp] + 11.*A.shift(-4,dim)[comp] 
    -2.*A.shift(-5,dim)[comp];
}

 



template<class T> inline typename  T::T_numtype  backward12n (T& A, int dim = firstDim)  { return backward12(A,dim) * recip_2; }
template<class T> inline typename  T::T_numtype  backward22n (T& A, int dim = firstDim)  { return backward22(A,dim); }
template<class T> inline typename  T::T_numtype  backward32n (T& A, int dim = firstDim)  { return backward32(A,dim) * recip_2; }
template<class T> inline typename  T::T_numtype  backward42n (T& A, int dim = firstDim)  { return backward42(A,dim); }

 



template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  backward12n (T& A, int comp, int dim)  { return backward12(A,comp,dim) * recip_2; }
template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  backward22n (T& A, int comp, int dim)  { return backward22(A,comp,dim); }
template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  backward32n (T& A, int comp, int dim)  { return backward32(A,comp,dim) * recip_2; }
template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  backward42n (T& A, int comp, int dim)  { return backward42(A,comp,dim); }

 



template<class T> inline typename  T::T_numtype  forward11 (T& A, int dim = firstDim)  {
  return A.shift(1,dim) - A;
}

template<class T> inline typename  T::T_numtype  forward21 (T& A, int dim = firstDim)  {
  return A - 2.*A.shift(1,dim) + A.shift(2,dim);
}

template<class T> inline typename  T::T_numtype  forward31 (T& A, int dim = firstDim)  {
  return -A + 3.*A.shift(1,dim) -3.*A.shift(2,dim) + A.shift(3,dim);
}

template<class T> inline typename  T::T_numtype  forward41 (T& A, int dim = firstDim)  {
  return A -4.*A.shift(1,dim) + 6.*A.shift(2,dim) -4.*A.shift(3,dim) 
    + A.shift(4,dim);
}

 



template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  forward11 (T& A, int comp, int dim)  {
  return -(*A)[comp]+A.shift(1,dim)[comp];
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  forward21 (T& A, int comp, int dim)  {
  return (*A)[comp] - 2.*A.shift(1,dim)[comp] + A.shift(2,dim)[comp];
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  forward31 (T& A, int comp, int dim)  {
  return -(*A)[comp] + 3.*A.shift(1,dim)[comp] -3.*A.shift(2,dim)[comp] 
    + A.shift(3,dim)[comp];
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  forward41 (T& A, int comp, int dim)  {
  return (*A)[comp] -4.*A.shift(1,dim)[comp] + 6.*A.shift(2,dim)[comp] 
    -4.*A.shift(3,dim)[comp] + A.shift(4,dim)[comp];
}

 



template<class T> inline typename  T::T_numtype  forward11n (T& A, int dim = firstDim)  { return forward11(A,dim); }
template<class T> inline typename  T::T_numtype  forward21n (T& A, int dim = firstDim)  { return forward21(A,dim); }
template<class T> inline typename  T::T_numtype  forward31n (T& A, int dim = firstDim)  { return forward31(A,dim); }
template<class T> inline typename  T::T_numtype  forward41n (T& A, int dim = firstDim)  { return forward41(A,dim); }

 



template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  forward11n (T& A, int comp, int dim)  { return forward11(A,comp,dim); }
template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  forward21n (T& A, int comp, int dim)  { return forward21(A,comp,dim); }
template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  forward31n (T& A, int comp, int dim)  { return forward31(A,comp,dim); }
template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  forward41n (T& A, int comp, int dim)  { return forward41(A,comp,dim); }

 



template<class T> inline typename  T::T_numtype  forward12 (T& A, int dim = firstDim)  {
  return -3.*A + 4.*A.shift(1,dim) - A.shift(2,dim);
}

template<class T> inline typename  T::T_numtype  forward22 (T& A, int dim = firstDim)  {
  return 2.*A -5.*A.shift(1,dim) + 4.*A.shift(2,dim) -A.shift(3,dim);
}

template<class T> inline typename  T::T_numtype  forward32 (T& A, int dim = firstDim)  {
  return -5.*A + 18.*A.shift(1,dim) -24.*A.shift(2,dim) 
    + 14.*A.shift(3,dim) -3.*A.shift(4,dim);
}

template<class T> inline typename  T::T_numtype  forward42 (T& A, int dim = firstDim)  {
  return 3.*A -14.*A.shift(1,dim) + 26.*A.shift(2,dim) -24.*A.shift(3,dim) 
    +11.*A.shift(4,dim) -2.*A.shift(5,dim);
}

 



template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  forward12 (T& A, int comp, int dim)  {
  return -3.*(*A)[comp] + 4.*A.shift(1,dim)[comp] - A.shift(2,dim)[comp];
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  forward22 (T& A, int comp, int dim)  {
  return 2.*(*A)[comp] -5.*A.shift(1,dim)[comp] + 4.*A.shift(2,dim)[comp] 
    -A.shift(3,dim)[comp];
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  forward32 (T& A, int comp, int dim)  {
  return -5.*(*A)[comp] + 18.*A.shift(1,dim)[comp] -24.*A.shift(2,dim)[comp]
    + 14.*A.shift(3,dim)[comp] -3.*A.shift(4,dim)[comp];
}

template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  forward42 (T& A, int comp, int dim)  {
  return 3.*(*A)[comp] -14.*A.shift(1,dim)[comp] + 26.*A.shift(2,dim)[comp] 
    -24.*A.shift(3,dim)[comp] +11.*A.shift(4,dim)[comp] 
    + 11.*A.shift(5,dim)[comp];
}


 



template<class T> inline typename  T::T_numtype  forward12n (T& A, int dim = firstDim)  { return forward12(A,dim) * recip_2; }
template<class T> inline typename  T::T_numtype  forward22n (T& A, int dim = firstDim)  { return forward22(A,dim); }
template<class T> inline typename  T::T_numtype  forward32n (T& A, int dim = firstDim)  { return forward32(A,dim) * recip_2; }
template<class T> inline typename  T::T_numtype  forward42n (T& A, int dim = firstDim)  { return forward42(A,dim); }

 



template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  forward12n (T& A, int comp, int dim)  { return forward12(A,comp,dim) * recip_2; }
template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  forward22n (T& A, int comp, int dim)  { return forward22(A,comp,dim); }
template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  forward32n (T& A, int comp, int dim)  { return forward32(A,comp,dim) * recip_2; }
template<class T> inline typename  multicomponent_traits< typename  T::T_numtype>::T_element  forward42n (T& A, int comp, int dim)  { return forward42(A,comp,dim); }

 



template<class T>
inline TinyVector< typename  T::T_numtype,2> grad2D(T& A) {
  return TinyVector< typename  T::T_numtype,2>(
    central12(A,firstDim),
    central12(A,secondDim));
}

template<class T>
inline TinyVector< typename  T::T_numtype,2> grad2D4(T& A) {
  return TinyVector< typename  T::T_numtype,2>(
    central14(A,firstDim),
    central14(A,secondDim));
}

template<class T>
inline TinyVector< typename  T::T_numtype,3> grad3D(T& A) {
  return TinyVector< typename  T::T_numtype,3>(
    central12(A,firstDim),
    central12(A,secondDim),
    central12(A,thirdDim));
}

template<class T>
inline TinyVector< typename  T::T_numtype,3> grad3D4(T& A) {
  return TinyVector< typename  T::T_numtype,3>(
    central14(A,firstDim),
    central14(A,secondDim),
    central14(A,thirdDim));
}

template<class T>
inline TinyVector< typename  T::T_numtype,2> grad2Dn(T& A) {
  return TinyVector< typename  T::T_numtype,2>(
    central12n(A,firstDim),
    central12n(A,secondDim));
}

template<class T>
inline TinyVector< typename  T::T_numtype,2> grad2D4n(T& A) {
  return TinyVector< typename  T::T_numtype,2>(
    central14n(A,firstDim),
    central14n(A,secondDim));
}

template<class T>
inline TinyVector< typename  T::T_numtype,3> grad3Dn(T& A) {
  return TinyVector< typename  T::T_numtype,3>(
    central12n(A,firstDim),
    central12n(A,secondDim),
    central12n(A,thirdDim));
}

template<class T>
inline TinyVector< typename  T::T_numtype,3> grad3D4n(T& A) {
  return TinyVector< typename  T::T_numtype,3>(
    central14n(A,firstDim),
    central14n(A,secondDim),
    central14n(A,thirdDim));
}

 



template<class T>
inline TinyVector< typename  T::T_numtype,2> gradSqr2D(T& A) {
  return TinyVector< typename  T::T_numtype,2>(
    central22(A,firstDim),
    central22(A,secondDim));
}

template<class T>
inline TinyVector< typename  T::T_numtype,2> gradSqr2D4(T& A) {
  return TinyVector< typename  T::T_numtype,2>(
    central24(A,firstDim),
    central24(A,secondDim));
}

template<class T>
inline TinyVector< typename  T::T_numtype,3> gradSqr3D(T& A) {
  return TinyVector< typename  T::T_numtype,3>(
    central22(A,firstDim),
    central22(A,secondDim),
    central22(A,thirdDim));
}

template<class T>
inline TinyVector< typename  T::T_numtype,3> gradSqr3D4(T& A) {
  return TinyVector< typename  T::T_numtype,3>(
    central24(A,firstDim),
    central24(A,secondDim),
    central24(A,thirdDim));
}

 



template<class T>
inline TinyVector< typename  T::T_numtype,2> gradSqr2Dn(T& A) {
  return gradSqr2D(A);
}

template<class T>
inline TinyVector< typename  T::T_numtype,2> gradSqr2D4n(T& A) {
  return TinyVector< typename  T::T_numtype,2>(
    central24(A,firstDim) * recip_12,
    central24(A,secondDim) * recip_12);
}

template<class T>
inline TinyVector< typename  T::T_numtype,3> gradSqr3Dn(T& A) {
  return gradSqr3D(A);
}

template<class T>
inline TinyVector< typename  T::T_numtype,3> gradSqr3D4n(T& A) {
  return TinyVector< typename  T::T_numtype,3>(
    central24(A,firstDim) * recip_12,
    central24(A,secondDim) * recip_12,
    central24(A,thirdDim) * recip_12);
}

 



template<class T>
inline TinyMatrix< typename  multicomponent_traits< typename  
    T::T_numtype>::T_element, 3, 3>
Jacobian3D(T& A)
{
    const int x=0, y=1, z=2;
    const int u=0, v=1, w=2;

    TinyMatrix< typename  multicomponent_traits< typename  
        T::T_numtype>::T_element, 3, 3> grad;

    grad(u,x) = central12(A,u,x);
    grad(u,y) = central12(A,u,y);
    grad(u,z) = central12(A,u,z);
    grad(v,x) = central12(A,v,x);
    grad(v,y) = central12(A,v,y);
    grad(v,z) = central12(A,v,z);
    grad(w,x) = central12(A,w,x);
    grad(w,y) = central12(A,w,y);
    grad(w,z) = central12(A,w,z);

    return grad;
}

template<class T>
inline TinyMatrix< typename  multicomponent_traits< typename  
    T::T_numtype>::T_element, 3, 3>
Jacobian3Dn(T& A)
{
    const int x=0, y=1, z=2;
    const int u=0, v=1, w=2;

    TinyMatrix< typename  multicomponent_traits< typename  
        T::T_numtype>::T_element, 3, 3> grad;
    
    grad(u,x) = central12n(A,u,x);
    grad(u,y) = central12n(A,u,y);
    grad(u,z) = central12n(A,u,z);
    grad(v,x) = central12n(A,v,x);
    grad(v,y) = central12n(A,v,y);
    grad(v,z) = central12n(A,v,z);
    grad(w,x) = central12n(A,w,x);
    grad(w,y) = central12n(A,w,y);
    grad(w,z) = central12n(A,w,z);

    return grad;
}

template<class T>
inline TinyMatrix< typename  multicomponent_traits< typename 
    T::T_numtype>::T_element, 3, 3>
Jacobian3D4(T& A)
{
    const int x=0, y=1, z=2;
    const int u=0, v=1, w=2;

    TinyMatrix< typename  multicomponent_traits< typename  
        T::T_numtype>::T_element, 3, 3> grad;
    
    grad(u,x) = central14(A,u,x);
    grad(u,y) = central14(A,u,y);
    grad(u,z) = central14(A,u,z);
    grad(v,x) = central14(A,v,x);
    grad(v,y) = central14(A,v,y);
    grad(v,z) = central14(A,v,z);
    grad(w,x) = central14(A,w,x);
    grad(w,y) = central14(A,w,y);
    grad(w,z) = central14(A,w,z);

    return grad;
}

template<class T>
inline TinyMatrix< typename  multicomponent_traits< typename 
    T::T_numtype>::T_element, 3, 3>
Jacobian3D4n(T& A)
{
    const int x=0, y=1, z=2;
    const int u=0, v=1, w=2;

    TinyMatrix< typename  multicomponent_traits< typename  
        T::T_numtype>::T_element, 3, 3> grad;
    
    grad(u,x) = central14n(A,u,x);
    grad(u,y) = central14n(A,u,y);
    grad(u,z) = central14n(A,u,z);
    grad(v,x) = central14n(A,v,x);
    grad(v,y) = central14n(A,v,y);
    grad(v,z) = central14n(A,v,z);
    grad(w,x) = central14n(A,w,x);
    grad(w,y) = central14n(A,w,y);
    grad(w,z) = central14n(A,w,z);

    return grad;
}

 



 

template<class T>
inline TinyVector< typename  T::T_numtype,3> 
curl(T& vx, T& vy, T& vz) {
  const int x = firstDim, y = secondDim, z = thirdDim;

  return TinyVector< typename  T::T_numtype,3>(
    central12(vz,y)-central12(vy,z),
    central12(vx,z)-central12(vz,x),
    central12(vy,x)-central12(vx,y));
}

 
template<class T>
inline TinyVector< typename  T::T_numtype,3>
curln(T& vx, T& vy, T& vz) {
  const int x = firstDim, y = secondDim, z = thirdDim;

  return TinyVector< typename  T::T_numtype,3>(
    (central12(vz,y)-central12(vy,z)) * recip_2,
    (central12(vx,z)-central12(vz,x)) * recip_2,
    (central12(vy,x)-central12(vx,y)) * recip_2);
}

 
template<class T>
inline typename  T::T_numtype curl(T& A) {
  const int x = firstDim, y = secondDim, z = thirdDim;

  return T::T_numtype(
    central12(A,z,y)-central12(A,y,z),
    central12(A,x,z)-central12(A,z,x),
    central12(A,y,x)-central12(A,x,y));
}

 
template<class T>
inline typename  T::T_numtype curln(T& A) {
  const int x = firstDim, y = secondDim, z = thirdDim;

  return T::T_numtype(
    (central12(A,z,y)-central12(A,y,z)) * recip_2,
    (central12(A,x,z)-central12(A,z,x)) * recip_2,
    (central12(A,y,x)-central12(A,x,y)) * recip_2);
}

 
template<class T>
inline TinyVector< typename  T::T_numtype,3>
curl4(T& vx, T& vy, T& vz) {
  const int x = firstDim, y = secondDim, z = thirdDim;

  return TinyVector< typename  T::T_numtype,3>(
    central14(vz,y)-central14(vy,z),
    central14(vx,z)-central14(vz,x),
    central14(vy,x)-central14(vx,y));
}

 
template<class T>
inline typename  T::T_numtype
curl4(T& A) {
  const int x = firstDim, y = secondDim, z = thirdDim;

  return T::T_numtype(
    central14(A,z,y)-central14(A,y,z),
    central14(A,x,z)-central14(A,z,x),
    central14(A,y,x)-central14(A,x,y));
}

 
template<class T>
inline TinyVector< typename  T::T_numtype,3>
curl4n(T& vx, T& vy, T& vz) {
  const int x = firstDim, y = secondDim, z = thirdDim;

  return TinyVector< typename  T::T_numtype,3>(
    (central14(vz,y)-central14(vy,z)) * recip_2,
    (central14(vx,z)-central14(vz,x)) * recip_2,
    (central14(vy,x)-central14(vx,y)) * recip_2);
}

 
template<class T>
inline typename  T::T_numtype
curl4n(T& A) {
  const int x = firstDim, y = secondDim, z = thirdDim;

  return T::T_numtype(
    (central14(A,z,y)-central14(A,y,z)) * recip_2,
    (central14(A,x,z)-central14(A,z,x)) * recip_2,
    (central14(A,y,x)-central14(A,x,y)) * recip_2);
}



 

template<class T>
inline typename  T::T_numtype
curl(T& vx, T& vy) {
  const int x = firstDim, y = secondDim;

  return central12(vy,x)-central12(vx,y);
}

template<class T>
inline typename  T::T_numtype
curln(T& vx, T& vy) {
  const int x = firstDim, y = secondDim;

  return (central12(vy,x)-central12(vx,y)) * recip_2;
}

 
template<class T>
inline typename  T::T_numtype::T_numtype curl2D(T& A) {
  const int x = firstDim, y = secondDim;
  return central12(A,y,x)-central12(A,x,y);
}

template<class T>
inline typename  T::T_numtype::T_numtype curl2Dn(T& A) {
  const int x = firstDim, y = secondDim;
  return (central12(A,y,x)-central12(A,x,y)) * recip_2;
}


 

template<class T>
inline typename  T::T_numtype
curl4(T& vx, T& vy) {
  const int x = firstDim, y = secondDim;

  return central14(vy,x)-central14(vx,y);
}

template<class T>
inline typename  T::T_numtype
curl4n(T& vx, T& vy) {
  const int x = firstDim, y = secondDim;

  return (central14(vy,x)-central14(vx,y)) * recip_12;
}

 
template<class T>
inline typename  T::T_numtype::T_numtype curl2D4(T& A) {
  const int x = firstDim, y = secondDim;
  return central14(A,y,x)-central14(A,x,y);
}

template<class T>
inline typename  T::T_numtype::T_numtype curl2D4n(T& A) {
  const int x = firstDim, y = secondDim;
  return (central14(A,y,x)-central14(A,x,y)) * recip_12;
}

 




template<class T> inline typename  T::T_numtype  div (T&  vx , T&  vy ) { 
  return central12(vx,firstDim) + central12(vy,secondDim);
} 

template<class T> inline typename  T::T_numtype  divn (T&  vx , T&  vy ) { 
  return (central12(vx,firstDim) + central12(vy,secondDim))
     * recip_2;
} 

template<class T> inline typename  T::T_numtype  div4 (T&  vx , T&  vy ) { 
  return central14(vx,firstDim) + central14(vy,secondDim);
} 

template<class T> inline typename  T::T_numtype  div4n (T&  vx , T&  vy ) { 
  return (central14(vx,firstDim) + central14(vy,secondDim))
    * recip_12;
} 

template<class T> inline typename  T::T_numtype  div (T&  vx , T&  vy , T&  vz ) { 
  return central12(vx,firstDim) + central12(vy,secondDim) 
    + central12(vz,thirdDim);
} 

template<class T> inline typename  T::T_numtype  divn (T&  vx , T&  vy , T&  vz ) { 
  return (central12(vx,firstDim) + central12(vy,secondDim) 
    + central12(vz,thirdDim)) * recip_2;
} 

template<class T> inline typename  T::T_numtype  div4 (T&  vx , T&  vy , T&  vz ) { 
  return central14(vx,firstDim) + central14(vy,secondDim) 
    + central14(vz,thirdDim);
} 

template<class T> inline typename  T::T_numtype  div4n (T&  vx , T&  vy , T&  vz ) { 
  return (central14(vx,firstDim) + central14(vy,secondDim)
    + central14(vz,thirdDim)) * recip_12;
} 

template<class T>
inline typename  T::T_numtype::T_numtype
div2D(T& A) {
  const int x = firstDim, y = secondDim;
  return central12(A,x,x) + central12(A,y,y);
}

template<class T>
inline typename  T::T_numtype::T_numtype
div2D4(T& A) {
  const int x = firstDim, y = secondDim;
  return central14(A,x,x) + central14(A,y,y);
}

template<class T>
inline typename  T::T_numtype::T_numtype
div2Dn(T& A) {
  const int x = firstDim, y = secondDim;
  return (central12(A,x,x) + central12(A,y,y)) * recip_2;
}

template<class T>
inline typename  T::T_numtype::T_numtype
div2D4n(T& A) {
  const int x = firstDim, y = secondDim;
  return (central14(A,x,x) + central14(A,y,y)) * recip_12;
}

template<class T>
inline typename  T::T_numtype::T_numtype
div3D(T& A) {
  const int x = firstDim, y = secondDim, z = thirdDim;
  return central12(A,x,x) + central12(A,y,y) + central12(A,z,z);
}

template<class T>
inline typename  T::T_numtype::T_numtype
div3D4(T& A) {
  const int x = firstDim, y = secondDim, z = thirdDim;
  return central14(A,x,x) + central14(A,y,y) + central14(A,z,z);
}

template<class T>
inline typename  T::T_numtype::T_numtype
div3Dn(T& A) {
  const int x = firstDim, y = secondDim, z = thirdDim;
  return (central12(A,x,x) + central12(A,y,y) + central12(A,z,z))
    * recip_2;
}

template<class T>
inline typename  T::T_numtype::T_numtype
div3D4n(T& A) {
  const int x = firstDim, y = secondDim, z = thirdDim;
  return (central14(A,x,x) + central14(A,y,y) + central14(A,z,z))
    * recip_12;
}

 



template<class T>
inline typename  T::T_numtype
mixed22(T& A, int x, int y)
{
    return A.shift(-1,x,-1,y) - A.shift(-1,x,1,y)
        -A.shift(1,x,-1,y) + A.shift(1,x,1,y);
}

template<class T>
inline typename  T::T_numtype
mixed22n(T& A, int x, int y)
{
    return mixed22(A, x, y) * recip_4;
}

template<class T>
inline typename  T::T_numtype
mixed24(T& A, int x, int y)
{
    return 64.*(A.shift(-1,x,-1,y) - A.shift(-1,x,1,y)
        -A.shift(1,x,-1,y) + A.shift(1,x,1,y))
        + (A.shift(-2,x,+1,y) - A.shift(-1,x,2,y)
        - A.shift(1,x,2,y)-A.shift(2,x,1,y)
        + A.shift(2,x,-1,y)+A.shift(1,x,-2,y)
        - A.shift(-1,x,-2,y)+A.shift(-2,x,-1,y))
        + 8.*(A.shift(-1,x,1,y)+A.shift(-1,x,2,y)
        -A.shift(2,x,-2,y) + A.shift(2,x,2,y));
}

template<class T>
inline typename  T::T_numtype
mixed24n(T& A, int x, int y)
{
    return mixed24(A,x,y) * recip_144;
}

 



 
 
 
 

 



template<class T>
inline typename  multicomponent_traits< typename 
    T::T_numtype>::T_element div3DVec4(T& A, 
    const UniformCubicGeometry<3>& geom)
{
    const int x = 0, y = 1, z = 2;

    return (central14(A, x, firstDim) + central14(A, y, secondDim)
        + central14(A, z, thirdDim)) * recip_12 * geom.recipSpatialStep();
}

template<class T>
inline typename  T::T_numtype Laplacian3D4(T& A, 
    const UniformCubicGeometry<3>& geom)
{
    return Laplacian3D4n(A) * geom.recipSpatialStepPow2();
}

template<class T>
inline typename  T::T_numtype Laplacian3DVec4(T& A,
    const UniformCubicGeometry<3>& geom)
{
    typedef typename  T::T_numtype vector3d;
    typedef typename  multicomponent_traits<vector3d>::T_element 
        T_element;
    const int u = 0, v = 1, w = 2;
    const int x = 0, y = 1, z = 2;

     
     

    T_element t1 = (central24(A,u,x) + central24(A,u,y) + central24(A,u,z))
        * recip_12 * geom.recipSpatialStepPow2();

    T_element t2 = (central24(A,v,x) + central24(A,v,y) + central24(A,v,z))
        * recip_12 * geom.recipSpatialStepPow2();

    T_element t3 = (central24(A,w,x) + central24(A,w,y) + central24(A,w,z))
        * recip_12 * geom.recipSpatialStepPow2();

    return vector3d(t1,t2,t3);
}

template<class T>
inline TinyMatrix< typename  multicomponent_traits< typename 
    T::T_numtype>::T_element, 3, 3>
grad3DVec4(T& A, const UniformCubicGeometry<3>& geom)
{
    const int x=0, y=1, z=2;
    const int u=0, v=1, w=2;

    TinyMatrix< typename  multicomponent_traits< typename 
        T::T_numtype>::T_element, 3, 3> grad;

     
    grad(u,x) = central14n(A,u,x) * geom.recipSpatialStep();
    grad(u,y) = central14n(A,u,y) * geom.recipSpatialStep();
    grad(u,z) = central14n(A,u,z) * geom.recipSpatialStep();
    grad(v,x) = central14n(A,v,x) * geom.recipSpatialStep();
    grad(v,y) = central14n(A,v,y) * geom.recipSpatialStep();
    grad(v,z) = central14n(A,v,z) * geom.recipSpatialStep();
    grad(w,x) = central14n(A,w,x) * geom.recipSpatialStep();
    grad(w,y) = central14n(A,w,y) * geom.recipSpatialStep();
    grad(w,z) = central14n(A,w,z) * geom.recipSpatialStep();

    return grad;
}

template<class T>
inline TinyVector< typename  T::T_numtype,3> grad3D4(T& A,
    const UniformCubicGeometry<3>& geom) {
  return TinyVector< typename  T::T_numtype,3>(
    central14(A,firstDim) * recip_12 * geom.recipSpatialStep(),
    central14(A,secondDim) * recip_12 * geom.recipSpatialStep(),
    central14(A,thirdDim) * recip_12 * geom.recipSpatialStep());
}

} 



# 8 "../blitz/array/stencil.h" 2


namespace  blitz  { 

 
 
 
 

 
















# 42 "../blitz/array/stencil.h"
















































































 




template<class T> class dummy;

struct dummyArray {
    typedef dummy<double> T_iterator;

    const dummyArray& shape() const { return *this; }
};

extern  dummyArray _dummyArray;

 



template<class T>
class dummy {
public:
    dummy() { }

    dummy(T value)
      : value_(value)
    { }

    dummy(const dummyArray&)
    { }

    operator T() const { return value_; };

    template<class T2>
    void operator=(T2) { }

    typename  multicomponent_traits<T>::T_element operator[](int i) const
    { return value_[i]; }

    void loadStride(int) { }
    void moveTo(int) { }
    void moveTo(int,int) { }
    void moveTo(int,int,int) { }
    void moveTo(int,int,int,int) { }
    void advance() { }
    T shift(int,int) { return T(); }

private:
    T value_;
};


 






template<int N_rank, class P_numtype>
class stencilExtent {
public:
    typedef P_numtype T_numtype;

    stencilExtent()
    {
        min_ = 0;
        max_ = 0;
    }
  
    dummy<T_numtype> operator()(int i)
    {
        update(0, i);
        return dummy<T_numtype>(1);
    }
 
    dummy<T_numtype> operator()(int i, int j)
    {
        update(0, i);
        update(1, j);
        return dummy<T_numtype>(1);
    }

    dummy<T_numtype> operator()(int i, int j, int k)
    {
        update(0, i);
        update(1, j);
        update(2, k);
        return dummy<T_numtype>(1);
    }

    dummy<T_numtype> shift(int offset, int dim)
    {
        update(dim, offset);
        return dummy<T_numtype>(1);
    }
  
    dummy<T_numtype> shift(int offset1, int dim1, int offset2, int dim2)
    {
        update(dim1, offset1);
        update(dim2, offset2);
        return dummy<T_numtype>(1);
    }
 
    dummy< typename  multicomponent_traits<T_numtype>::T_element> 
        operator[](int)
    {
        return dummy< typename  multicomponent_traits<T_numtype>::T_element>
            (1);
    }
 
    void update(int rank, int offset)
    {
        if (offset < min_[rank])
            min_[rank] = offset;
        if (offset > max_[rank])
            max_[rank] = offset;
    }

    template<class T_numtype2>
    void combine(const stencilExtent<N_rank,T_numtype2>& x)
    {
        for (int i=0; i < N_rank; ++i)
        {
            min_[i] = minmax::min(min_[i], x.min(i));
            max_[i] = minmax::max(max_[i], x.max(i));
        }
    }

    template<class T_numtype2>
    void combine(const dummy<T_numtype2>&)
    { }

    int min(int i) const
    { return min_[i]; }

    int max(int i) const
    { return max_[i]; }

    const TinyVector<int,N_rank>& min() const
    { return min_; }

    const TinyVector<int,N_rank>& max() const
    { return max_; }

    template<class T>
    void operator=(T)
    { }

     
    template<class T> void operator+=(T) { }
    template<class T> void operator-=(T) { }
    template<class T> void operator*=(T) { }
    template<class T> void operator/=(T) { }

    operator T_numtype()
    { return T_numtype(1); }

    T_numtype operator*()
    { return T_numtype(1); }
 
private:
    mutable  TinyVector<int,N_rank> min_, max_;
};


 



template<class T>
struct stencilExtent_traits {
    typedef dummy<double> T_stencilExtent;
};

template<class T_numtype, int N_rank>
struct stencilExtent_traits<Array<T_numtype,N_rank> > {
    typedef stencilExtent<N_rank,T_numtype> T_stencilExtent;
};

 




template<class T_shape1>
inline bool  areShapesConformable(const T_shape1&, const dummyArray&)
{
    return true ;
}

} 

# 1 "../blitz/array/stencil.cc" 1







namespace  blitz  { 

 
 
 
 
 
 
 
 

 


















template<int N_rank, class T_numtype1, class T_array2,
    class T_array3, class T_array4, class T_array5, class T_array6,
    class T_array7, class T_array8, class T_array9, class T_array10,
    class T_array11>
void checkShapes(const Array<T_numtype1,N_rank>& A,
    const T_array2& B, const T_array3& C, const T_array4& D, 
    const T_array5& E, const T_array6& F, const T_array7& G, 
    const T_array8& H, const T_array9& I, const T_array10& J, 
    const T_array11& K)
{
     ;
# 58 "../blitz/array/stencil.cc"
}

template<class T_extent, int N_rank, 
    class T_stencil, class T_numtype1, class T_array2,
    class T_array3, class T_array4, class T_array5, class T_array6,
    class T_array7, class T_array8, class T_array9, class T_array10,
    class T_array11>
void calcStencilExtent(T_extent& At, const T_stencil& stencil, 
    const Array<T_numtype1,N_rank>& A,
    const T_array2& B, const T_array3& C, const T_array4& D, const T_array5& E, 
    const T_array6& F, const T_array7& G, const T_array8& H, const T_array9& I, 
    const T_array10& J, const T_array11& K)
{
     
    typename  stencilExtent_traits<T_array2>::T_stencilExtent Bt;
    typename  stencilExtent_traits<T_array3>::T_stencilExtent Ct;
    typename  stencilExtent_traits<T_array4>::T_stencilExtent Dt;
    typename  stencilExtent_traits<T_array5>::T_stencilExtent Et;
    typename  stencilExtent_traits<T_array6>::T_stencilExtent Ft;
    typename  stencilExtent_traits<T_array7>::T_stencilExtent Gt;
    typename  stencilExtent_traits<T_array8>::T_stencilExtent Ht;
    typename  stencilExtent_traits<T_array9>::T_stencilExtent It;
    typename  stencilExtent_traits<T_array10>::T_stencilExtent Jt;
    typename  stencilExtent_traits<T_array11>::T_stencilExtent Kt;

    stencil.apply(At, Bt, Ct, Dt, Et, Ft, Gt, Ht, It, Jt, Kt);
    At.combine(Bt);
    At.combine(Ct);
    At.combine(Dt);
    At.combine(Et);
    At.combine(Ft);
    At.combine(Gt);
    At.combine(Ht);
    At.combine(It);
    At.combine(Jt);
    At.combine(Kt);
}

template<int N_rank, class T_stencil, class T_numtype1, class T_array2>
RectDomain<N_rank> interiorDomain(const T_stencil& stencil,
    const Array<T_numtype1,N_rank>& A,
    const T_array2& B)
{
    RectDomain<N_rank> domain = A.domain();

     
    stencilExtent<3, T_numtype1> At;
    calcStencilExtent(At, stencil, A, B, _dummyArray, _dummyArray, 
        _dummyArray, _dummyArray, _dummyArray, _dummyArray, _dummyArray, 
        _dummyArray, _dummyArray);

     
    TinyVector<int,N_rank> lbound, ubound;
    lbound = domain.lbound() - At.min();
    ubound = domain.ubound() - At.max();
    return RectDomain<N_rank>(lbound,ubound);
}

template<int hasExtents>
struct _getStencilExtent {
template<int N_rank,
    class T_stencil, class T_numtype1, class T_array2,
    class T_array3, class T_array4, class T_array5, class T_array6,
    class T_array7, class T_array8, class T_array9, class T_array10,
    class T_array11>
static void getStencilExtent(TinyVector<int,N_rank>& minb,
    TinyVector<int,N_rank>& maxb,
    const T_stencil& stencil, Array<T_numtype1,N_rank>& A,
    T_array2& B, T_array3& C, T_array4& D, T_array5& E, T_array6& F,
    T_array7& G, T_array8& H, T_array9& I, T_array10& J, T_array11& K)
{
     
    stencilExtent<N_rank, T_numtype1> At;
    calcStencilExtent(At, stencil, A, B, C, D, E, F, G, H, I, J, K);
    minb = At.min();
    maxb = At.max();
}
};

template<>
struct _getStencilExtent<1> {
template<int N_rank,
    class T_stencil, class T_numtype1, class T_array2,
    class T_array3, class T_array4, class T_array5, class T_array6,
    class T_array7, class T_array8, class T_array9, class T_array10,
    class T_array11>
static inline void getStencilExtent(TinyVector<int,N_rank>& minb,
    TinyVector<int,N_rank>& maxb,
    const T_stencil& stencil, Array<T_numtype1,N_rank>& A,
    T_array2& B, T_array3& C, T_array4& D, T_array5& E, T_array6& F,
    T_array7& G, T_array8& H, T_array9& I, T_array10& J, T_array11& K)
{
    stencil.getExtent(minb, maxb);
}
};

template<int N_rank,
    class T_stencil, class T_numtype1, class T_array2,
    class T_array3, class T_array4, class T_array5, class T_array6,
    class T_array7, class T_array8, class T_array9, class T_array10,
    class T_array11>
inline void getStencilExtent(TinyVector<int,N_rank>& minb,
    TinyVector<int,N_rank>& maxb,
    const T_stencil& stencil, Array<T_numtype1,N_rank>& A,
    T_array2& B, T_array3& C, T_array4& D, T_array5& E, T_array6& F,
    T_array7& G, T_array8& H, T_array9& I, T_array10& J, T_array11& K)
{
    _getStencilExtent<T_stencil::hasExtent>::getStencilExtent(
        minb, maxb, stencil, A, B, C, D, E, F, G, H, I, J, K);
}

 




template<class T_stencil, class T_numtype1, class T_array2,
    class T_array3, class T_array4, class T_array5, class T_array6,
    class T_array7, class T_array8, class T_array9, class T_array10,
    class T_array11>
void applyStencil_imp(const T_stencil& stencil, Array<T_numtype1,3>& A,
    T_array2& B, T_array3& C, T_array4& D, T_array5& E, T_array6& F,
    T_array7& G, T_array8& H, T_array9& I, T_array10& J, T_array11& K)
{
    checkShapes(A,B,C,D,E,F,G,H,I,J,K);
 
     
    TinyVector<int,3> minb, maxb;
    getStencilExtent(minb, maxb, stencil, A, B, C, D, E, F, G, H, I, J, K);

     
     
     
    int stencil_lbound0 = minb(0);
    int stencil_lbound1 = minb(1);
    int stencil_lbound2 = minb(2);

    int stencil_ubound0 = maxb(0);
    int stencil_ubound1 = maxb(1);
    int stencil_ubound2 = maxb(2);

    int lbound0 = minmax::max(A.lbound(0), A.lbound(0) - stencil_lbound0);
    int lbound1 = minmax::max(A.lbound(1), A.lbound(1) - stencil_lbound1);
    int lbound2 = minmax::max(A.lbound(2), A.lbound(2) - stencil_lbound2);

    int ubound0 = minmax::min(A.ubound(0), A.ubound(0) - stencil_ubound0);
    int ubound1 = minmax::min(A.ubound(1), A.ubound(1) - stencil_ubound1);
    int ubound2 = minmax::min(A.ubound(2), A.ubound(2) - stencil_ubound2);








     
    FastArrayIterator<T_numtype1,3> Aiter(A);
    typename  T_array2::T_iterator Biter(B);
    typename  T_array3::T_iterator Citer(C);
    typename  T_array4::T_iterator Diter(D);
    typename  T_array5::T_iterator Eiter(E);
    typename  T_array6::T_iterator Fiter(F);
    typename  T_array7::T_iterator Giter(G);
    typename  T_array8::T_iterator Hiter(H);
    typename  T_array9::T_iterator Iiter(I);
    typename  T_array10::T_iterator Jiter(J);
    typename  T_array11::T_iterator Kiter(K);

     
    Aiter.loadStride(2);
    Biter.loadStride(2);
    Citer.loadStride(2);
    Diter.loadStride(2);
    Eiter.loadStride(2);
    Fiter.loadStride(2);
    Giter.loadStride(2);
    Hiter.loadStride(2);
    Iiter.loadStride(2);
    Jiter.loadStride(2);
    Kiter.loadStride(2);

    for (int i=lbound0; i <= ubound0; ++i)
    {
      for (int j=lbound1; j <= ubound1; ++j)
      {
        Aiter.moveTo(i,j,lbound2);
        Biter.moveTo(i,j,lbound2);
        Citer.moveTo(i,j,lbound2);
        Diter.moveTo(i,j,lbound2);
        Eiter.moveTo(i,j,lbound2);
        Fiter.moveTo(i,j,lbound2);
        Giter.moveTo(i,j,lbound2);
        Hiter.moveTo(i,j,lbound2);
        Iiter.moveTo(i,j,lbound2);
        Jiter.moveTo(i,j,lbound2);
        Kiter.moveTo(i,j,lbound2);

        for (int k=lbound2; k <= ubound2; ++k)
        {
            stencil.apply(Aiter, Biter, Citer, Diter, Eiter, Fiter, Giter,
                Hiter, Iiter, Jiter, Kiter);

            Aiter.advance();
            Biter.advance();
            Citer.advance();
            Diter.advance();
            Eiter.advance();
            Fiter.advance();
            Giter.advance();
            Hiter.advance();
            Iiter.advance();
            Jiter.advance();
            Kiter.advance();
        }
      }
    }
}

 




template<class T_stencil, class T_numtype1, class T_array2,
    class T_array3, class T_array4, class T_array5, class T_array6,
    class T_array7, class T_array8, class T_array9, class T_array10,
    class T_array11>
void applyStencil_imp(const T_stencil& stencil, Array<T_numtype1,2>& A,
    T_array2& B, T_array3& C, T_array4& D, T_array5& E, T_array6& F, 
    T_array7& G, T_array8& H, T_array9& I, T_array10& J, T_array11& K)
{
    checkShapes(A,B,C,D,E,F,G,H,I,J,K);

     
    TinyVector<int,2> minb, maxb;
    getStencilExtent(minb, maxb, stencil, A, B, C, D, E, F, G, H, I, J, K);

     
     
     
    int stencil_lbound0 = minb(0);
    int stencil_lbound1 = minb(1);

    int stencil_ubound0 = maxb(0);
    int stencil_ubound1 = maxb(1);

    int lbound0 = minmax::max(A.lbound(0), A.lbound(0) - stencil_lbound0);
    int lbound1 = minmax::max(A.lbound(1), A.lbound(1) - stencil_lbound1);

    int ubound0 = minmax::min(A.ubound(0), A.ubound(0) - stencil_ubound0);
    int ubound1 = minmax::min(A.ubound(1), A.ubound(1) - stencil_ubound1);







     
    FastArrayIterator<T_numtype1,2> Aiter(A);
    typename  T_array2::T_iterator Biter(B);
    typename  T_array3::T_iterator Citer(C);
    typename  T_array4::T_iterator Diter(D);
    typename  T_array5::T_iterator Eiter(E);
    typename  T_array6::T_iterator Fiter(F);
    typename  T_array7::T_iterator Giter(G);
    typename  T_array8::T_iterator Hiter(H);
    typename  T_array9::T_iterator Iiter(I);
    typename  T_array10::T_iterator Jiter(J);
    typename  T_array11::T_iterator Kiter(K);

     
    Aiter.loadStride(1);
    Biter.loadStride(1);
    Citer.loadStride(1);
    Diter.loadStride(1);
    Eiter.loadStride(1);
    Fiter.loadStride(1);
    Giter.loadStride(1);
    Hiter.loadStride(1);
    Iiter.loadStride(1);
    Jiter.loadStride(1);
    Kiter.loadStride(1);

    for (int i=lbound0; i <= ubound0; ++i)
    {
        Aiter.moveTo(i,lbound1);
        Biter.moveTo(i,lbound1);
        Citer.moveTo(i,lbound1);
        Diter.moveTo(i,lbound1);
        Eiter.moveTo(i,lbound1);
        Fiter.moveTo(i,lbound1);
        Giter.moveTo(i,lbound1);
        Hiter.moveTo(i,lbound1);
        Iiter.moveTo(i,lbound1);
        Jiter.moveTo(i,lbound1);
        Kiter.moveTo(i,lbound1);

        for (int k=lbound1; k <= ubound1; ++k)
        {
            stencil.apply(Aiter, Biter, Citer, Diter, Eiter, Fiter, Giter,
                Hiter, Iiter, Jiter, Kiter);

            Aiter.advance();
            Biter.advance();
            Citer.advance();
            Diter.advance();
            Eiter.advance();
            Fiter.advance();
            Giter.advance();
            Hiter.advance();
            Iiter.advance();
            Jiter.advance();
            Kiter.advance();
        }
    }
}

 




template<class T_stencil, class T_numtype1, class T_array2,
    class T_array3, class T_array4, class T_array5, class T_array6,
    class T_array7, class T_array8, class T_array9, class T_array10,
    class T_array11>
void applyStencil_imp(const T_stencil& stencil, Array<T_numtype1,1>& A,
    T_array2& B, T_array3& C, T_array4& D, T_array5& E, T_array6& F, 
    T_array7& G, T_array8& H, T_array9& I, T_array10& J, T_array11& K)
{
    checkShapes(A,B,C,D,E,F,G,H,I,J,K);

     
    TinyVector<int,1> minb, maxb;
    getStencilExtent(minb, maxb, stencil, A, B, C, D, E, F, G, H, I, J, K);

     
     
     
    int stencil_lbound0 = minb(0);
    int stencil_ubound0 = maxb(0);

    int lbound0 = minmax::max(A.lbound(0), A.lbound(0) - stencil_lbound0);
    int ubound0 = minmax::min(A.ubound(0), A.ubound(0) - stencil_ubound0);






     
    FastArrayIterator<T_numtype1,1> Aiter(A);
    typename  T_array2::T_iterator Biter(B);
    typename  T_array3::T_iterator Citer(C);
    typename  T_array4::T_iterator Diter(D);
    typename  T_array5::T_iterator Eiter(E);
    typename  T_array6::T_iterator Fiter(F);
    typename  T_array7::T_iterator Giter(G);
    typename  T_array8::T_iterator Hiter(H);
    typename  T_array9::T_iterator Iiter(I);
    typename  T_array10::T_iterator Jiter(J);
    typename  T_array11::T_iterator Kiter(K);

     
    Aiter.loadStride(0);
    Biter.loadStride(0);
    Citer.loadStride(0);
    Diter.loadStride(0);
    Eiter.loadStride(0);
    Fiter.loadStride(0);
    Giter.loadStride(0);
    Hiter.loadStride(0);
    Iiter.loadStride(0);
    Jiter.loadStride(0);
    Kiter.loadStride(0);

    for (int i=lbound0; i <= ubound0; ++i)
    {
        stencil.apply(Aiter, Biter, Citer, Diter, Eiter, Fiter, Giter,
            Hiter, Iiter, Jiter, Kiter);

        Aiter.advance();
        Biter.advance();
        Citer.advance();
        Diter.advance();
        Eiter.advance();
        Fiter.advance();
        Giter.advance();
        Hiter.advance();
        Iiter.advance();
        Jiter.advance();
        Kiter.advance();
    }
}

 




template<class T_stencil, class T_numtype1, int N_rank>
inline void applyStencil(const T_stencil& stencil, Array<T_numtype1,N_rank>& A)
{
    applyStencil_imp(stencil, A, _dummyArray, _dummyArray,
        _dummyArray, _dummyArray, _dummyArray, _dummyArray,
        _dummyArray, _dummyArray, _dummyArray, _dummyArray);
}

template<class T_stencil, class T_numtype1, int N_rank, class T_array2>
inline void applyStencil(const T_stencil& stencil, Array<T_numtype1,N_rank>& A,
    T_array2& B)
{
    applyStencil_imp(stencil, A, B, _dummyArray, _dummyArray,
        _dummyArray, _dummyArray, _dummyArray, _dummyArray,
        _dummyArray, _dummyArray, _dummyArray);
}

template<class T_stencil, class T_numtype1, int N_rank, class T_array2,
    class T_array3>
inline void applyStencil(const T_stencil& stencil, Array<T_numtype1,N_rank>& A,
    T_array2& B, T_array3& C)
{
    applyStencil_imp(stencil, A, B, C, _dummyArray, _dummyArray,
        _dummyArray, _dummyArray, _dummyArray, _dummyArray, _dummyArray,
        _dummyArray);
}

template<class T_stencil, class T_numtype1, int N_rank, class T_array2,
    class T_array3, class T_array4>
inline void applyStencil(const T_stencil& stencil, Array<T_numtype1,N_rank>& A,
    T_array2& B, T_array3& C, T_array4& D)
{
    applyStencil_imp(stencil, A, B, C, D, _dummyArray, _dummyArray,
        _dummyArray, _dummyArray, _dummyArray, _dummyArray, _dummyArray);
}

template<class T_stencil, class T_numtype1, int N_rank, class T_array2,
    class T_array3, class T_array4, class T_array5>
inline void applyStencil(const T_stencil& stencil, Array<T_numtype1,N_rank>& A,
   T_array2& B, T_array3& C, T_array4& D, T_array5& E)
{
    applyStencil_imp(stencil, A, B, C, D, E, _dummyArray,
        _dummyArray, _dummyArray, _dummyArray, _dummyArray, _dummyArray);
}

template<class T_stencil, class T_numtype1, int N_rank, class T_array2,
    class T_array3, class T_array4, class T_array5, class T_array6>
inline void applyStencil(const T_stencil& stencil, Array<T_numtype1,N_rank>& A,
   T_array2& B, T_array3& C, T_array4& D, T_array5& E, T_array6& F)
{
    applyStencil_imp(stencil, A, B, C, D, E, F,
        _dummyArray, _dummyArray, _dummyArray, _dummyArray, _dummyArray);
}

template<class T_stencil, class T_numtype1, int N_rank, class T_array2,
    class T_array3, class T_array4, class T_array5, class T_array6,
    class T_array7>
inline void applyStencil(const T_stencil& stencil, Array<T_numtype1,N_rank>& A,
   T_array2& B, T_array3& C, T_array4& D, T_array5& E, T_array6& F,
   T_array7& G)
{
    applyStencil_imp(stencil, A, B, C, D, E, F, G,
        _dummyArray, _dummyArray, _dummyArray, _dummyArray);
}

template<class T_stencil, class T_numtype1, int N_rank, class T_array2,
    class T_array3, class T_array4, class T_array5, class T_array6,
    class T_array7, class T_array8>
inline void applyStencil(const T_stencil& stencil, Array<T_numtype1,N_rank>& A,
   T_array2& B, T_array3& C, T_array4& D, T_array5& E, T_array6& F,
   T_array7& G, T_array8& H)
{
    applyStencil_imp(stencil, A, B, C, D, E, F, G, H,
        _dummyArray, _dummyArray, _dummyArray);
}

template<class T_stencil, class T_numtype1, int N_rank, class T_array2,
    class T_array3, class T_array4, class T_array5, class T_array6,
    class T_array7, class T_array8, class T_array9>
inline void applyStencil(const T_stencil& stencil, Array<T_numtype1,N_rank>& A,
   T_array2& B, T_array3& C, T_array4& D, T_array5& E, T_array6& F,
   T_array7& G, T_array8& H, T_array9& I)
{
    applyStencil_imp(stencil, A, B, C, D, E, F, G, H, I,
        _dummyArray, _dummyArray);
}

template<class T_stencil, class T_numtype1, int N_rank, class T_array2,
    class T_array3, class T_array4, class T_array5, class T_array6,
    class T_array7, class T_array8, class T_array9, class T_array10>
inline void applyStencil(const T_stencil& stencil, Array<T_numtype1,N_rank>& A,
   T_array2& B, T_array3& C, T_array4& D, T_array5& E, T_array6& F,
   T_array7& G, T_array8& H, T_array9& I, T_array10& J)
{
    applyStencil_imp(stencil, A, B, C, D, E, F, G, H, I, J,
        _dummyArray);
}

template<class T_stencil, class T_numtype1, int N_rank, class T_array2,
    class T_array3, class T_array4, class T_array5, class T_array6,
    class T_array7, class T_array8, class T_array9, class T_array10,
    class T_array11>
inline void applyStencil(const T_stencil& stencil, Array<T_numtype1,N_rank>& A,
   T_array2& B, T_array3& C, T_array4& D, T_array5& E, T_array6& F,
   T_array7& G, T_array8& H, T_array9& I, T_array10& J, T_array11& K)
{
    applyStencil_imp(stencil, A, B, C, D, E, F, G, H, I, J, K);
}

} 


# 315 "../blitz/array/stencil.h" 2




# 2482 "../blitz/array.h" 2

# 1 "../blitz/array/indirect.h" 1




# 1 "../blitz/array/cartesian.h" 1



namespace  blitz  { 

 




 
template<class T_tuple, class T_container, int N_containers>
class CartesianProductIterator;

struct _cp_end_tag { };

template<class T_tuple, class T_container, int N_containers>
class CartesianProduct {
public:
    typedef T_tuple value_type;
    typedef T_tuple& reference;
    typedef const T_tuple& const_reference;
    typedef CartesianProductIterator<T_tuple,T_container,N_containers> iterator;
    typedef int difference_type;
    typedef int size_type;

    iterator begin()
    { return iterator(*this); }

    iterator end()
    { return iterator(_cp_end_tag()); }

    CartesianProduct(const T_container& container0, 
        const T_container& container1)
    { 
         ;
        containers_[0] = &container0;
        containers_[1] = &container1;
    }

    CartesianProduct(const T_container& container0, 
        const T_container& container1,
        const T_container& container2)
    { 
         ;
        containers_[0] = &container0;
        containers_[1] = &container1;
        containers_[2] = &container2;
    }

    const T_container& operator[](int i)
    { return *(containers_[i]); }

    void debugDump();

protected:
    const T_container* containers_[N_containers]; 
};

template<class T_tuple, class T_container, int N_containers>
void CartesianProduct<T_tuple,T_container,N_containers>::debugDump()
{
    cout << "Dump of CartesianProduct<..,..," << N_containers << ">" << endl;
    for (int i=0; i < N_containers; ++i)
    {
        cout << "Container " << (i+1) << ": ";
        typename  T_container::const_iterator iter = containers_[i]->begin(),
            end = containers_[i]->end();
        for (; iter != end; ++iter)
            cout << (*iter) << '\t'; 
    }
}

template<class T_tuple, class T_container, int N_containers>
class CartesianProductIterator {
public:
    typedef typename  T_container::const_iterator citerator;
    typedef CartesianProductIterator<T_tuple,T_container,N_containers> iterator;
    typedef CartesianProduct<T_tuple,T_container,N_containers> T_cp;

    CartesianProductIterator(T_cp& container)
    {
        for (int i=0; i < N_containers; ++i)
        {
            firstiters_[i] = container[i].begin();
            iters_[i] = firstiters_[i];
            enditers_[i] = container[i].end();
            tuple_[i] = *iters_[i];
        }

        endflag_ = false ;
    }

    void operator++();

    CartesianProductIterator(_cp_end_tag)
    {
        endflag_ = true ;
    }

    bool  operator==(const iterator& x) const
    {
        return (endflag_ == x.endflag_);
    }

    bool  operator!=(const iterator& x) const
    {   
        return endflag_ != x.endflag_;
    }

    const T_tuple& operator*() const
    { return tuple_; }

protected:
    citerator iters_[N_containers];
    citerator firstiters_[N_containers];
    citerator enditers_[N_containers];
    T_tuple tuple_;
    bool  endflag_;
};

template<class T_tuple, class T_container, int N_containers>
void CartesianProductIterator<T_tuple, T_container, 
    N_containers>::operator++()
{
     
     

     
    const int Nminus1 = N_containers - 1;

    int i = Nminus1;

    for (; i >= 0; --i)
    {
        ++iters_[i];
        if (iters_[i] != enditers_[i])
            break;
    }

    if (i == -1)
    {
        endflag_ = true ;
        return;
    }

    tuple_[i] = *iters_[i];

    for (++i; i < N_containers; ++i)  
    {
        iters_[i] = firstiters_[i];
        tuple_[i] = *iters_[i];
    }
}

} 



# 5 "../blitz/array/indirect.h" 2


namespace  blitz  { 

template<class T_array, class T_index>
class IndirectArray {

public:
    IndirectArray(T_array& array, T_index& index)
        : array_(array), index_(index)
    { }

    template<class T_expr>
    void operator=(T_expr expr);

protected:
    T_array& array_;
    T_index& index_;
};

 
template<class T_array, class T_arrayiter, class T_subdomain, class T_expr>
inline void applyOverSubdomain(const T_array& array, T_arrayiter& arrayIter,
    T_subdomain subdomain, T_expr expr);
template<class T_array, class T_arrayiter, int N_rank, class T_expr>
inline void applyOverSubdomain(const T_array& array, T_arrayiter& arrayIter,
    RectDomain<N_rank> subdomain,
    T_expr expr);

template<class T_array, class T_index> template<class T_rhs>
void IndirectArray<T_array, T_index>::operator=(T_rhs rhs)
{
    typedef typename  asExpr<T_rhs>::T_expr T_expr;
    T_expr expr(rhs);

    typename  T_array::T_iterator arrayIter(array_);

    typename  T_index::iterator iter = index_.begin(),
                       end = index_.end();

    for (; iter != end; ++iter)
    {
        typename  T_index::value_type subdomain = *iter;
        applyOverSubdomain(array_, arrayIter, subdomain, expr);
    }
}

template<class T_array, class T_arrayiter, class T_subdomain, class T_expr>
inline void applyOverSubdomain(const T_array& array, T_arrayiter& arrayIter, 
    T_subdomain subdomain, T_expr expr)
{
     






    arrayIter.moveTo(subdomain);
    expr.moveTo(subdomain);

    *const_cast< typename  T_arrayiter::T_numtype*>(arrayIter.data()) = *expr;
}

 
template<class T_array, class T_arrayiter, int N_rank, class T_expr>
inline void applyOverSubdomain(const T_array& array, T_arrayiter& arrayIter, 
    RectDomain<N_rank> subdomain,
    T_expr expr)
{
    typedef typename  T_array::T_numtype T_numtype;

     
     
     
     

    static int stripDim = 0;

    if (subdomain.lbound(stripDim) == subdomain.ubound(stripDim))
    {
         
        for (stripDim=0; stripDim < N_rank; ++stripDim)
          if (subdomain.lbound(stripDim) != subdomain.ubound(stripDim))
            break;

         
        if (stripDim == N_rank)
            stripDim = 0;
    }

# 105 "../blitz/array/indirect.h"


     
     







     







     
    arrayIter.moveTo(subdomain.lbound());
    expr.moveTo(subdomain.lbound());

     



    bool  useUnitStride = arrayIter.isUnitStride(stripDim)
          && expr.isUnitStride(stripDim);

    int lbound = subdomain.lbound(stripDim); 
    int ubound = subdomain.ubound(stripDim);

    if (useUnitStride)
    {
        T_numtype*   data = const_cast<T_numtype*>(arrayIter.data());

        int length = ubound - lbound + 1;
        for (int i=0; i < length; ++i)
            data[i] = expr.fastRead(i);
    }
    else {


    arrayIter.loadStride(stripDim);
    expr.loadStride(stripDim);

    for (int i=lbound; i <= ubound; ++i)
    {
        *const_cast< typename  T_arrayiter::T_numtype*>(arrayIter.data()) 
            = *expr;
        expr.advance();
        arrayIter.advance();
    }


    }

}

 
template<class T_container>
CartesianProduct<TinyVector<int,2>,T_container,2>
indexSet(const T_container& container0, const T_container& container1)
{
    return CartesianProduct<TinyVector<int,2>,T_container,2>(
        const_cast<T_container&>(container0), 
        const_cast<T_container&>(container1));
}

template<class T_container>
CartesianProduct<TinyVector<int,3>,T_container,3>
indexSet(const T_container& container0, const T_container& container1,
    const T_container& container2)
{
    return CartesianProduct<TinyVector<int,3>,T_container,3>(
        const_cast<T_container&>(container0), 
        const_cast<T_container&>(container1), 
        const_cast<T_container&>(container2));
}

 

 
 
 
 
 
 
 
 

template<class T1, class T2, class T3=int, class T4=int>
struct cp_findContainerType {
    typedef T1 T_container;
};

template<class T2, class T3, class T4>
struct cp_findContainerType<int,T2,T3,T4> {
    typedef typename  cp_findContainerType<T2,T3,T4>::T_container T_container;
};


 
 
 
 
 
 
 
 

template<class T, class T2>
struct cp_traits {
    typedef T T_container;

    static const T_container& make(const T& x)
    { return x; }
};

template<class T2>
struct cp_traits<int,T2> {
    typedef T2 T_container;

    static T2 make(int x)
    { 
        T2 singleton;
        singleton.push_back(x);
        return singleton;
    }
};

 
 
 

template<class T1, class T2>
CartesianProduct<TinyVector<int,2>, typename  
    cp_findContainerType<T1,T2>::T_container,2> 
indexSet(const T1& c1, const T2& c2)
{
    typedef typename  cp_findContainerType<T1,T2>::T_container
        T_container;

    return CartesianProduct<TinyVector<int,2>, T_container, 2>(
          cp_traits<T1,T_container>::make(c1),
          cp_traits<T2,T_container>::make(c2));
}

template<class T1, class T2, class T3>
CartesianProduct<TinyVector<int,3>, typename 
    cp_findContainerType<T1,T2,T3>::T_container, 3>
indexSet(const T1& c1, const T2& c2, const T3& c3)
{
    typedef typename  cp_findContainerType<T1,T2,T3>::T_container
        T_container;

    return CartesianProduct<TinyVector<int,3>, T_container, 3>(
          cp_traits<T1,T_container>::make(c1),
          cp_traits<T2,T_container>::make(c2),
          cp_traits<T3,T_container>::make(c3));
}

} 


# 2483 "../blitz/array.h" 2




# 1 "ctime3.cpp" 2


using namespace  blitz ; 

int main()
{
}

void foo()
{
    const int N = 10;
    Array<float,1> A(N), B(N), C(N), D(N), E(N);
    A = B*C + D*E;
    A = B+C + D*cos(E);
    A = B*sin(C) + D*sin(E);
    B = C + D;
    A = A+B+C+D;
}

